GS_VERSION = "v0.0.0-beta";
GS_GRAINS = null;
GS_REF = null;

## ------------------------------------------------------------

$addref = (
    $name, $description, $arguments, $output -> (
        GS_REF _= [
            $name
            [ "description:" $description ] 
            [ "arguments:" ($arguments ||| "none") ] 
            [ "output:" ($output ||| "null") ]
        ]
    )
);

## ------------------------------------------------------------

$addarg = (
    $name, $description, $type = "list", $default = null -> (
        [
            "@" + $name 
            [ "description:" $description ]
            [ "type:" $type ]
            (if $default != null then [ "default:" $default ])
        ]
    )
);

## ------------------------------------------------------------

$addout = (
    $description, $type -> [ "description:" $description ] [ "type:" $type ]
);

## ------------------------------------------------------------

msg = (
    $to, $msg -> (
        $do1 = [ $to $msg ]
    )
);

## ------------------------------------------------------------

sym = (
    $x -> (
        msg("sym", $x);
        GS_SYMBOL
    )
);

$addref(
    @name "sym",
    @description "Casts input value as a symbol.",
    @arguments (
        $addarg(@name "x",  @type "anything",@description "value to cast")
    ),
    @output $addout(@description "symbol", @type "symbol")
);

## ------------------------------------------------------------

pcdiff = (
	$a, $b, $mod = 12 -> ( 
		$a = fmod($a, $mod); 
		$b = fmod($b, $mod); 
		$da = $b - $a; 
		$db = $da + $mod * -(sgn($da) || 1); 
        $mask = max(0, sgn(abs($db) - abs($da)));
		$da * $mask + $db * (1 - $mask)
    ) 
);

$addref(
    @name "pcdiff",
    @description "Signed pitch class difference.",
    @arguments (
        $addarg(@name "a",  @type "int/float/list",@description "pitch classes.")
        $addarg(@name "b", @type "int/float/list",@description "pitch classes.")
    ),
    @output $addout(@description "signed difference", @type "int/float/list")
);

## ------------------------------------------------------------

setcorpus = (
    $filepath -> (
        GS_GRAINS = null;
        msg("db", "read" $filepath)
    )
);

$addref(
    @name "setcorpus",
    @description "Loads an audio corpus, given an absolute path to a .llll file. See #query function.",
    @arguments (
        $addarg(@name "filepath", @type "symbol", @description "file path to .llll corpus file.")
    )
);

## ------------------------------------------------------------

samplelist = (
    $x, $i -> (
        $N = length($x);
        $i = scale($i, 0, 1, 1, $N);
        $l = floor($i);
        $r = min($l + 1, $N);
        $m = fmod($i, 1);
        $x:$l * (1 - $m) + $x:$r * $m
    )
);

$addref(
    @name "samplelist",
    @description "Samples an interpolated value from a numeric list given a normalized index.",
    @arguments (
        $addarg(@name "x", @type "list", @description "list to sample from.")
        $addarg(@name "i", @type "list", @description "normalized sampling index.")
    ),
    @output $addout(@description "interpolated sample", @type "int/float/list")
);

## ------------------------------------------------------------

query = (
    $x = "SELECT * FROM grains" -> (
        msg("db", "query" $x);
        GS_GRAINS
    )
);

$addref(
    @name "query",
    @description "Executes an sqlite3 query on the current audio corpus, and returns the results. Every query should use 'grains' as the table name. For instance: 'SELECT * FROM grains'. See #setcorpus.",
    @arguments (
        $addarg(@name "query", @type "symbol", @default "'SELECT * FROM grains'", @description "sqlite3 query.")
    ),
    @output $addout(@description "list of grains", @type "llll")
);

## ------------------------------------------------------------

getkey = (
    $grain, $key -> ($grain::1).$key
);

$addref(
    @name "getkey",
    @description "Returns value associated with a grain's key.",
    @arguments (
        $addarg(@name "grain", @type "llll", @description "grain.")
        $addarg(@name "key", @type "symbol", @description "name of grain key.")
    ),
    @output $addout(@description "value associated with key", @type "anything")
);

## ------------------------------------------------------------

setkey = ($grain, $key, $val -> [ ($grain::1).$key = $val ]);

$addref(
    @name "setkey",
    @description "Modifies the key of a grain.",
    @arguments (
        $addarg(@name "grain", @type "llll", @description "grain to modify.")
        $addarg(@name "key", @type "symbol", @description "name of grain key.")
        $addarg(@name "val", @type "anything", @description "new value for grain key.")
    ),
    @output $addout(@description "modified grain", @type "llll")
);

## ------------------------------------------------------------

mapkey = (
    $grain, $key, $func -> (
        setkey($grain, $key, $func(getkey($grain, $key)))
    )
);

$addref(
    @name "mapkey",
    @description "Modifies the key of a grain via a lambda function.",
    @arguments (
        $addarg(@name "grain", @type "llll", @description "grain to modify.")
        $addarg(@name "key", @type "symbol", @description "name of grain key.")
        $addarg(@name "func", @type "lambda function", @description "lambda function with signature $currentvalue -> $newvalue.")
    ),
    @output $addout(@description "modified grain", @type "llll")
);

## ------------------------------------------------------------

bpf = (
    $pts, $func = null -> (
        $depth = depth($pts);
        $size = length($pts);
        if $depth == 1 then (
            for $p $i in $pts collect [ ($i - 1.) / max(1, $size - 1.) (if $func then $func($p) else $p) 0. ]
        ) else if $depth == 2 then (
            $cols = trans($pts);
            $dims = length($cols);
            $norm = maximum(($cols::1) ||| 1.);
            $x = [sort(float($cols::1) / if $norm != 0 then $norm else 1.)];
            $y = [ if $func then $func($cols::2) else $cols::2 ];
            $slope = [for $i in 1...$size collect ($pts::($i 3)) ||| 0];
            trans($x $y $slope)
        )
    )
);

$addref(
    @name "bpf",
    @description "Formats an numeric list into a breaking point function, in the form of [<x> <y> <slope>] tuples, where <x> is normalized to the 0-1 range.",
    @arguments (
        $addarg(@name "pts", @type "list", @description "numeric list")
        $addarg(@name "func", @type "function", @description "optional lambda function for y axis")
    ),
    @output $addout(@description "breaking point function", @type "llll")
);

## ------------------------------------------------------------

scale = (
    $x, $inmin = 0, $inmax = 1, $outmin = 0, $outmax = 1 -> (
        (($x - $inmin) / ($inmax - $inmin)) * ($outmax - $outmin) + $outmin
    )
);

$addref(
    @name "scale",
    @description "Scales an input value or list from a given range to another.",
    @arguments (
        $addarg(@name "x", @type "int/float/list", @description "value to scale.")
        $addarg(@name "inmin", @type "int/float", @default 0, @description "input minimum value.")
        $addarg(@name "inmax", @type "int/float", @default 1, @description "input maxiumum value.")
        $addarg(@name "outmin", @type "int/float", @default 0, @description "output minimum value.")
        $addarg(@name "outmax", @type "int/float", @default 1, @description "output maxiumum value.")
    ),
    @output $addout(@description "scaled input", @type "int/float/list/llll")
);

## ------------------------------------------------------------

rand = (
    $a = 1, $b = null, $res = 1000 -> (
        if $b == null then (
            $min = 0;
            $max = $a
        ) else (
            $min = $a;
            $max = $b
        );
        scale(random(0, $res), 0, $res, $min, $max)
    )
);

$addref(
    @name "rand",
    @description "Random floating point number generator.",
    @arguments (
        $addarg(@name "a", @type "int/float", @description "max. value if @b is null, else min. value.")
        $addarg(@name "b", @type "int/float", @description "min. value.")
        $addarg(@name "res", @type "int", @default 1000, @description "random value resolution.")
    ),
    @output $addout(@description "random floating point number", @type "int/float")
);

## ------------------------------------------------------------

choose = (
    $x, $n = 1 -> (
        for $i in 1...$n collect $x:(random(1, length($x)))
    )
);

$addref(
    @name "choose",
    @description "Choose randomly one or more elements from list.",
    @arguments (
        $addarg(@name "x", @type "list", @description "list to choose from.")
        $addarg(@name "n", @type "int", @description "number of random choices.")
    ),
    @output $addout(@description "random elements", @type "anything")
);

## ------------------------------------------------------------

c2r = (
    $cents -> 2 ** ($cents / 1200)
);

$addref(
    @name "c2r",
    @description "Cents to ratio conversion.",
    @arguments (
        $addarg(@name "cents", @type "list/int/float", @description "cents to convert.")
    ),
    @output $addout(@description "list of ratios", @type "int/float/list")
);

## ------------------------------------------------------------

r2c = (
    $r -> log2($r) * 1200
);

$addref(
    @name "r2c",
    @description "Ratio to cents conversion.",
    @arguments (
        $addarg(@name "ratios", @type "list/int/float", @description "ratios to convert.")
    ),
    @output $addout(@description "list of cents", @type "list/int/float")
);

## ------------------------------------------------------------

sortgrains = (
    $grains, $key -> (
        sort($grains, ($a, $b -^ $key -> (getkey($a, $key) < getkey($b, $key))))
    )
);

$addref(
    @name "sortgrains",
    @description "Sorts grains by a given key (grain_id, file_id, pitch, pitchclass, pitchsalience, duration, centroid, zerox, loudness, etc.)",
    @arguments (
        $addarg(@name "grains", @type "llll", @description "grains to sort.")
        $addarg(@name "key", @type "symbol", @description "grain key to sort by.")
    ),
    @output $addout(@description "list of sorted grains", @type "llll")
);

## ------------------------------------------------------------

filtergrains = (
    $grains, $func, $max = 0, $maxdepth = 1, $unwrap = 1 -> (
        $lambda = (
            $x  -^ $func -> (
                $func($x)
            )
        );
        finditems($grains, $max, $lambda, @maxdepth $maxdepth, @unwrap $unwrap)
    )
);

## ------------------------------------------------------------

pitchdiff = (
    $source, $targets -> (
        $distances = (
            if $targets:1 < 12 then (
                pcdiff($source / 100., $targets) * 100
            ) else (
                $targets - $source
            )
        );
        $distances:(minmax(abs($distances)):2)
    )
);

$addref(
    @name "pitchdiff",
    @description "Given a list of target midicents and/or pitch classes, returns the signed difference between a pitch in midicents and the nearest midicent/pitch class target.",
    @arguments (
        $addarg(@name "pitch", @type "int/float", @description "reference pitch in midicents.")
        $addarg(@name "targets", @type "int/float/list", @description "list of midicent or pitch class targets.")
    ),
    @output $addout(@description "signed difference to closest target, in cents.", @type "int/float")
);

## ------------------------------------------------------------

detuning = (
    $grain, $targets -> (
        $source = getkey($grain, "pitch");
        pitchdiff($source, $targets)
    )
);

$addref(
    @name "detuning",
    @description "Given a list of target midicents and/or pitch classes, returns the difference between a grains' original pitch and the nearest midicent/pitch class target. See #transcribe function.",
    @arguments (
        $addarg(@name "grain", @type "llll", @description "reference grain.")
        $addarg(@name "targets", @type "int/float/list", @description "list of midicent or pitch class targets.")
    ),
    @output $addout(@description "pitch shifting amount in cents", @type "int/float")
);

## ------------------------------------------------------------

transcribe = (
    $grain, $onset = 0, $pan = null, $gain = null, $detune = null -> (
        ## unpack grain
        $grain = $grain::1;

        ## check for non-zero detuning
        $rate = [ 11 (if $detune && $detune != 0 then c2r($detune)) ];

        ## get pitch value and keep a copy
        $mc = $grain."pitch";
        $mccopy = $mc; 
        
        ## check if detuning is applied
        if $rate::(1 2) then (
            ## update pitch value based on detuning
            $mc += r2c($rate::(1 2))
        ) else (
            ## nullify unused slot for optimization
            $rate = null
        );
        ## color note based on detuning
        $color = [ 6 fmod(abs(($mccopy - $mc) / 1200) + .5, 1) ];

        ## clean gain and panning slots
        $pan = if $pan != null then [ 2 bpf($pan) ];
        $gain = if $gain != null then [ 1 bpf($gain, ($y -> max(1, $y * 127.))) ];

        ## get chord velocity and duration
        $vel = if $gain then maximum(trans($gain.1)::2) else min(127, $grain."loudness" * 512);
        $dur = $grain."duration";

        ## format note and add to roll
        $note = [ $mc $dur $vel ["slots" [ 7 $grain."file" ] [ 10 $grain."offset" ] $pan $rate $gain $color ]];
        msg("roll", "addchord" [ $onset $note ])
    )
);

$addref(
    @name "transcribe",
    @description "Adds input grain to the rendering sequence. See #setcorpus, #query, and #render functions.",
    @arguments (
        $addarg(@name "grain", @type "llll", @description "grain to add to rendering sequence.")
        $addarg(@name "onset", @type "int/float", @default 0, @description "grain onset in milliseconds.")
        $addarg(@name "pan", @type "int/float/list/llll", @description "normalized panning value or envelope.")
        $addarg(@name "gain", @type "int/float/llll", @description "gain value or envelope.")
        $addarg(@name "detune", @type "int/float", @description "detuning amount in cents.")
    )
);

## ------------------------------------------------------------

render = (
   $numchannels = 2, $panmode = 0, $sr = 48000, $normalize = 0, $play = 0, $process = null -> (
        msg("sampler", 
            [ "panmode" $panmode] 
            [ "numchannels" $numchannels ] 
            [ "sr" $sr ]
            [ "normalize" $normalize ]
        );
        msg("roll", "dump");
        ($process &&& msg("sampler", [ "process" $process ] ));
        ($play == 1 && msg("playtoggle", 1))
    )
);

$addref(
    @name "render",
    @description "Triggers script rendering into an audio buffer. See #transcribe function.",
    @arguments (
        $addarg(@name "numchannels", @type "int", @default 2, @description "number of output channels.")
        $addarg(@name "panmode", @type "int", @default 0, @description "panning mode. 0: linear panning; 1: circular panning.")
        $addarg(@name "sr", @type "int", @default 48000, @description "sampling rate.")
        $addarg(@name "normalize", @type "int", @default 0, @description "audio normalization.")
        $addarg(@name "play", @type "int", @default 0, @description "autoplay rendered buffer.")
        $addarg(@name "process", @type "llll", @description "optional post-rendering audio processing commands.")
    )
);

## ------------------------------------------------------------

export = (
    $path -> (
        msg("export", $path)
    )
);

$addref(
    @name "export",
    @description "Exports the rendered output as either a .wav, .mid/midi. or .llll file, given a output path. See #render function.",
    @arguments (
        $addarg(@name "path", @type "symbol", @description "output file path.")
    )
);

## ------------------------------------------------------------

hanning = ($N = 16 -> ($N -= 1; sin((pi * (0...$N)) / $N) ** 2.));

$addref(
    @name "hanning",
    @description "Generates a hanning window.",
    @arguments (
        $addarg(@name "N", @type "int", @default 16, @description "window resolution.")
    ),
    @output $addout(@description "hanning window" @type "list")
);

## ------------------------------------------------------------

#( 
    adapted from emmanuel jourdan: https://cycling74.com/forums/math-behind-function-curve
    NOTE: this is implementation is different from both bach's (closest) and Max.
)#

interpolate = (
    $x, $a, $b, $slope = 0 -> (
        $ca = 1.2;
        $cb = .41;
        $cc = .91;
        $m = 1e-20;
        $xrange = $b:1 - $a:1;
        $yrange = $b:2 - $a:2;
        if abs($slope) < .001 then (
            (($x - $a:1) / $xrange) * $yrange + $a:2
        ) else (
            if $slope < 0 then (
                $gx = ($b:1 - $x) / $xrange;
                $hp = (($m - $slope) * $ca) ** $cb * $cc;
                $fp = $hp / (1.0 - $hp);
                $gp = (exp($fp * $gx) - 1.) / (exp($fp) - 1.0);
                $b:2 - $gp * $yrange
            ) else (
                $gx = ($x - $a:1) / $xrange;
                $hp = (($slope + $m) * $ca)  ** $cb * $cc;
                $fp = $hp / (1.0 - $hp);
                $gp = (exp($fp * $gx) - 1.) / (exp($fp) - 1.0);
                $gp * $yrange + $a:2
            )
        )
    )
);

$addref(
    @name "interpolate",
    @description "Curve interpolation between two points.",
    @arguments (
        $addarg(@name "x", @type "int/float/list", @description "interpolation point")
        $addarg(@name "a", @type "list", @description "xy coordinates for point A")
        $addarg(@name "b", @type "list", @description "xy coordinates for point B")
        $addarg(@name "slope", @type "list", @default 0, @description "slope of curve between the two points, in the -1 to 1 range")
    ),
    @output $addout(@description "interpolated values" @type "int/float/list")
);

## ------------------------------------------------------------

samplebpf = (
    $bpf, $pts -> (
        $cols = trans($bpf);
        $xvals = $cols::1;
        $yvals = $cols::2;
        $cvals = $cols::3;
        $N = length($bpf);
        for $pt in $pts collect (
            $xdiffs = $xvals - $pt;
            $i = 1;
            $pos = null;
            while $i <= $N do (
                $dx = $xdiffs:$i;
                if $dx >= 0 then (
                    $pos = max(1, $i - 1);
                    $i = $N + 1
                ) else (
                    $i += 1
                )
            );
            $a = left(($bpf:$pos)::1, 2);
            $b = ($bpf:(min($pos + 1, $N)))::1;
            $slope = $b:3;
            $b = left($b, 2);
            interpolate($pt, $a, $b, $slope)
        )
    )
);

$addref(
    @name "samplebpf",
    @description "Samples an interpolated value from a breaking point function, given a list of normalized indices. See #bpf function.",
    @arguments (
        $addarg(@name "bpf", @type "llll", @description "breaking point function")
        $addarg(@name "pts", @type "int/float/list", @description "sampling point/s")
    ),
    @output $addout(@description "interpolated bpf values" @type "int/float/list")
);

## ------------------------------------------------------------

process = (
    $grain, $commands -> (
        $offset = $grain.getkey("offset");
        msg(
            "process",
            [ "source" $grain.getkey("file") ]
            [ "process" 
                [
                    ["fx" "crop"]
                    ["params" 
                        ["start" $offset ]
                        ["end" $offset + $grain.getkey("duration") ]
                    ]
                ]
                $commands 
            ]
        );
        [ GS_TMP_GRAIN ]
    )
);

$addref(
    @name "process",
    @description "Applies a sequence of DSP operations to the input grain, prior to rendering, via audio processing commands. These commands are generated through functions (e.g., see #reverse, #paulstretch, #freeverb, #rubberband), which contain the parameters for that specific DSP operation. Note that these post-rendering operations won't be reflected in the score transcription.",
    @arguments (
        $addarg(@name "grain", @type "llll", @description "grain to process.")
        $addarg(@name "commands", @type "llll", @description "list of audio process commands.")
    ),
    @output $addout(@description "processed grain" @type "llll")
);


## ------------------------------------------------------------

reverse = ( -> [ [ "fx" "reverse" ] ]);

$addref(
    @name "reverse",
    @description "Audio process command for reversing a buffer. See #process.",
    @output $addout(@description "reverse command" @type "llll")
);

## ------------------------------------------------------------

freeverb = (
    $roomsize = .5,
    $damp = .5,
    $width = .5,
    $tail = -1,
    $dry = 1., 
    $wet = 1/3. -> (
        [
            ["fx" "freeverb"]
            [ "params" 
                [ "roomsize" $roomsize ]
                [ "damp" $damp ]
                [ "width" $width ]
                [ "tail" $tail ]
                [ "dry" if depth($dry) > 1 || length($dry) > 1 then [ bpf($dry) ] else $dry ]
                [ "wet" if depth($wet) > 1 || length($wet) > 1 then [ bpf($wet) ] else $wet ]
            ]
        ]
    )
);

$addref(
    @name "freeverb",
    @description "Audio process command for applying reverb to a buffer. See #process function.",
    @arguments (
        $addarg(@name "roomsize", @default "0.5", @type "int/float", @description "reverb room size")
        $addarg(@name "damp", @default "0.5", @type "int/float", @description "damping coefficient")
        $addarg(@name "width", @default "0.5", @type "int/float", @description "panning width/spread, from 0 to 1.")
        $addarg(@name "tail", @default "-1", @type "int/float", @description "Duration of reverb tail in ms. -1: auto, 0: no tail.")
        $addarg(@name "dry", @default "1", @type "int/float/llll", @description "amount of dry output, as either a single number or envelope.")
        $addarg(@name "wet", @default "0.33", @type "int/float/llll", @description "amount of wet output, as either a single number or envelope.")
    ),
    @output $addout(@description "freeverb command" @type "llll")
);

## ------------------------------------------------------------

paulstretch = (
    $stretching = 1,
    $timeunit = 2,
    $envtimeunit = 2,
    $spectral = 1,
    $framesize = 8192 -> (
        $stretching = if depth($stretching) > 1 || length($stretching) > 1 then [ bpf($stretching) ] else $stretching;
        [
            [ "fx" "paulstretch" ]
            [ "params" 
                [ "stretching" $stretching ||| 1 ]
                [ "timeunit" $timeunit ]
                [ "envtimeunit" $envtimeunit ]
                [ "spectral" $spectral ] 
                [ "framesize" $framesize ] 
            ]
        ]
    )
);

$addref(
    @name "paulstretch",
    @description "Audio process command for applying time-stretching to a buffer. See #process.",
    @arguments (
        $addarg(@name "stretching", @default 1, @type "int/float/llll", @description "stretching amount, as single number or envelope.")
        $addarg(@name "timeunit", @default 2, @type "int", @description "time unit for @stretching. 0: ms, 1: samples, 2: duration ratio.")
        $addarg(@name "envtimeunit", @default 2, @type "int", @description "time unit for @stretching envelope. 0: ms, 1: samples, 2: duration ratio.")
        $addarg(@name "spectral", @default 1, @type "int", @description "stretching mode. 0: frequency domain, 1: time domain.")
        $addarg(@name "framesize", @default 8192, @type "int", @description "analysis frame size, in samples.")
    ),
    @output $addout(@description "paulstretch command" @type "llll")
);

## ------------------------------------------------------------

paulfreeze = (
    $duration = 1,
    $onset = 0,
    $timeunit = 2,
    $spectral = 1,
    $framesize = 8192 -> (
        [
            [ "fx" "paulfreeze" ]
            [ "params" 
                [ "duration" $duration ||| 1000 ]
                [ "onset" (if length($onset) > 1 then [$onset] else $onset) ||| 0 ]
                [ "timeunit" $timeunit ]
                [ "spectral" $spectral ]
                [ "framesize" $framesize ]
            ]
        ]
    )
);

$addref(
    @name "paulfreeze",
    @description "Audio process command for freezing a buffer. See #process.",
    @arguments (
        $addarg(@name "duration", @default 1, @type "int/float", @description "freezing duration.")
        $addarg(@name "onset", @default 0, @type "int/float/llll", @description "freezing duration.")
        $addarg(@name "timeunit", @default 2, @type "int", @description "time unit for @duration. 0: ms, 1: samples, 2: duration ratio.")
        $addarg(@name "spectral", @default 1, @type "int", @description "stretching mode. 0: frequency domain, 1: time domain.")
        $addarg(@name "framesize", @default 8192, @type "int", @description "analysis frame size, in samples.")
    ),
    @output $addout(@description "paulfreeze command" @type "llll")
);

## ------------------------------------------------------------

overdrive = (
    $factor = 1 -> (
        $factor = if depth($factor) > 1 || length($factor) > 1 then [ bpf($factor) ] else $factor;
        [
            [ "fx" "overdrive" ]
            [ "params" 
                [ "factor" $factor ]
            ]
        ]
    )
);

$addref(
    @name "overdrive",
    @description "Audio process command for applying soft-clip distortion to a buffer. See #process.",
    @arguments (
        $addarg(@name "factor", @type "int/float/llll", @description "distortion amount, either as single number or envelope.")
    ),
    @output $addout(@description "overdrive command" @type "llll")
);

## ------------------------------------------------------------

clip = (
    $factor = 1 -> (
        $factor = if depth($factor) > 1 || length($factor) > 1 then [ bpf($factor) ] else $factor;
        [
            [ "fx" "clip" ]
            [ "params" 
                [ "factor" $factor ]
            ]
        ]
    )
);

$addref(
    @name "clip",
    @description "Audio process command for applying hard-clip distortion to a buffer. See #process.",
    @arguments (
        $addarg(@name "factor", @type "int/float/llll", @description "distortion amount, either as single number or envelope.")
    ),
    @output $addout(@description "clip command" @type "llll")
);

## ------------------------------------------------------------

rubberband = (
    $stretching = 1,
    $pitchshift = 0,
    $pitchunit = 0,
    $timeunit = 2,
    $envtimeunit = 2,
    $blocksize = 1024,
    $fftwin = 1,
    $phase = 0,
    $pitchmode = 2,
    $formants = 0,
    $smoothing = 0,
    $stretchmode = 0,
    $detector = 0,
    $transients = 2 -> (
        $stretching = if depth($stretching) > 1 || length($stretching) > 1 then [ bpf($stretching) ] else $stretching;
        $pitchshift = if depth($pitchshift) > 1 || length($pitchshift) > 1 then [ bpf($pitchshift) ] else $pitchshift;
        [
            [ "fx" "rubberband" ]
            [ "params" 
                [ "stretching" $stretching ||| 1 ]
                [ "pitchshift" $pitchshift ||| 1 ]
                [ "pitchunit" $pitchunit ]
                [ "timeunit" $timeunit ]
                [ "envtimeunit" $envtimeunit ]
                [ "blocksize" $blocksize ]
                [ "fftwin" $fftwin ]
                [ "phase" $phase ]
                [ "pitchmode" $pitchmode ]
                [ "formants" $formants ]
                [ "smoothing" $smoothing ]
                [ "stretchmode" $stretchmode ]
                [ "detector" $detector ]
                [ "transients" $transients ] 
            ]
        ]
    )
);

$addref(
    @name "rubberband",
    @description "Audio process command for applying rubberband pitch-shifting/time-stretching to a buffer. See #process.",
    @arguments (
        $addarg(@name "stretching", @default 1, @type "int/float/llll", @description "stretching amount, as single number or envelope.")
        $addarg(@name "pitchshift", @default 0, @type "int/float/llll", @description "pitch shifting amount, as single number or envelope.")
        $addarg(@name "pitchunit", @default 0, @type "int", @description "unit for @pitchshift. 0: cents, 1: MIDI, 2: Hertz, 3: frequency ratio.")
        $addarg(@name "timeunit", @default 2, @type "int", @description "time unit for @stretching. 0: ms, 1: samples, 2: duration ratio.")
        $addarg(@name "envtimeunit", @default 2, @type "int", @description "time unit for @stretching envelope. 0: ms, 1: samples, 2: duration ratio.")
        $addarg(@name "blocksize", @default 1024, @type "int", @description "size for granular processes, such as envelopes, in samples.")
        $addarg(@name "fftwin", @default 1, @type "int", @description "FFT window type. 0: short, 1: standard, 2: long")
        $addarg(@name "phase", @default 0, @type "int", @description "Phase adjustment mode. 0: elastic, 1: precise.")
        $addarg(@name "pitchmode", @default 2, @type "int", @description "Pitch shift mode. 0: high speed, 1: high quality, 2: high consistency.")
        $addarg(@name "formants", @default 0, @type "int", @description "Formant processing. 0: off, 1: on")
        $addarg(@name "smoothing", @default 0, @type "int", @description "Time-domain smoothing. 0: off, 1: on")
        $addarg(@name "stretchmode", @default 0, @type "int", @description "Stretch mode. 0: elastic, 1: precise.")
        $addarg(@name "detector", @default 0, @type "int", @description "Transient detection algorithm. 0: compound, 1: percussive, 2: soft")
        $addarg(@name "transients", @default 2, @type "int", @description "Transient type. 0: crisp, 1: mixed, 2: smooth")
    ),
    @output $addout(@description "rubberband command" @type "llll")
);

## ------------------------------------------------------------

soundtouch = (
    $stretching = 1,
    $pitchshift = 0,
    $pitchunit = 0,
    $timeunit = 2,
    $antialias = 0,
    $quick = 0,
    $speech = 0 -> (
        [
            [ "fx" "soundtouch" ]
            [ "params" 
                [ "stretching" $stretching ||| 1 ]
                [ "pitchshift" $pitchshift ||| 1 ]
                [ "pitchunit" $pitchunit ]
                [ "timeunit" $timeunit ]
                [ "naa" $antialias ]
                [ "quick" $quick ]
                [ "speech" $speech ]
            ]
        ]
    )
);

$addref(
    @name "soundtouch",
    @description "Audio process command for applying soundtouch pitch-shifting/time-stretching to a buffer. See #process.",
    @arguments (
        $addarg(@name "stretching", @default 1, @type "int/float", @description "stretching amount, as single number or envelope.")
        $addarg(@name "pitchshift", @default 0, @type "int/float", @description "pitch shifting amount, as single number or envelope.")
        $addarg(@name "pitchunit", @default 0, @type "int", @description "unit for @pitchshift. 0: cents, 1: MIDI, 2: Hertz, 3: frequency ratio.")
        $addarg(@name "timeunit", @default 2, @type "int", @description "time unit for @stretching. 0: ms, 1: samples, 2: duration ratio.")
        $addarg(@name "antialias", @default 0, @type "int", @description "Anti-aliasing filter. 0: off, 1: on.")
        $addarg(@name "quick", @default 0, @type "int", @description "Quick processing. 0: off, 1: on.")
        $addarg(@name "speech", @default 0, @type "int", @description "Tune algorithm for speech. 0: off, 1: on.")
    ),
    @output $addout(@description "soundtouch command" @type "llll")
);

## ------------------------------------------------------------

repeat = (
    $duration,
    $timeunit = 2 -> (
        [
            [ "fx" "repeat" ]
            [ "params"
                [ "duration" $duration ]
                [ "timeunit" $timeunit ]
            ]
        ]
    )
);

$addref(
    @name "repeat",
    @description "Audio process command for repeating a buffer. See #process.",
    @arguments (
        $addarg(@name "duration", @default 1, @type "int/float", @description "target duration, based on @timeunit.")
        $addarg(@name "timeunit", @default 2, @type "int", @description "time unit for @duration. 0: ms, 1: samples, 2: duration ratio.")
    ),
    @output $addout(@description "repeat command" @type "llll")
);

## ------------------------------------------------------------

onepole = (
    $cutoff,
    $highpass = 0 -> (
        [
            [ "fx" "onepole" ]
            [ "params"
                [ "cutoff" $cutoff ]
                [ "highpass" $highpass ]
            ]
        ]
    )
);

$addref(
    @name "onepole",
    @description "Audio process command for applying single-pole lowpass or highpass filtering to a buffer. See #process.",
    @arguments (
        $addarg(@name "cutoff", @default 1, @type "int/float", @description "cutoff frequency.")
        $addarg(@name "highpass", @default 0, @type "int", @description "Highpass filter mode. 0: off, 1: on.")
    ),
    @output $addout(@description "onepole command" @type "llll")
);

## ------------------------------------------------------------

gain = (
    $gain,
    $resamplingfiltersize = 11,
    $resamplingmode = 0,
    $ampunit = 0,
    $envampunit = 0,
    $envtimeunit = 2 -> (
        [
            [ "fx" "gain" ]
            [ "params"
                [ "gain" $gain ]
                [ "resamplingfiltersize" $resamplingfiltersize ]
                [ "resamplingmode" $resamplingmode ]
                [ "ampunit" $ampunit ]
                [ "envampunit" $envampunit ]
                [ "envtimeunit" $envtimeunit ]
            ]
        ]
    )
);

$addref(
    @name "gain",
    @description "Audio process command for modifying a buffer's gain. See #process.",
    @arguments (
        $addarg(@name "gain", @type "int/float/llll", @description "gain amount, as either a single number or envelope.")
        $addarg(@name "resamplingfiltersize", @default 11, @type "int", @description "Resampling filter size, in samples.")
        $addarg(@name "resamplingmode", @default 0, @type "int", @description "Resampling mode. 0: sinc, 1: nearest neighbor, 2: S&H, 3: linear, 4: quad, 5: cubic")
        $addarg(@name "ampunit", @default 0, @type "int", @description "amplitude unit. 0: linear, 1: decibels.")
        $addarg(@name "envampunit", @default 0, @type "int", @description "amplitude unit for @gain envelope. 0: linear, 1: decibels.")
        $addarg(@name "envtimeunit", @default 2, @type "int", @description "time unit for @gain envelope. 0: ms, 1: samples, 2: duration ratio.")
    ),
    @output $addout(@description "gain command" @type "llll")
);

## ------------------------------------------------------------

dynamics = (
    $attack = 10,
    $release = 50,
    $knee = 0.7,
    $makeup = 0,
    $ratio = 1.5,
    $thresh = -20.,
    $ampunit = 1,
    $timeunit = 0 -> (
        [
            [ "fx" "dynamics" ]
            [ "params"
                [ "attack" $attack ]
                [ "release" $release ]
                [ "knee" $knee ]
                [ "makeup" $makeup ]
                [ "ratio" $ratio ]
                [ "thresh" $thresh ]
                [ "ampunit" $ampunit ]
                [ "timeunit" $timeunit ]
            ]
        ]
    )
);

$addref(
    @name "dynamics",
    @description "Audio process command for applying simple compression to a buffer. See #process.",
    @arguments (
        $addarg(@name "attack", @default 10, @type "int/float", @description "attack time.")
        $addarg(@name "release", @default 50, @type "int/float", @description "release time.")
        $addarg(@name "knee", @default "0.7", @type "int/float", @description "knee width.")
        $addarg(@name "makeup", @default 0, @type "int/float", @description "make-up gain.")
        $addarg(@name "ratio", @default "1.5", @type "int/float", @description "compression ratio.")
        $addarg(@name "thresh", @default -20, @type "int/float", @description "amplitude threshold.")
        $addarg(@name "ampunit", @default 1, @type "int", @description "amplitude unit. 0: linear, 1: decibels.")
        $addarg(@name "timeunit", @default 0, @type "int", @description "time unit. 0: ms, 1: samples, 2: duration ratio, 3: ms difference, 4: diff. in samples.")
    ),
    @output $addout(@description "dynamics command" @type "llll")
);

## ------------------------------------------------------------

resynth = (
    $func,
    $frequnit = 2,
    $maxnsines = 100,
    $maxpeaks = 100,
    $magnitudethreshold = .0002,
    $framesize = 2048,
    $hopsize = 512,
    $minfrequency = 0,
    $maxfrequency = 22050,
    $wintype = "hann",
    $stochastic = 0,
    $stocf = 0.2 -> (
        GS_RESYNTH_FUNC = $func ||| ($x, $y, $z, $w -> [$x] [$y] [$z] [$w]);
        [
            [ "fx" "resynth" ]
            [ "params"
                [ "stochastic" $stochastic ]
                [ "frequnit" $frequnit ]
                [ "maxnsines" $maxnsines ]
                [ "maxpeaks" $maxpeaks ]
                [ "magnitudethreshold" $magnitudethreshold ]
                [ "framesize" $framesize ]
                [ "hopsize" $hopsize ]
                [ "minfrequency" $minfrequency ]
                [ "maxfrequency" $maxfrequency ]
                (if $stochastic == 0 then [ "wintype" $wintype ])
                (if $stochastic == 1 then [ "stocf" $stocf ])
            ]
        ]
    )
);

$addref(
    @name "resynth",
    @description "Audio process command for applying partial tracking analysis/resynthesis to a buffer. See #process.",
    @arguments (
        $addarg(@name "func", @type "function", @description "pitch/frequency lambda function, with signature $oldpartials -> $newpartials.")
        $addarg(@name "frequnit", @default 2, @type "int", @description "unit for frequency components in @func. 0: Hertz, 1: BPM, 2: midicents, 3: MIDI")
        $addarg(@name "maxnsines", @default 100, @type "int", @description "max. number of sines per frame.")
        $addarg(@name "maxpeaks", @default 100, @type "int", @description "max. number of returned peaks.")
        $addarg(@name "magnitudethreshold", @default "0.0002", @type "float", @description "peak amplitude threshold.")
        $addarg(@name "framesize", @default 2048, @type "int", @description "window size, in samples")
        $addarg(@name "hopsize", @default 512, @type "int", @description "hop size, in samples")
        $addarg(@name "minfrequency", @default 0, @type "int/float", @description "min. frequency of the range to evaluate")
        $addarg(@name "maxfrequency", @default 22050, @type "int/float", @description "max. frequency of the range to evaluate")
        $addarg(@name "wintype", @default "'hann'", @type "sym/int", @description "window type. For instance, 'hann', 'sine', 'triangular', etc")
        $addarg(@name "stochastic", @default 0, @type "int", @description "analysis/resynthesis mode. 0: sinusoidal, 1: sinusoidal + stochastic.")
        $addarg(@name "stocf", @default '0.2', @type "int/float", @description "decimation factor of stochastic approximation. Ignored if @stochastic is 0.")
    ),
    @output $addout(@description "resynth command" @type "llll")
);

## ------------------------------------------------------------

buildtree = (
    $grains, $keys = "mfcc" -> (
        msg("kdtree", [ "features" $keys] ["grains" $grains])
    )
);

## ------------------------------------------------------------

searchtree = (
    $grain -> (
        msg("kdtree", [ "query" $grain]);
        GS_TREE_RESULT
    )
);

## ------------------------------------------------------------

null