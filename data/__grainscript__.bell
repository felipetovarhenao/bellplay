SEGMENTS = null;
REF = null;

## ------------------------------------------------------------

addref = (
    $name, $description, $arguments, $routing = 0 -> (
        REF _= [
            $name
            [ "description:" ($description + (if $routing then (" The output of this function must be routed into grainscript via the $do1 script variable. â€” i.e., $do1 = " + $name + "(...)") else "")) ] 
            [ "arguments:" ($arguments ||| "none") ] 
        ]
    )
);

## ------------------------------------------------------------

addarg = (
    $name, $description, $type = "list", $default = null -> (
        [
            "@" + $name 
            [ "description:" $description ]
            [ "type:" $type ]
            [ "default:" ($default ||| "none") ]
        ]
    )
);

## ------------------------------------------------------------

msg = (
    $to, $msg -> (
        [$to $msg]
    )
);

## ------------------------------------------------------------

pcdiff = (
	$a, $b, $mod = 12 -> ( 
		$a = fmod($a, $mod); 
		$b = fmod($b, $mod); 
		$da = $b - $a; 
		$db = $da + $mod * -(sgn($da) || 1); 
		$mask = for $xa in $da, $xb in $db collect int(abs($xa) < abs($xb)); 
		$da * $mask + $db * (1 - $mask)) 
);

addref(
    @name "pcdiff",
    @description "signed pitch class difference.",
    @arguments (
        addarg(@name "a",  @description "pitch classes.")
        addarg(@name "b", @description "pitch classes.")
    )
);

## ------------------------------------------------------------

setcorpus = (
    $filepath -> (
        SEGMENTS = null;
        msg("db", "read" $filepath)
    )
);

addref(
    @name "setcorpus",
    @description "loads an audio corpus, given a path to a .llll file.",
    @arguments (
        addarg(@name "filepath", @type "symbol", @description "file path to .llll corpus file.")
    ),
    @routing 1
);

## ------------------------------------------------------------

sampletable = (
    $x, $i -> (
        $N = length($x);
        $i = scale($i, 0, 1, 1, $N);
        $l = floor($i);
        $r = min($l + 1, $N);
        $m = fmod($i, 1);
        $x:$l * (1 - $m) + $x:$r * $m
    )
);

addref(
    @name "sampletable",
    @description "samples an interpolated value from a numeric list given a normalized index.",
    @arguments (
        addarg(@name "x", @type "list", @description "list to sample from.")
    )
);

## ------------------------------------------------------------

query = (
    $x -> msg("db", "query" $x)
);

addref(
    @name "query",
    @description "creates a SQLite3 query on the current corpus. For instance: 'SELECT * FROM segments'.",
    @arguments (
        addarg(@name "query", @type "symbol", @description "SQLite3 query.")
    ),
    @routing 1
);

## ------------------------------------------------------------

getsegments = (
    -> SEGMENTS
);

addref(
    @name "getsegments",
    @description "returns list of resulting segments from last query. See 'query' function."
);

## ------------------------------------------------------------

setkey = (
    $seg, $key, $val -> (
        $seg = $seg::1;
        $seg.$key = $val;
        [ $seg ]
    )
);

addref(
    @name "setkey",
    @description "modifies the key or field of a query segment.",
    @arguments (
        addarg(@name "seg", @type "list", @description "segment to modify.")
        addarg(@name "key", @type "symbol", @description "name of segment key.")
        addarg(@name "val", @type "anything", @description "new value for segment key.")
    )
);

## ------------------------------------------------------------

getkey = (
    $seg, $key -> ($seg::1).$key
);

addref(
    @name "getkey",
    @description "returns value associated with a segment's key.",
    @arguments (
        addarg(@name "seg", @type "list", @description "segment.")
        addarg(@name "key", @type "symbol", @description "name of segment key.")
    )
);

## ------------------------------------------------------------

mapkey = (
    $x, $key, $fun -> (
        setkey($x, $key, $fun(getkey($x, $key)))
    )
);

addref(
    @name "mapkey",
    @description "modifies the key of a corpus segment via a lambda function.",
    @arguments (
        addarg(@name "seg", @type "list", @description "segment to modify.")
        addarg(@name "key", @type "symbol", @description "name of segment key.")
        addarg(@name "fun", @type "lambda function", @description "lambda function with signature $key -> $val.")
    )
);

## ------------------------------------------------------------

bpf = (
    $pts, $curve = 0. -> (
        $N = length($pts);
        if $N == 1 then (
            $pts = flat($pts):1;
            [0 $pts 0] [ 1 $pts 0]
        ) else (
            for $pt $i in $pts collect (
                $idx = ($i - 1.) / max($N - 1, 1);
                [(if depth($pt) > 1 then flat($pt) else $idx $pt) $curve]
            )
        )
    )
);

addref(
    @name "bpf",
    @description "Converts a numeric list into a breaking point function.",
    @arguments (
        addarg(@name "pts", @type "list", @description "numeric list")
        addarg(@name "curve", @type "int/float", @default 0, @description "default curve value")
    )
);

## ------------------------------------------------------------

scale = (
    $x, $inmin = 0, $inmax = 1, $outmin = 0, $outmax = 1 -> (
        (($x - $inmin) / ($inmax - $inmin)) * ($outmax - $outmin) + $outmin
    )
);

addref(
    @name "scale",
    @description "scales an input value or list from a given range to another.",
    @arguments (
        addarg(@name "x", @type "int/float/list", @description "value to scale.")
        addarg(@name "inmin", @type "int/float", @default 0, @description "input minimum value.")
        addarg(@name "inmax", @type "int/float", @default 1, @description "input maxiumum value.")
        addarg(@name "outmin", @type "int/float", @default 0, @description "output minimum value.")
        addarg(@name "outmax", @type "int/float", @default 1, @description "output maxiumum value.")
    )
);

## ------------------------------------------------------------

frand = (
    $a = 1, $b = null, $res = 1000 -> (
        if $b == null then (
            $min = 0;
            $max = $a
        ) else (
            $min = $a;
            $max = $b
        );
        scale(random(0, $res), 0, $res, $min, $max)
    )
);

addref(
    @name "frand",
    @description "returns a random floating point number.",
    @arguments (
        addarg(@name "a", @type "int/float", @description "max. value if $b is null, else min. value.")
        addarg(@name "b", @type "int/float", @description "min. value.")
        addarg(@name "res", @type "int", @default 1000, @description "random value resolution.")
    )
);

## ------------------------------------------------------------

choose = (
    $x, $n = 1 -> (
        for $i in 1...$n collect $x:(random(1, length($x)))
    )
);

addref(
    @name "choose",
    @description "choose randomly one or more elements from list.",
    @arguments (
        addarg(@name "x", @type "list", @description "list to choose from.")
        addarg(@name "n", @type "int", @description "number of random choices.")
    )
);

## ------------------------------------------------------------

c2r = (
    $cents -> 2 ** ($cents / 1200)
);

addref(
    @name "c2r",
    @description "cents to ratio conversion to.",
    @arguments (
        addarg(@name "cents", @type "int/float", @description "cents to convert.")
    )
);

## ------------------------------------------------------------

r2c = (
    $r -> log2($r) * 1200
);

## ------------------------------------------------------------

filtersegments = (
    $segs, $fun, $max = 0, $maxdepth = 1, $unwrap = 1 -> (
        $lambda = (
            $x  -^ $fun -> (
                $fun($x)
            )
        );
        finditems($segs, $max, $lambda, @maxdepth $maxdepth, @unwrap $unwrap)
    )
);

## ------------------------------------------------------------

getshift = (
    $seg, $targets -> (
        $source = getkey($seg, "pitch");
        $distances = (
            for $pitch in $targets collect (
                if $pitch <= 12 then (
                    pcdiff($source / 100., $pitch) * 100
                ) else (
                    $pitch - $source
                )
            )
        );
        $distances:(minmax(abs($distances)):2)
    )
);

addref(
    @name "getshift",
    @description "Given a list of target midicents and/or pitch classes, it returns the difference between a segments' original pitch and the nearest pitch/pitch class target.",
    @arguments (
        addarg(@name "seg", @type "llll", @description "reference segment.")
        addarg(@name "targets", @type "list", @description "list of midicent or pitch class targets.")
    )
);

## ------------------------------------------------------------

seg2chord = (
    $segments, $onset = 0, $pan = null, $gain = null, $shift = null -> (
        $notes = (
            for $seg in $segments collect (
                $seg = flat($seg, 1);
                $file = [ 7 $seg.'file'];
                $offset = [ 10 $seg.'offset'];
                $pan = (if $pan then [ 2 $pan ] else null);
                $mc = $seg.'pitch';
                $gain = [1 $gain ||| bpf(0 127 127 0)];
                $rate = [11 (if $shift && $shift != 0 then c2r($shift))];
                $color = $mc; 
                $speed = $rate::(1 2);
                if $speed then (
                    $mc += r2c($rate::(1 2))
                ) else (
                    $rate = null
                );
                $vel = minmax(flat($gain)):3;
                $color = [6 fmod(abs(($color - $mc) / 1200) + .5, 1)];
                $dur = $seg.'duration';
                [ $mc $dur $vel ['slots' $file $offset $pan $rate $gain $color]]
            )
        );
        msg("roll", "addchord" [ $onset $notes ])
    )
);

addref(
    @name "seg2chord",
    @description "Segments to chord event conversion.",
    @arguments (
        addarg(@name "segments", @type "list/llll", @description "list of segments to convert to chords.")
        addarg(@name "onset", @type "int/float", @default 0, @description "chord onset in milliseconds.")
        addarg(@name "pan", @type "llll", @description "normalized panning envelope.")
        addarg(@name "gain", @type "llll", @description "velocity envelope.")
        addarg(@name "shift", @type "int/float", @description "pitch shift in cents.")
    ),
    @routing 1
);

## ------------------------------------------------------------

render = (
   $panmode = 0, $numchannels = 2, $sr = 48000, $normalize = 0, $play = 0 -> (
        msg("sampler", 
            [ "panmode" $panmode] 
            [ "numchannels" $numchannels ] 
            [ "sr" $sr ]
            [ "normalize" $normalize ]
        )
        msg("roll", "dump")
        (if $play then msg("playtoggle", 1))
    )
);

addref(
    @name "render",
    @description "Trigger script rendering into an audio buffer.",
    @arguments (
        addarg(@name "panmode", @type "int", @default 0, @description "panning mode. 0: linear panning; 1: circular panning.")
        addarg(@name "numchannels", @type "int", @default 2, @description "number of output channels.")
        addarg(@name "sr", @type "int", @default 48000, @description "sampling rate.")
        addarg(@name "normalize", @type "int", @default 0, @description "audio normalization.")
        addarg(@name "play", @type "int", @default 0, @description "autoplay rendered buffer.")
    ),
    @routing 1
);

## ------------------------------------------------------------

mergechords = (
    $ms = 5, $mc = 0 -> (
        msg("roll", "merge" $ms $mc)
    )
);

## ------------------------------------------------------------

null