GRAINS = null;
REF = null;

## ------------------------------------------------------------

addref = (
    $name, $description, $arguments, $routing = 0 -> (
        REF _= [
            $name
            [ "description:" ($description + (if $routing then (" Note that the output of this function must be routed into grainscript via the $do1 script variable, like so: $do1 = " + $name + "(...)") else "")) ] 
            [ "arguments:" ($arguments ||| "none") ] 
        ]
    )
);

## ------------------------------------------------------------

addarg = (
    $name, $description, $type = "list", $default = null -> (
        [
            "@" + $name 
            [ "description:" $description ]
            [ "type:" $type ]
            (if $default != null then [ "default:" $default ])
        ]
    )
);

## ------------------------------------------------------------

msg = (
    $to, $msg -> (
        [$to $msg]
    )
);

## ------------------------------------------------------------

pcdiff = (
	$a, $b, $mod = 12 -> ( 
		$a = fmod($a, $mod); 
		$b = fmod($b, $mod); 
		$da = $b - $a; 
		$db = $da + $mod * -(sgn($da) || 1); 
		$mask = for $xa in $da, $xb in $db collect int(abs($xa) < abs($xb)); 
		$da * $mask + $db * (1 - $mask)) 
);

addref(
    @name "pcdiff",
    @description "Signed pitch class difference.",
    @arguments (
        addarg(@name "a",  @description "pitch classes.")
        addarg(@name "b", @description "pitch classes.")
    )
);

## ------------------------------------------------------------

setcorpus = (
    $filepath -> (
        GRAINS = null;
        msg("db", "read" $filepath)
    )
);

addref(
    @name "setcorpus",
    @description "Loads an audio corpus, given an absolute path to a .llll file.",
    @arguments (
        addarg(@name "filepath", @type "symbol", @description "file path to .llll corpus file.")
    ),
    @routing 1
);

## ------------------------------------------------------------

samplelist = (
    $x, $i -> (
        $N = length($x);
        $i = scale($i, 0, 1, 1, $N);
        $l = floor($i);
        $r = min($l + 1, $N);
        $m = fmod($i, 1);
        $x:$l * (1 - $m) + $x:$r * $m
    )
);

addref(
    @name "samplelist",
    @description "Samples an interpolated value from a numeric list given a normalized index.",
    @arguments (
        addarg(@name "x", @type "list", @description "list to sample from.")
    )
);

## ------------------------------------------------------------

query = (
    $x = "SELECT * FROM grains LIMIT 50" -> msg("db", "query" $x)
);

addref(
    @name "query",
    @description "Creates a SQLite3 query on the current corpus.",
    @arguments (
        addarg(@name "query", @type "symbol", @default "'SELECT * FROM grains LIMIT 50'", @description "SQLite3 query.")
    ),
    @routing 1
);

## ------------------------------------------------------------

getgrains = (
    -> GRAINS
);

addref(
    @name "getgrains",
    @description "Returns list of resulting grains from last query. See 'query' function."
);

## ------------------------------------------------------------

setkey = (
    $grain, $key, $val -> (
        $grain = $grain::1;
        $grain.$key = $val;
        [ $grain ]
    )
);

addref(
    @name "setkey",
    @description "Modifies the key or field of a query grain.",
    @arguments (
        addarg(@name "grain", @type "llll", @description "grain to modify.")
        addarg(@name "key", @type "symbol", @description "name of grain key.")
        addarg(@name "val", @type "anything", @description "new value for grain key.")
    )
);

## ------------------------------------------------------------

getkey = (
    $grain, $key -> ($grain::1).$key
);

addref(
    @name "getkey",
    @description "Returns value associated with a grain's key.",
    @arguments (
        addarg(@name "grain", @type "llll", @description "grain.")
        addarg(@name "key", @type "symbol", @description "name of grain key.")
    )
);

## ------------------------------------------------------------

mapkey = (
    $x, $key, $fun -> (
        setkey($x, $key, $fun(getkey($x, $key)))
    )
);

addref(
    @name "mapkey",
    @description "Modifies the key of a corpus grain via a lambda function.",
    @arguments (
        addarg(@name "grain", @type "llll", @description "grain to modify.")
        addarg(@name "key", @type "symbol", @description "name of grain key.")
        addarg(@name "fun", @type "lambda function", @description "lambda function with signature $key -> $val.")
    )
);

## ------------------------------------------------------------

bpf = (
    $pts, $curve = 0. -> (
        $N = length($pts);
        if $N == 1 then (
            $pts = flat($pts):1;
            [0 $pts 0] [ 1 $pts 0]
        ) else (
            for $pt $i in $pts collect (
                $idx = ($i - 1.) / max($N - 1, 1);
                [(if depth($pt) > 1 then flat($pt) else $idx $pt) $curve]
            )
        )
    )
);

addref(
    @name "bpf",
    @description "Converts a numeric list into a breaking point function.",
    @arguments (
        addarg(@name "pts", @type "list", @description "numeric list")
        addarg(@name "curve", @type "int/float", @default 0, @description "default curve value")
    )
);

## ------------------------------------------------------------

scale = (
    $x, $inmin = 0, $inmax = 1, $outmin = 0, $outmax = 1 -> (
        (($x - $inmin) / ($inmax - $inmin)) * ($outmax - $outmin) + $outmin
    )
);

addref(
    @name "scale",
    @description "Scales an input value or list from a given range to another.",
    @arguments (
        addarg(@name "x", @type "int/float/list", @description "value to scale.")
        addarg(@name "inmin", @type "int/float", @default 0, @description "input minimum value.")
        addarg(@name "inmax", @type "int/float", @default 1, @description "input maxiumum value.")
        addarg(@name "outmin", @type "int/float", @default 0, @description "output minimum value.")
        addarg(@name "outmax", @type "int/float", @default 1, @description "output maxiumum value.")
    )
);

## ------------------------------------------------------------

frand = (
    $a = 1, $b = null, $res = 1000 -> (
        if $b == null then (
            $min = 0;
            $max = $a
        ) else (
            $min = $a;
            $max = $b
        );
        scale(random(0, $res), 0, $res, $min, $max)
    )
);

addref(
    @name "frand",
    @description "Returns a random floating point number.",
    @arguments (
        addarg(@name "a", @type "int/float", @description "max. value if $b is null, else min. value.")
        addarg(@name "b", @type "int/float", @description "min. value.")
        addarg(@name "res", @type "int", @default 1000, @description "random value resolution.")
    )
);

## ------------------------------------------------------------

choose = (
    $x, $n = 1 -> (
        for $i in 1...$n collect $x:(random(1, length($x)))
    )
);

addref(
    @name "choose",
    @description "Choose randomly one or more elements from list.",
    @arguments (
        addarg(@name "x", @type "list", @description "list to choose from.")
        addarg(@name "n", @type "int", @description "number of random choices.")
    )
);

## ------------------------------------------------------------

c2r = (
    $cents -> 2 ** ($cents / 1200)
);

addref(
    @name "c2r",
    @description "Cents to ratio conversion to.",
    @arguments (
        addarg(@name "cents", @type "int/float", @description "cents to convert.")
    )
);

## ------------------------------------------------------------

r2c = (
    $r -> log2($r) * 1200
);

## ------------------------------------------------------------

filtergrains = (
    $grains, $fun, $max = 0, $maxdepth = 1, $unwrap = 1 -> (
        $lambda = (
            $x  -^ $fun -> (
                $fun($x)
            )
        );
        finditems($grains, $max, $lambda, @maxdepth $maxdepth, @unwrap $unwrap)
    )
);

## ------------------------------------------------------------

getshift = (
    $grain, $targets -> (
        $source = getkey($grain, "pitch");
        $distances = (
            for $pitch in $targets collect (
                if $pitch <= 12 then (
                    pcdiff($source / 100., $pitch) * 100
                ) else (
                    $pitch - $source
                )
            )
        );
        $distances:(minmax(abs($distances)):2)
    )
);

addref(
    @name "getshift",
    @description "Given a list of target midicents and/or pitch classes, it returns the difference between a grains' original pitch and the nearest pitch/pitch class target.",
    @arguments (
        addarg(@name "grain", @type "llll", @description "reference grain.")
        addarg(@name "targets", @type "list", @description "list of midicent or pitch class targets.")
    )
);

## ------------------------------------------------------------

gs_cleanbpf = ($x, $f = 1 -> (if length($x) == 1 || depth($x) == 1 then bpf($x * float($f)) else $x));

## ------------------------------------------------------------

addgrain = (
    $grain, $onset = 0, $pan = null, $gain = null, $shift = null -> (
        $grain = $grain::1;
        $mc = $grain."pitch";
        $rate = [11 (if $shift && $shift != 0 then c2r($shift))];
        $color = $mc; 
        $speed = $rate::(1 2);
        if $speed then (
            $mc += r2c($rate::(1 2))
        ) else (
            $rate = null
        );
        $pan = (if $pan != null then [ 2 gs_cleanbpf($pan) ]);
        $gain = (if $gain != null then [ 1 gs_cleanbpf($gain, 127)]);
        $vel = (if $gain then minmax(flat($gain)):3 else min(127, $grain."loudness" * 512));
        $color = [ 6 fmod(abs(($color - $mc) / 1200) + .5, 1) ];
        $dur = $grain."duration";
        $note = [ $mc $dur $vel ["slots" [ 7 $grain."file" ] [ 10 $grain."offset" ] $pan $rate $gain $color]];
        msg("roll", "addchord" [ $onset $note ])
    )
);

addref(
    @name "addgrain",
    @description "Add grains to rendering queue.",
    @arguments (
        addarg(@name "grains", @type "list/llll", @description "list of grains to convert to chords.")
        addarg(@name "onset", @type "int/float", @default 0, @description "chord onset in milliseconds.")
        addarg(@name "pan", @type "llll", @description "normalized panning envelope.")
        addarg(@name "gain", @type "llll", @description "velocity envelope.")
        addarg(@name "shift", @type "int/float", @description "pitch shift in cents.")
    ),
    @routing 1
);

## ------------------------------------------------------------

render = (
   $panmode = 0, $numchannels = 2, $sr = 48000, $normalize = 0, $play = 0 -> (
        msg("sampler", 
            [ "panmode" $panmode] 
            [ "numchannels" $numchannels ] 
            [ "sr" $sr ]
            [ "normalize" $normalize ]
        )
        msg("roll", "dump")
        (if $play then msg("playtoggle", 1))
    )
);

addref(
    @name "render",
    @description "Trigger script rendering into an audio buffer.",
    @arguments (
        addarg(@name "panmode", @type "int", @default 0, @description "panning mode. 0: linear panning; 1: circular panning.")
        addarg(@name "numchannels", @type "int", @default 2, @description "number of output channels.")
        addarg(@name "sr", @type "int", @default 48000, @description "sampling rate.")
        addarg(@name "normalize", @type "int", @default 0, @description "audio normalization.")
        addarg(@name "play", @type "int", @default 0, @description "autoplay rendered buffer.")
    ),
    @routing 1
);

## ------------------------------------------------------------

mergechords = (
    $ms = 5, $mc = 0 -> (
        msg("roll", "merge" $ms $mc)
    )
);

## ------------------------------------------------------------

null