GS_VERSION = "v0.0.5-beta";
GS_GRAINS = null;
GS_REF = null;
GS_REF_TIMEUNIT_OPTIONS = null;
GS_REF_AUDIO_DOMAIN_OPTIONS = null;

## ------------------------------------------------------------

$addref = (
    $name, $description, $arguments, $output -> (
        GS_REF _= [
            $name
            [ "description:" $description ] 
            [ "arguments:" ($arguments ||| "none") ] 
            [ "output:" ($output ||| "null") ]
        ]
    )
);

## ------------------------------------------------------------

$addarg = (
    $name, $description, $type = "list", $default = null, $options = null -> (
        [
            "@" + $name 
            [ "description:" $description ]
            [ "type:" $type ]
            ($default &&& [ "default:" $default ])
            ($options &&& [ "options:" $options ])
        ]
    )
);

$addopt = (
    $value, $description -> (
        [ (if $description then (tosymbol($value) + ":") else $value) $description ]
    )
);

$addout = (
    $description, $type -> [ "description:" $description ] [ "type:" $type ]
);

## ------------------------------------------------------------

msg = (
    $to, $msg -> (
        $do1 = [ $to $msg ];
        null
    )
);

## ------------------------------------------------------------

getpathinfo = (
    $x -> (
        msg("pathinfo", $x);
        if GS_PATH_INFO == null then printerror("invalid path:" $x);
        GS_PATH_INFO
    )
);

## ------------------------------------------------------------

printerror = (
    $text, $stop = 1 -> (
        msg("console",
            [ "code" $stop == 0 ]
            [ "type" 2 - $stop ]
            [ "text" $text ]
        );
        null
    )
);

## ------------------------------------------------------------

tosymbol = (
    $x -> (
        msg("sym", $x);
        GS_SYMBOL
    )
);

$addref(
    @name "tosymbol",
    @description "Casts input value as a symbol.",
    @arguments (
        $addarg(@name "x",  @type "anything",@description "value to cast")
    ),
    @output $addout(@description "symbol", @type "symbol")
);

## ------------------------------------------------------------

GS_REF_TIMEUNIT_OPTIONS = (
    $addopt(@value 0, @description "milliseconds")
    $addopt(@value 1, @description "samples")
    $addopt(@value 2, @description "duration" "ratio")
    $addopt(@value 3, @description "milliseconds" "difference")
    $addopt(@value 4, @description "samples" "difference")
);

GS_REF_AUDIO_DOMAIN_OPTIONS = (
    $addopt(@value 0, @description "frequency domain")
    $addopt(@value 1, @description "time domain")
);

GS_REF_PITCH_FORMAT_OPTIONS = (
    $addopt(@value 0 @description "cents")
    $addopt(@value 1 @description "MIDI" )
    $addopt(@value 2 @description "Hertz")
    $addopt(@value 3 @description "frequency ratio")
);

GS_REF_SWITCH_OPTIONS = (
    $addopt(@value 0 @description "off")
    $addopt(@value 1 @description "on" )
);

GS_REF_NORMALIZE_OPTIONS = (
    $addopt(@value 0 @description "never")
    $addopt(@value 1 @description "always")
    $addopt(@value 2 @description "overload protection only" )
);

GS_REF_WINDOW_OPTIONS = (
    $addopt(@value "rectangular")
    $addopt(@value "triangular")
    $addopt(@value "sine")
    $addopt(@value "hann")
    $addopt(@value "hamming")
    $addopt(@value "blackman")
    $addopt(@value "nuttall")
    $addopt(@value "blackmannuttall")
    $addopt(@value "blackmanharris")
    $addopt(@value "gaussian")
    $addopt(@value "sqrthann")
    $addopt(@value "sqrthamming")
);

GS_REF_AMPUNIT_OPTIONS = (
    $addopt(@value 0, @description "linear")
    $addopt(@value 1, @description "decibels")
);

GS_REF_CURVE_OPTIONS = (
    $addopt(@value 0, @description "linear")
    $addopt(@value 1, @description "sine")
    $addopt(@value 2, @description "curve")
    $addopt(@value 3, @description "s-curve")
);

GS_REF_RESAMPLINGMODE_OPTIONS = (
    $addopt(@value "sinc")
    $addopt(@value "nearest neighbor")
    $addopt(@value "sample and hold")
    $addopt(@value "linear")
    $addopt(@value "quad")
    $addopt(@value "cubic")
);

GS_REF_RESAMPLINGPOLICY_OPTIONS = (
    $addopt(@value 0 @description "don't")
    $addopt(@value 1 @description "to lowest")
    $addopt(@value 2 @description "to highest")
    $addopt(@value 3 @description "to most common")
    $addopt(@value 4 @description "to max. current")
);

## ------------------------------------------------------------

pcdiff = (
    $a, $b, $mod = 12 -> ( 
        if $a == null || $b == null then (
            printerror("you must provide values for both @a and @b in pcdiff()")
        );
        $a = fmod($a, $mod); 
        $b = fmod($b, $mod); 
        $da = $b - $a;
        $db = $da + $mod * -sgn($da); 
        $mask = max(0, sgn(abs($db) - abs($da)));
        $da * $mask + $db * (1 - $mask)
    ) 
);

$addref(
    @name "pcdiff",
    @description "Signed pitch class difference.",
    @arguments (
        $addarg(@name "a",  @type "int/float/list",@description "pitch classes.")
        $addarg(@name "b", @type "int/float/list",@description "pitch classes.")
    ),
    @output $addout(@description "signed difference", @type "int/float/list")
);

## ------------------------------------------------------------

setcorpus = (
    $filepath -> (
        if $filepath == null then (
            printerror("you must provide a value for @filepath in setcorpus()")
        );
        $pathinfo = getpathinfo($filepath);
        $path = $pathinfo."path";
        $extension = $pathinfo."extension";
        if $extension != ".llll" then printerror(if $extension == null then "you must provide a file path" else "invalid corpus extension:" $extension);
        GS_GRAINS = null;
        msg("db", "read" $path + $extension)
    )
);

$addref(
    @name "setcorpus",
    @description "Loads an audio corpus, given an absolute path to a .llll file. See #query function.",
    @arguments (
        $addarg(@name "filepath", @type "symbol", @description "file path to .llll corpus file.")
    )
);

## ------------------------------------------------------------

samplelist = (
    $x, $i -> (
        if $x == null || $i == null then (
            printerror("you must provide values for @x and @i in samplelist()")
        );
        $N = length($x);
        $i = scale($i, 0, 1, 1, $N);
        $l = floor($i);
        $r = min($l + 1, $N);
        $m = fmod($i, 1);
        $x:$l * (1 - $m) + $x:$r * $m
    )
);

$addref(
    @name "samplelist",
    @description "Samples an interpolated value from a numeric list given a normalized index.",
    @arguments (
        $addarg(@name "x", @type "list", @description "list to sample from.")
        $addarg(@name "i", @type "list", @description "normalized sampling index.")
    ),
    @output $addout(@description "interpolated sample", @type "int/float/list")
);

## ------------------------------------------------------------

query = (
    $x = "SELECT * FROM grains" -> (
        if $x == null then (
            printerror("you must provide a value for @x in query()")
        );
        msg("db", "query" $x);
        (if GS_GRAINS == null then printerror("query did not yield any results:" tosymbol($x)));
        GS_GRAINS
    )
);

$addref(
    @name "query",
    @description "Executes an sqlite3 query on the current audio corpus, and returns the results. Every query should use 'grains' as the table name. For instance: 'SELECT * FROM grains'. See #setcorpus.",
    @arguments (
        $addarg(@name "query", @type "symbol", @default "'SELECT * FROM grains'", @description "sqlite3 query.")
    ),
    @output $addout(@description "list of grains", @type "llll")
);

## ------------------------------------------------------------

getkey = (
    $grain, $key -> (
        if $key == null || $grain == null then (
            printerror("you must provide values for both @grain and @key in getkey()") 
        ) else ($grain::1).$key
    )
);

$addref(
    @name "getkey",
    @description "Returns value associated with a grain's key.",
    @arguments (
        $addarg(@name "grain", @type "llll", @description "grain.")
        $addarg(@name "key", @type "symbol", @description "name of grain key.")
    ),
    @output $addout(@description "value associated with key", @type "anything")
);

## ------------------------------------------------------------

setkey = (
    $grain, $key, $val -> (
        if $key == null || $grain == null then (
            printerror("you must provide values for both @grain and @key in setkey()") 
        ) else (
            [ ($grain::1).$key = $val ]
        )
    )
);

$addref(
    @name "setkey",
    @description "Modifies the key of a grain.",
    @arguments (
        $addarg(@name "grain", @type "llll", @description "grain to modify.")
        $addarg(@name "key", @type "symbol", @description "name of grain key.")
        $addarg(@name "val", @type "anything", @description "new value for grain key.")
    ),
    @output $addout(@description "modified grain", @type "llll")
);

## ------------------------------------------------------------

mapkey = (
    $grain, $key, $func -> (
        if $key == null || $grain == null || $func == null then (
            printerror("you must provide values for @grain, @key, and @func and @key in mapkey().") 
        );
        setkey($grain, $key, $func(getkey($grain, $key)))
    )
);

$addref(
    @name "mapkey",
    @description "Modifies the key of a grain via a lambda function.",
    @arguments (
        $addarg(@name "grain", @type "llll", @description "grain to modify.")
        $addarg(@name "key", @type "symbol", @description "name of grain key.")
        $addarg(@name "func", @type "lambda function", @description "lambda function with signature $currentvalue -> $newvalue.")
    ),
    @output $addout(@description "modified grain", @type "llll")
);

## ------------------------------------------------------------

bpf = (
    $pts,
    ## by default, x axis is sorted and normalized
    $xfunc = ($x -> ($norm = maximum($x ||| 1.); sort(float($x) / if $norm != 0 then $norm else 1.))),
    $yfunc = null,
    $sfunc = null -> (
        $depth = depth($pts);
        $size = length($pts);
        if $depth == 1 then (
            for $p $i in $pts collect [ ($i - 1.) / max(1, $size - 1.) (if $yfunc then $yfunc($p) else $p) 0. ]
        ) else if $depth == 2 then (
            $cols = trans($pts);
            $x = [ if $xfunc then $xfunc($cols::1) else $cols::1 ];
            $y = [ if $yfunc then $yfunc($cols::2) else $cols::2 ];
            $slope = for $i in 1...$size collect ($pts::($i 3)) ||| 0;
            if $sfunc then (
                $slope = $sfunc($slope)
            );
            trans($x $y [ $slope ])
        )
    )
);

$addref(
    @name "bpf",
    @description "Formats an numeric list into a breakpoint function, in the form of [<x> <y> <slope>] tuples, where <x> is normalized to the 0-1 range.",
    @arguments (
        $addarg(@name "pts", @type "list", @description "numeric list")
        $addarg(@name "xfunc", @default "<normalization function>", @type "function/null", @description "optional lambda function for x axis")
        $addarg(@name "yfunc", @default "null", @type "function/null", @description "optional lambda function for y axis")
        $addarg(@name "sfunc", @default "null", @type "function/null", @description "optional lambda function for bpf slope")
    ),
    @output $addout(@description "breakpoint function", @type "llll")
);


## ------------------------------------------------------------

x2dx = ($x -> for $a in left($x, -1), $b in right($x, 1) collect $b - $a);

$addref(
    @name "x2dx",
    @description "Given a numeric list, outputs the difference between adjacent elements. Inverse of #dx2x.",
    @arguments (
        $addarg(@name "x", @type "list", @description "list for compute differences for.")
    ),
    @output $addout(@description "dx", @type "list")
);

## ------------------------------------------------------------

dx2x = ($dx, $st = 0 -> $st for $x in $dx collect $st += $x);

$addref(
    @name "dx2x",
    @description "Outputs a numeric list where each element is the result of the cumulative sum of the input list, given a starting value. Inverse of #x2dx.",
    @arguments (
        $addarg(@name "dx", @type "list", @description "list of differences/deltas.")
        $addarg(@name "st", @default 0 @type "int/float", @description "starting value")
    ),
    @output $addout(@description "x", @type "list")
);

## ------------------------------------------------------------

revbpf = (
    $bpf -> (
        bpf($bpf, 
            ($x -> dx2x(rev(x2dx($x)))), 
            ($y -> rev($y)), 
            ($s -> left($s, 1) rev(right($s, 1)) * -1)
        )
    )
);

$addref(
    @name "revbpf",
    @description "Reverses a breakpoint function.",
    @arguments (
        $addarg(@name "bpf", @type "llll", @description "breakpoint function to reverse")
    ),
    @output $addout(@description "breakpoint function", @type "llll")
);

## ------------------------------------------------------------

scale = (
    $x, $inmin = 0, $inmax = 1, $outmin = 0, $outmax = 1 -> (
        (($x - $inmin) / ($inmax - $inmin)) * float($outmax - $outmin) + $outmin
    )
);

$addref(
    @name "scale",
    @description "Scales an input value or list from a given range to another.",
    @arguments (
        $addarg(@name "x", @type "int/float/list", @description "value to scale.")
        $addarg(@name "inmin", @type "int/float", @default 0, @description "input minimum value.")
        $addarg(@name "inmax", @type "int/float", @default 1, @description "input maxiumum value.")
        $addarg(@name "outmin", @type "int/float", @default 0, @description "output minimum value.")
        $addarg(@name "outmax", @type "int/float", @default 1, @description "output maxiumum value.")
    ),
    @output $addout(@description "scaled input", @type "int/float/list/llll")
);

## ------------------------------------------------------------

rand = (
    $a = 1, $b = null, $res = 1000 -> (
        if $b == null then (
            $min = 0;
            $max = $a
        ) else (
            $min = $a;
            $max = $b
        );
        scale(random(0, $res), 0, $res, $min, $max)
    )
);

$addref(
    @name "rand",
    @description "Random floating point number generator.",
    @arguments (
        $addarg(@name "a", @type "int/float", @description "max. value if @b is null, else min. value.")
        $addarg(@name "b", @type "int/float", @description "min. value.")
        $addarg(@name "res", @type "int", @default 1000, @description "random value resolution.")
    ),
    @output $addout(@description "random floating point number", @type "int/float")
);

## ------------------------------------------------------------

choose = (
    $choices, $n = 1, $weights = null -> (
        $len = length($choices);
        $sum = if $weights == null then 0 else reduce($weights, #+);
        for $i in 1...$n collect (
            if $sum == 0 then (
                $choices:random(1, $len)
            ) else (    
                $choice = null;
                $rand = rand() * $sum;
                for $x in $choices, $w in $weights as $choice == null with @iterationmode 1 do (
                    if $rand < $w then $choice = $x;
                    $rand -= $w 
                );
                $choice  
            )
        )
    )
);

$addref(
    @name "choose",
    @description "Choose randomly one or more elements from a list, with optional probability weights.",
    @arguments (
        $addarg(@name "choices", @type "list", @description "list to choose from.")
        $addarg(@name "n", @default 1, @type "int", @description "number of random choices.")
        $addarg(@name "weights", @default "null" @type "list/null", @description "optional probability weights for each element.")
    ),
    @output $addout(@description "random choices", @type "anything")
);

## ------------------------------------------------------------

c2r = (
    $cents -> 2 ** ($cents / 1200)
);

$addref(
    @name "c2r",
    @description "Cents to ratio conversion.",
    @arguments (
        $addarg(@name "cents", @type "list/int/float", @description "cents to convert.")
    ),
    @output $addout(@description "list of ratios", @type "int/float/list")
);

## ------------------------------------------------------------

r2c = (
    $r -> log2($r) * 1200
);

$addref(
    @name "r2c",
    @description "Ratio to cents conversion.",
    @arguments (
        $addarg(@name "ratios", @type "list/int/float", @description "ratios to convert.")
    ),
    @output $addout(@description "list of cents", @type "list/int/float")
);

## ------------------------------------------------------------

sortgrains = (
    $grains, $key -> (
        sort($grains, ($a, $b -^ $key -> (getkey($a, $key) < getkey($b, $key))))
    )
);

$addref(
    @name "sortgrains",
    @description "Sorts grains by a given key (grain_id, file_id, pitch, pitchclass, pitchsalience, duration, centroid, zerox, loudness, etc.)",
    @arguments (
        $addarg(@name "grains", @type "llll", @description "grains to sort.")
        $addarg(@name "key", @type "symbol", @description "grain key to sort by.")
    ),
    @output $addout(@description "list of sorted grains", @type "llll")
);

## ------------------------------------------------------------

filtergrains = (
    $grains, $func, $max = 0, $maxdepth = 1, $unwrap = 1 -> (
        $lambda = (
            $x  -^ $func -> (
                $func($x)
            )
        );
        finditems($grains, $max, $lambda, @maxdepth $maxdepth, @unwrap $unwrap)
    )
);

## ------------------------------------------------------------

pitchdiff = (
    $source, $targets -> (
        if $targets == null then (
            printerror("you must provide @targets in pitchdiff")
        );
        $distances = (
            if $targets:1 < 12 then (
                pcdiff($source / 100., $targets) * 100
            ) else (
                $targets - $source
            )
        );
        $distances:(minmax(abs($distances)):2)
    )
);

$addref(
    @name "pitchdiff",
    @description "Given a list of target midicents and/or pitch classes, returns the signed difference between a pitch in midicents and the nearest midicent/pitch class target.",
    @arguments (
        $addarg(@name "pitch", @type "int/float", @description "reference pitch in midicents.")
        $addarg(@name "targets", @type "int/float/list", @description "list of midicent or pitch class targets.")
    ),
    @output $addout(@description "signed difference to closest target, in cents.", @type "int/float")
);

## ------------------------------------------------------------

detuning = (
    $grain, $targets -> (
        if $grain == null || $targets == null then (
            printerror("you must provide values for both @grain and @targets in detuning()")
        );
        $source = getkey($grain, "pitch");
        if $source < 0 then (
            $source = mc2f(getkey($grain, "centroid"))
        );
        pitchdiff($source, $targets)
    )
);

$addref(
    @name "detuning",
    @description "Given a list of target midicents and/or pitch classes, returns the difference between a grains' original pitch and the nearest midicent/pitch class target. See #transcribe function.",
    @arguments (
        $addarg(@name "grain", @type "llll", @description "reference grain.")
        $addarg(@name "targets", @type "int/float/list", @description "list of midicent or pitch class targets.")
    ),
    @output $addout(@description "pitch shifting amount in cents", @type "int/float")
);

## ------------------------------------------------------------

transcribe = (
    $grain, $onset = 0, $pan = null, $gain = null, $detune = null -> (
        if $grain == null then (
            printerror("attempt to pass a null value as @grain in transcribe()")
        );
        ## unpack grain
        $grain = $grain::1;

        ## check for non-zero detuning
        $rate = [ 11 (if $detune && $detune != 0 then c2r($detune)) ];

        ## get pitch value
        $mc = $grain."pitch";

        ## assign notehead based on pitch value
        $notehead = [ 23 if $mc < 0 then 88 else 85];

        ## replace pitch with mc centroid if unpitched.
        $mc = if $mc < 0 then f2mc($grain."centroid") else $mc;

        ## keep copy before pitch shifting
        $mccopy = $mc; 
        
        ## check if detuning is applied
        if $rate::(1 2) then (
            ## update pitch value based on detuning
            $mc += r2c($rate::(1 2))
        ) else (
            ## nullify unused slot for optimization
            $rate = null
        );
        ## color note based on detuning
        $color = [ 6 fmod(abs(($mccopy - $mc) / 1200) + .66, 1) ];

        ## clean gain and panning slots
        $pan = if $pan != null then [ 2 bpf($pan) ];
        $gain = if $gain != null then [ 1 bpf($gain, @yfunc ($y -> max(1, $y * 127.))) ];

        ## get chord velocity and duration
        $vel = if $gain then maximum(trans($gain.1)::2) else min(127, $grain."loudness" * 512);
        $dur = $grain."duration";
        
        ## make size slot based on duration
        $size = [ 4 scale(log2(min(16384, max(1, $dur))), 0, 14, 25, 150) ];

        ## format note and add to roll
        $note = [ $mc $dur $vel ["slots" [ 7 $grain."file" ] [ 10 $grain."offset" ] $pan $rate $gain $color $notehead $size ]];
        msg("roll", "addchord" [ $onset $note ])
    )
);

$addref(
    @name "transcribe",
    @description "Adds input grain to the rendering sequence. See #setcorpus, #query, and #render functions.",
    @arguments (
        $addarg(@name "grain", @type "llll", @description "grain to add to rendering sequence.")
        $addarg(@name "onset", @type "int/float", @default 0, @description "grain onset in milliseconds.")
        $addarg(@name "pan", @type "int/float/list/llll", @description "normalized panning value or envelope.")
        $addarg(@name "gain", @type "int/float/llll", @description "gain value or envelope.")
        $addarg(@name "detune", @type "int/float", @description "detuning amount in cents.")
    )
);

## ------------------------------------------------------------

wavesynth = (
    $frequency = 440,
    $amplitude = .5,
    $duration = 100,
    $waveform = 0,
    $normalize = 0,
    $iterationmode = 1,
    $analyze = 0,
    $sr = 48000 -> (
        $pitch = null;
        $loudness = null;
        $fullduration = null;
        $notes = for $fq in $frequency, $a in $amplitude, $d in $duration with @iterationmode $iterationmode @maxdepth 1 @unwrap 1 collect (
            ## reset bpf for each note
            $bpf = null;

            ## check for frequency envelopes
            if length($fq) > 1 then (
                ## get starting frequency, assuming envelope is a depth 1 list
                $start = $fq:1;

                ## if not, it's likely a bpf
                if depth($fq) > 1 then (
                    $start = $start:(1 2)
                );
                ## generate breakpoint relative to starting frequency and convert to cents
                $bpf = [ "breakpoints" bpf($fq, @yfunc ($y -^ $start -> r2c($y/$start))) ];
                
                ## replace @fq with starting frequency
                $fq = $start
            );

            ## check if amp is a bpf
            if length($a) > 1 || depth($a) > 1 then (
                $bpf = bpf($a, @yfunc ($y -> max(1, $y * 127.)));
                $gain = [ 1 $bpf ];
                $a = maximum((trans($bpf)::2) ||| 1)
            ) else (
                $a *= 127.
            );

            ## convert to midicents
            $mc = f2mc($fq);

            ## collect pitch and loudness if analysis is skipped
            if $analyze != 1 then (
                $pitch _= $mc;
                $loudness _= $a;
                $fullduration _= $d
            );

            ## format note
            [ $mc $d $a $bpf [ "slots" $gain ]]
        );
        msg("wavesynth", 
            ## if analysis is skipped, construct features manually
            (if $analyze != 1 then (
                    $pitch = $pitch ||| 1;
                    $loudness = $loudness ||| 1;
                    $fullduration = $fullduration ||| 1;
                    [ 'features' 
                        [ "pitch" minimum($pitch) ]
                        [ "loudness" maximum($loudness) ]
                        [ "duration" maximum($fullduration) ]
                        [ "pitchclass" fmod($pitch * .01, 12.)]
                        [ "file_id" null ]
                        [ "mfcc" null ]
                        [ "pitchsalience" 1 ]
                        [ "zerox" 0 ]
                        [ "centroid" reduce(mc2f($pitch) * $loudness, #+) / reduce($loudness, #+) ]
                        [ "offset" 0 ]
                        [ "file_end" maximum($duration) ]
                    ]
                )
            )
            [ "synth" 
                [ "normalize" $normalize ]
                [ "waveform" $waveform + 1 ]
                [ "sr" $sr ]
            ]
            [ 'roll' 'addchord' [ 0 $notes ] ] 
        );
        [ GS_TMP_GRAIN ]
    )
);

$addref(
    @name "wavesynth",
    @description "Generates an grain through additive wave synthesis, given frequency, amplitude, and duration values for each partial.",
    @arguments (
        $addarg(@name "frequency", @type "int/float/list/llll", @default 440, @description "frequency values for each partial. Each value can be a single number or envelope.")
        $addarg(@name "amplitude", @type "int/float/list", @default "0.5", @description "linear amplitude values for each partial. Each value can be a single number or envelope.")
        $addarg(@name "duration", @type "int/float/list", @default 100, @description "duration values for each partial, in milliseconds.")
        $addarg(@name "waveform", @type "int", @default 0, @description "waveform type.", @options 
            $addopt(@value 0, @description "sinusoid")
            $addopt(@value 1, @description "triangular")
            $addopt(@value 2, @description "rectangular")
            $addopt(@value 3, @description "sawtooth")
        )
        $addarg(@name "normalize", @type "int", @default 0, @description "audio normalization.", @options 
            GS_REF_NORMALIZE_OPTIONS
        )
    ),
    @output $addout(@description "synthesized grain" @type "llll")
);

## ------------------------------------------------------------

render = (
   $numchannels = 2, $panmode = 0, $sr = 48000, $normalize = 0, $play = 0, $spread = 0, $process = null -> (
        if $numchannels < 1 then printerror("number of channels must be greater than 0");
        msg("sampler", 
            [ "panmode" $panmode] 
            [ "numchannels" $numchannels ] 
            [ "sr" $sr ]
            [ "normalize" $normalize ]
            [ "spread" $spread ]
        );
        msg("roll", "getlength");
        msg("roll", "dump");
        ($process &&& msg("sampler", [ "process" $process ] ));
        ($play == 1 && msg("playtoggle", 1))
    )
);

$addref(
    @name "render",
    @description "Triggers audio rendering of all transcribed grains via #transcribe. Note that it's possible to apply post-rendering processing by passing audio processing commands (e.g., #reverse, #freeverb, #clip, etc.) to the @process arguments, but these audio modifications won't be accurately reflected in the score transcription. See #process function.",
    @arguments (
        $addarg(@name "numchannels", @type "int", @default 2, @description "number of output channels.")
        $addarg(@name "panmode", @type "int", @default 0, @description "panning mode." @options 
            $addopt(@value 0, @description "linear")
            $addopt(@value 1, @description "circular")
        )
        $addarg(@name "sr", @type "int", @default 48000, @description "sampling rate.")
        $addarg(@name "normalize", @type "int", @default 0, @description "audio normalization." @options 
            GS_REF_NORMALIZE_OPTIONS
        )
        $addarg(@name "play", @type "int", @default 0, @description "autoplay rendered buffer.", @options
            GS_REF_SWITCH_OPTIONS
        )
        $addarg(@name "spread", @type "int/float", @default 0, @description "multichannel panning spread, between 0 and 1.")
        $addarg(@name "process", @type "llll", @description "optional post-rendering audio processing commands.")
    )
);

## ------------------------------------------------------------

export = (
    $path, $stems = 0, $format = "float32" -> (
        ## get path info
        $pathinfo = getpathinfo($path);
        $path = $pathinfo.'path';
        $ext = $pathinfo.'extension';
        $filepath = $path + $ext;

        ## check file type
        if $ext == ".wav" then (
            ## get audio format
            $settings = [ "format" $format ];

            ## check if stem or single file export
            if $stems == 0 then (
                ## send settings first
                for $setting in $settings with @unwrap 1 do (
                    msg("buffer", $setting)
                );
                ## send write message
                msg("buffer", "writewave" $filepath )
            ) else (
                ## send stem info and let subpatcher do the rest
                msg("stems", [ "buffer" $settings ] $pathinfo )
            )
        ) else if $ext == ".mid" || $ext == ".midi" then (
            msg("roll", "exportmidi" $filepath)
        ) else if $ext == ".llll" then (
            msg("roll", "write" $filepath)
        ) else (
            printerror("file format is not supported:" $ext)
        )
    )
);

$addref(
    @name "export",
    @description "Exports the rendered output as either a .wav, .mid/midi. or .llll file, given a output path. For .wav files, mono stem files can be separately exported. See #render function.",
    @arguments (
        $addarg(@name "path", @type "symbol", @description "output file path.")
        $addarg(@name "stems", @default 0 @type "int", @description "stem export mode for .wav files." @options
            GS_REF_SWITCH_OPTIONS
        )
    )
);

## ------------------------------------------------------------

importmidi = (
    $path -> (
        GS_TMP_ROLL_OUTPUT = null;
        if $path == null then printerror("You must provide a value for @path in importmidi()");
        $pathinfo = getpathinfo($path);
        $ext = $pathinfo."extension";
        $path = $pathinfo."path";
        $filepath = $path + $ext;
        if $ext == ".midi" || $ext == ".mid" then (
            msg("import", [
                "roll"
                $filepath
            ])
        ) else (
            printerror(if $ext == null then "you must provide a file path" else "invalid file extension:" $ext)
        );
        GS_TMP_ROLL_OUTPUT
    )
);

$addref(
    @name "importmidi",
    @description "Imports a midi file, as a list of events, each with the following keys: 'pitch' , 'velocity', 'onset', 'voice', 'channel', and 'duration'",
    @arguments (
        $addarg(@name "path", @type "symbol", @description "input midi file path.")
    ),
    @output $addout(@description "midi events" @type "llll")
);

## ------------------------------------------------------------

hanning = ($N = 16 -> ($N -= 1; sin((pi * (0...$N)) / $N) ** 2.));

$addref(
    @name "hanning",
    @description "Generates a hanning window as a numeric list.",
    @arguments (
        $addarg(@name "N", @type "int", @default 16, @description "window resolution.")
    ),
    @output $addout(@description "hanning window" @type "list")
);

## ------------------------------------------------------------

#( 
    adapted from emmanuel jourdan: https://cycling74.com/forums/math-behind-function-curve
    NOTE: this is implementation is different from both bach's (closest) and Max.
)#

interpolate = (
    $x, $a, $b, $slope = 0 -> (
        $ca = 1.2;
        $cb = .41;
        $cc = .91;
        $m = 1e-20;
        $xrange = $b:1 - $a:1;
        $yrange = $b:2 - $a:2;
        if abs($slope) < .001 then (
            (($x - $a:1) / $xrange) * $yrange + $a:2
        ) else (
            if $slope < 0 then (
                $gx = ($b:1 - $x) / $xrange;
                $hp = (($m - $slope) * $ca) ** $cb * $cc;
                $fp = $hp / (1.0 - $hp);
                $gp = (exp($fp * $gx) - 1.) / (exp($fp) - 1.0);
                $b:2 - $gp * $yrange
            ) else (
                $gx = ($x - $a:1) / $xrange;
                $hp = (($slope + $m) * $ca)  ** $cb * $cc;
                $fp = $hp / (1.0 - $hp);
                $gp = (exp($fp * $gx) - 1.) / (exp($fp) - 1.0);
                $gp * $yrange + $a:2
            )
        )
    )
);

$addref(
    @name "interpolate",
    @description "Curve interpolation between two points.",
    @arguments (
        $addarg(@name "x", @type "int/float/list", @description "interpolation point")
        $addarg(@name "a", @type "list", @description "xy coordinates for point A")
        $addarg(@name "b", @type "list", @description "xy coordinates for point B")
        $addarg(@name "slope", @type "list", @default 0, @description "slope of curve between the two points, in the -1 to 1 range")
    ),
    @output $addout(@description "interpolated values" @type "int/float/list")
);

## ------------------------------------------------------------

samplebpf = (
    $bpf, $pts -> (
        $cols = trans($bpf);
        $xvals = $cols::1;
        $yvals = $cols::2;
        $cvals = $cols::3;
        $N = length($bpf);
        for $pt in $pts collect (
            $xdiffs = $xvals - $pt;
            $i = 1;
            $pos = null;
            while $i <= $N do (
                $dx = $xdiffs:$i;
                if $dx >= 0 then (
                    $pos = max(1, $i - 1);
                    $i = $N + 1
                ) else (
                    $i += 1
                )
            );
            $a = left(($bpf:$pos)::1, 2);
            $b = ($bpf:(min($pos + 1, $N)))::1;
            $slope = $b:3;
            $b = left($b, 2);
            interpolate($pt, $a, $b, $slope)
        )
    )
);

$addref(
    @name "samplebpf",
    @description "Samples an interpolated value from a breakpoint function, given a list of normalized indices. See #bpf function.",
    @arguments (
        $addarg(@name "bpf", @type "llll", @description "breakpoint function")
        $addarg(@name "pts", @type "int/float/list", @description "sampling point/s")
    ),
    @output $addout(@description "interpolated bpf values" @type "int/float/list")
);

## ------------------------------------------------------------

process = (
    $grain, $commands, $prefade = null -> (
        if $grain == null then (
            printerror("attempt to pass null value as @grain in process()")
        ) else if $commands == null then (
            printerror("you must provide audio processing commands in process()")
        );
        $offset = $grain.getkey("offset");
        msg(
            "process",
            [ "source" $grain.getkey("file") ]
            [ "process" 
                crop(@start $offset, @end $offset + $grain.getkey("duration"))
                ($prefade &&& $prefade > 0 &&& fade(@fadein $prefade, @fadeout $prefade))
                $commands 
            ]
        );
        [ GS_TMP_GRAIN ]
    )
);

$addref(
    @name "process",
    @description "Applies a sequence of DSP operations to the input grain, prior to rendering, via audio processing commands. These commands are generated through functions (e.g., see #reverse, #paulstretch, #freeverb, #rubberband), which contain the parameters for that specific DSP operation. See @process argument in #render.",
    @arguments (
        $addarg(@name "grain", @type "llll", @description "grain to process.")
        $addarg(@name "commands", @type "llll", @description "list of audio process commands.")
        $addarg(@name "prefade", @default "null" @type "llll/null", @description "optional pre-fade amount, in milliseconds.")
    ),
    @output $addout(@description "processed grain" @type "llll")
);


## ------------------------------------------------------------

fade = (
    $fadein = 5, 
    $fadeout = 5,
    $fadeincurve = -0.25,
    $fadeoutcurve = 0.25,
    $fadeintype = 0,
    $fadeouttype = 0,
    $timeunit = 0 -> (
        [
            [ "fx" "fade" ]
            [ "params"
                [ "fadein" $fadein ]
                [ "fadeout" $fadeout ]
                [ "timeunit" $timeunit ]
                [ "fadeincurve" $fadeincurve ]
                [ "fadeoutcurve" $fadeoutcurve ]
                [ "fadeintype" $fadeintype + 1 ]
                [ "fadeouttype" $fadeouttype + 1 ]
            ]
        ]
    )
);

$addref(
    @name "fade",
    @description "Audio process command for applying fadein/fadeout to a buffer. See #process.",
    @arguments (
        $addarg(@name "fadein", @default 5, @type "int/float", @description "fade-in duration.")
        $addarg(@name "fadeout", @default 5, @type "int/float", @description "fade-out duration.")
        $addarg(@name "fadeintype", @default 0, @type "int", @description "fade-in type.", @options 
            GS_REF_CURVE_OPTIONS
        )
        $addarg(@name "fadeouttype",@default 0, @type "int", @description "fade-out type.", @options 
            GS_REF_CURVE_OPTIONS
        )
        $addarg(@name "fadeincurve", @default "-0.25", @type "int/float", @description "fade-in curve amount, between -1 and 1.")
        $addarg(@name "fadeoutcurve", @default "0.25", @type "int/float", @description "fade-out curve amount, between -1 and 1.")
        $addarg(@name "timeunit", @default 0 @type "int", @description "time unit for @start and @end." @options
            GS_REF_TIMEUNIT_OPTIONS
        )
    ),
    @output $addout(@description "fade command" @type "llll")
);


## ------------------------------------------------------------


crop = (
    $start,
    $end,
    $timeunit = 0 -> (
        if $end == null || $start == null then printerror("you must provide values for @start and @end in crop()");
        if $end <= $start then printerror("@end must be greater than @start in crop()");
        [
            ["fx" "crop"]
            ["params" 
                ["start" $start ]
                ["end" $end ]
            ]
        ]
    )
);

$addref(
    @name "crop",
    @description "Audio process command for cropping a buffer. See #process.",
    @arguments (
        $addarg(@name "start", @type "int/float", @description "start time.")
        $addarg(@name "end", @type "int/float", @description "end time.")
        $addarg(@name "timeunit", @default 0 @type "int", @description "time unit for @start and @end." @options
            GS_REF_TIMEUNIT_OPTIONS
        )
    ),
    @output $addout(@description "processed grain" @type "llll")
);


## ------------------------------------------------------------

reverse = ( -> [ [ "fx" "reverse" ] ]);

$addref(
    @name "reverse",
    @description "Audio process command for reversing a buffer. See #process.",
    @output $addout(@description "reverse command" @type "llll")
);

## ------------------------------------------------------------

freeverb = (
    $roomsize = .5,
    $damp = .5,
    $width = .5,
    $tail = -1,
    $dry = 1., 
    $wet = 1/6. -> (
        [
            ["fx" "freeverb"]
            [ "params" 
                [ "roomsize" $roomsize ]
                [ "damp" $damp ]
                [ "width" $width ]
                [ "tail" $tail ]
                [ "dry" if depth($dry) > 1 || length($dry) > 1 then [ bpf($dry) ] else $dry ]
                [ "wet" if depth($wet) > 1 || length($wet) > 1 then [ bpf($wet) ] else $wet ]
            ]
        ]
    )
);

$addref(
    @name "freeverb",
    @description "Audio process command for applying reverb to a buffer. See #process function.",
    @arguments (
        $addarg(@name "roomsize", @default "0.5", @type "int/float", @description "reverb room size")
        $addarg(@name "damp", @default "0.5", @type "int/float", @description "damping coefficient")
        $addarg(@name "width", @default "0.5", @type "int/float", @description "panning width/spread, from 0 to 1.")
        $addarg(@name "tail", @default -1, @type "int/float", @description "duration of reverb tail in ms." @options 
            $addopt(@value -1 @description "auto")
            $addopt(@value 0 @description "no tail")
            $addopt(@value ">0" @description "duration in ms")
        )
        $addarg(@name "dry", @default 1, @type "int/float/llll", @description "amount of dry output, as either a single number or envelope.")
        $addarg(@name "wet", @default "0.16", @type "int/float/llll", @description "amount of wet output, as either a single number or envelope.")
    ),
    @output $addout(@description "freeverb command" @type "llll")
);

## ------------------------------------------------------------

gs_makegrain = (
    $file,
    $duration,  
    $offset = 0,
    $file_id = -1,
    $mfcc = 0. :* 13,
    $pitch = 0,
    $pitchsalience = 0,
    $centroid = 0,
    $loudness = 0,
    $zerox = 0 -> (
        [
            [ "file" $file ]
            [ "offset" $offset ]
            [ "duration" $duration ]
            [ "file_end" $duration ]
            [ "file_id" $file_id ]
            [ "mfcc" $mfcc ]
            [ "pitch" $pitch ]
            [ "pitchclass" fmod($pitch / 100.0, 12) ]
            [ "pitchsalience" $pitchsalience ]
            [ "centroid" $centroid ]
            [ "loudness" $loudness ]
            [ "zerox" $zerox ]
        ]
    )
);

## ------------------------------------------------------------

cycle = (
    $frequency = 0, 
    $duration = 1000 -> (
        $file = $frequency.getkey("file");
        $pitch = 0;
        if $file == null then (
            $file = envelope($frequency, @duration $duration).getkey("file");
            $pitch = f2mc(maximum($frequency ||| 1))
        );
        msg("generate", 
            [
                [ "fx" "cycle"]
                [ "params" 
                    [ $file ]
                ]
            ]
        );
        gs_makegrain(GS_TMP_BUFF, @loudness .707, @pitch $pitch @duration $duration)
    )
);

## ------------------------------------------------------------

envelope = (
    $envelope = 0, 
    $duration = 1000 -> (
        $depth = depth($envelope);
        $length = length($envelope);
        if $depth > 1 || $length > 1 then ($envelope = [ bpf($envelope) ]);
        msg("generate", 
            [
                [ "fx" "envelope"]
                [ "params" 
                    [ "duration" $duration ]
                    [ $envelope ]
                ]
            ]
        );
        gs_makegrain(GS_TMP_BUFF, @duration $duration)
    )
);

$addref(
    @name "envelope",
    @description "Generates an audio envelope as a grain, given a single number or a breakpoint function.",
    @arguments (
        $addarg(@name "envelope", @default 0, @type "int/float/llll", @description "envelope, as either a single number or a breakpoint function.")
        $addarg(@name "duration", @default 1000, @type "int", @description "envelope duration, in milliseconds")
    ),
    @output $addout(@description "envelope" @type "llll")
);

## ------------------------------------------------------------

paulstretch = (
    $stretching = 1,
    $timeunit = 2,
    $envtimeunit = 2,
    $spectral = 1,
    $framesize = 8192 -> (
        $stretching = if depth($stretching) > 1 || length($stretching) > 1 then [ bpf($stretching) ] else $stretching;
        [
            [ "fx" "paulstretch" ]
            [ "params" 
                [ "stretching" $stretching ||| 1 ]
                [ "timeunit" $timeunit ]
                [ "envtimeunit" $envtimeunit ]
                [ "spectral" $spectral ] 
                [ "framesize" $framesize ] 
            ]
        ]
    )
);

$addref(
    @name "paulstretch",
    @description "Audio process command for applying time-stretching to a buffer. See #process.",
    @arguments (
        $addarg(@name "stretching", @default 1, @type "int/float/llll", @description "stretching amount, as single number or envelope.")
        $addarg(@name "timeunit", @default 2, @type "int", @description "time unit for @stretching." @options (
            GS_REF_TIMEUNIT_OPTIONS
        ))
        $addarg(@name "envtimeunit", @default 2, @type "int", @description "time unit for @stretching envelope." @options 
            GS_REF_TIMEUNIT_OPTIONS
        )
        $addarg(@name "spectral", @default 1, @type "int", @description "stretching mode." @options 
            GS_REF_AUDIO_DOMAIN_OPTIONS
        )
        $addarg(@name "framesize", @default 8192, @type "int", @description "analysis frame size, in samples.")
    ),
    @output $addout(@description "paulstretch command" @type "llll")
);

## ------------------------------------------------------------

paulfreeze = (
    $duration = 1,
    $onset = 0,
    $timeunit = 2,
    $spectral = 1,
    $framesize = 8192 -> (
        [
            [ "fx" "paulfreeze" ]
            [ "params" 
                [ "duration" $duration ||| 1000 ]
                [ "onset" (if length($onset) > 1 then [$onset] else $onset) ||| 0 ]
                [ "timeunit" $timeunit ]
                [ "spectral" $spectral ]
                [ "framesize" $framesize ]
            ]
        ]
    )
);

$addref(
    @name "paulfreeze",
    @description "Audio process command for freezing a buffer. See #process.",
    @arguments (
        $addarg(@name "duration", @default 1, @type "int/float", @description "freezing duration.")
        $addarg(@name "onset", @default 0, @type "int/float/llll", @description "freezing duration.")
        $addarg(@name "timeunit", @default 2, @type "int", @description "time unit for @duration.", @options 
            GS_REF_TIMEUNIT_OPTIONS
        )
        $addarg(@name "spectral", @default 1, @type "int", @description "stretching mode." @options 
            GS_REF_AUDIO_DOMAIN_OPTIONS
        )
        $addarg(@name "framesize", @default 8192, @type "int", @description "analysis frame size, in samples.")
    ),
    @output $addout(@description "paulfreeze command" @type "llll")
);

## ------------------------------------------------------------

overdrive = (
    $factor = 1 -> (
        $factor = if depth($factor) > 1 || length($factor) > 1 then [ bpf($factor) ] else $factor;
        [
            [ "fx" "overdrive" ]
            [ "params" 
                [ "factor" $factor ]
            ]
        ]
    )
);

$addref(
    @name "overdrive",
    @description "Audio process command for applying soft-clip distortion to a buffer. See #process.",
    @arguments (
        $addarg(@name "factor", @type "int/float/llll", @description "amplitude distortion factor, either as single number or envelope.")
    ),
    @output $addout(@description "overdrive command" @type "llll")
);

## ------------------------------------------------------------

window = (
    $wintype = "hann",
    $winnormalized = 0,
    $zeropadding = 0,
    $zerophase = 0 -> (
        [
            [ "fx" "window" ]
            [ "params" 
                [ "wintype" $wintype ]
                [ "winnormalized" $winnormalized ]
                [ "zeropadding" $zeropadding ]
                [ "zerophase" $zerophase ]
            ]
        ]
    )
);

$addref(
    @name "window",
    @description "Audio process command for applying a windowing function to a buffer. See #process.",
    @arguments (
        $addarg(@name "wintype", @default "hann", @type "symbol", @description "window type, as a symbol" @options
            GS_REF_WINDOW_OPTIONS
        )
        $addarg(@name "winnormalized", @default 0, @type "int", @description "normalize window samples to sum up to 1 and multiply by a factor of 2." @options 
            GS_REF_SWITCH_OPTIONS
        )
        $addarg(@name "zeropadding", @default 0, @type "int", @description "number of samples for zero padding.")
        $addarg(@name "zerophase", @default 0, @type "int", @description "zero phase windowing" @options 
            GS_REF_SWITCH_OPTIONS
        )
    ),
    @output $addout(@description "window command" @type "llll")
);

## ------------------------------------------------------------

biquad = (
    $freq = 2000,
    $type = 0,
    $gain = 1,
    $q = 80 -> (
        [
            [ "fx" "biquad" ]
            [ "params" 
                [ "type" $type + 1 ]
                [ "freq" $freq ]
                [ "gain" $gain ]
                [ "q" $q ]
            ]
        ]
    )
);

$addref(
    @name "biquad",
    @description "Audio process command for applying biquad filtering to a buffer. See #process.",
    @arguments (
        $addarg(@name "type", @type "int", @description "filter type." @options
            $addopt(@value 0 @description "lowpass")
            $addopt(@value 1 @description "highpass")
            $addopt(@value 2 @description "bandpass")
            $addopt(@value 3 @description "bandstop")
            $addopt(@value 4 @description "peaknotch")
            $addopt(@value 5 @description "lowshelf")
            $addopt(@value 6 @description "highshelf")
            $addopt(@value 7 @description "resonant")
            $addopt(@value 8 @description "allpass")
        )
        $addarg(@name "freq", @default 2000, @type "int/float", @description "cutoff/center frequency.")
        $addarg(@name "gain", @default 1, @type "int/float", @description "linear gain.")
        $addarg(@name "q", @default 80, @type "int/float", @description "resonance or slope, depending on @type.")
    ),
    @output $addout(@description "biquad command" @type "llll")
);

## ------------------------------------------------------------

clip = (
    $threshold = 1 -> (
        $threshold = if depth($threshold) > 1 || length($threshold) > 1 then [ bpf($threshold) ] else $threshold;
        [
            [ "fx" "clip" ]
            [ "params" 
                [ "threshold" $threshold ]
            ]
        ]
    )
);

$addref(
    @name "clip",
    @description "Audio process command for applying hard-clip distortion to a buffer. See #process.",
    @arguments (
        $addarg(@name "factor", @type "int/float/llll", @description "distortion amplitude threshold, either as single number or envelope.")
    ),
    @output $addout(@description "clip command" @type "llll")
);

## ------------------------------------------------------------

rubberband = (
    $stretching = 1,
    $pitchshift = 0,
    $pitchunit = 0,
    $timeunit = 2,
    $envtimeunit = 2,
    $blocksize = 1024,
    $fftwin = 1,
    $phase = 0,
    $pitchmode = 2,
    $formants = 0,
    $smoothing = 0,
    $stretchmode = 0,
    $detector = 0,
    $transients = 2 -> (
        $stretching = if depth($stretching) > 1 || length($stretching) > 1 then [ bpf($stretching) ] else $stretching;
        $pitchshift = if depth($pitchshift) > 1 || length($pitchshift) > 1 then [ bpf($pitchshift) ] else $pitchshift;
        [
            [ "fx" "rubberband" ]
            [ "params" 
                [ "stretching" $stretching ||| 1 ]
                [ "pitchshift" $pitchshift ||| 1 ]
                [ "pitchunit" $pitchunit ]
                [ "timeunit" $timeunit ]
                [ "envtimeunit" $envtimeunit ]
                [ "blocksize" $blocksize ]
                [ "fftwin" $fftwin ]
                [ "phase" $phase ]
                [ "pitchmode" $pitchmode ]
                [ "formants" $formants ]
                [ "smoothing" $smoothing ]
                [ "stretchmode" $stretchmode ]
                [ "detector" $detector ]
                [ "transients" $transients ] 
            ]
        ]
    )
);

$addref(
    @name "rubberband",
    @description "Audio process command for applying rubberband pitch-shifting/time-stretching to a buffer. See #process.",
    @arguments (
        $addarg(@name "stretching", @default 1, @type "int/float/llll", @description "stretching amount, as single number or envelope.")
        $addarg(@name "pitchshift", @default 0, @type "int/float/llll", @description "pitch shifting amount, as single number or envelope.")
        $addarg(@name "pitchunit", @default 0, @type "int", @description "unit for @pitchshift." @options
            GS_REF_PITCH_FORMAT_OPTIONS
        )
        $addarg(@name "timeunit", @default 2, @type "int", @description "time unit for @stretching." @options 
            GS_REF_TIMEUNIT_OPTIONS
        )
        $addarg(@name "envtimeunit", @default 2, @type "int", @description "time unit for @stretching envelope." @options
            GS_REF_TIMEUNIT_OPTIONS
        )
        $addarg(@name "blocksize", @default 1024, @type "int", @description "size for granular processes, such as envelopes, in samples.")
        $addarg(@name "fftwin", @default 1, @type "int", @description "FFT window type." @options
            $addopt(@value 0 @description "short") 
            $addopt(@value 1 @description "standard") 
            $addopt(@value 2 @description "long")
        )
        $addarg(@name "phase", @default 0, @type "int", @description "phase adjustment mode." @options
            $addopt(@value 0 @description "elastic") 
            $addopt(@value 1 @description "precise") 
        )
        $addarg(@name "pitchmode", @default 2, @type "int", @description "pitch shift mode." @options
            $addopt(@value 0 @description "high speed") 
            $addopt(@value 1 @description "high quality") 
            $addopt(@value 2 @description "high consistency") 
        )
        $addarg(@name "formants", @default 0, @type "int", @description "formant processing." @options
            GS_REF_SWITCH_OPTIONS
        )
        $addarg(@name "smoothing", @default 0, @type "int", @description "time-domain smoothing." @options
            GS_REF_SWITCH_OPTIONS
        )
        $addarg(@name "stretchmode", @default 0, @type "int", @description "stretch mode." @options 
            $addopt(@value 0 @description "elastic") 
            $addopt(@value 1 @description "precise") 
        )
        $addarg(@name "detector", @default 0, @type "int", @description "transient detection algorithm." @options
            $addopt(@value 0 @description "compound") 
            $addopt(@value 1 @description "percussive") 
            $addopt(@value 2 @description "soft") 
        )
        $addarg(@name "transients", @default 2, @type "int", @description "transient type." @options
            $addopt(@value 0 @description "crisp") 
            $addopt(@value 1 @description "mixed") 
            $addopt(@value 2 @description "smooth") 
        )
    ),
    @output $addout(@description "rubberband command" @type "llll")
);

## ------------------------------------------------------------

soundtouch = (
    $stretching = 1,
    $pitchshift = 0,
    $pitchunit = 0,
    $timeunit = 2,
    $antialias = 0,
    $quick = 0,
    $speech = 0 -> (
        [
            [ "fx" "soundtouch" ]
            [ "params" 
                [ "stretching" $stretching ||| 1 ]
                [ "pitchshift" $pitchshift ||| 1 ]
                [ "pitchunit" $pitchunit ]
                [ "timeunit" $timeunit ]
                [ "naa" $antialias ]
                [ "quick" $quick ]
                [ "speech" $speech ]
            ]
        ]
    )
);

$addref(
    @name "soundtouch",
    @description "Audio process command for applying soundtouch pitch-shifting/time-stretching to a buffer. See #process.",
    @arguments (
        $addarg(@name "stretching", @default 1, @type "int/float", @description "stretching amount, as a single number.")
        $addarg(@name "pitchshift", @default 0, @type "int/float", @description "pitch shifting amount, as single number.")
        $addarg(@name "pitchunit", @default 0, @type "int", @description "unit for @pitchshift." @options
            GS_REF_PITCH_FORMAT_OPTIONS
        )
        $addarg(@name "timeunit", @default 2, @type "int", @description "time unit for @stretching." @options 
            GS_REF_TIMEUNIT_OPTIONS
        )
        $addarg(@name "antialias", @default 0, @type "int", @description "anti-aliasing filter." @options 
            GS_REF_SWITCH_OPTIONS
        )
        $addarg(@name "quick", @default 0, @type "int", @description "quick processing. " @options 
            GS_REF_SWITCH_OPTIONS
        )
        $addarg(@name "speech", @default 0, @type "int", @description "tune algorithm for speech. " @options 
            GS_REF_SWITCH_OPTIONS
        )
    ),
    @output $addout(@description "soundtouch command" @type "llll")
);

## ------------------------------------------------------------

repeat = (
    $duration = 2,
    $timeunit = 2 -> (
        [
            [ "fx" "repeat" ]
            [ "params"
                [ "duration" max(1, $duration) ]
                [ "timeunit" $timeunit ]
            ]
        ]
    )
);

$addref(
    @name "repeat",
    @description "Audio process command for repeating a buffer. See #process.",
    @arguments (
        $addarg(@name "duration", @default 2, @type "int/float", @description "target duration, based on @timeunit.")
        $addarg(@name "timeunit", @default 2, @type "int", @description "time unit for @duration." @options
            GS_REF_TIMEUNIT_OPTIONS
        )
    ),
    @output $addout(@description "repeat command" @type "llll")
);

## ------------------------------------------------------------

mix = (
    $grains = null,
    $gains = null,
    $offsets = null,
    $resamplingfiltersize = 11,
    $resamplingmode = 'sinc',
    $resamplingpolicy = 3,
    $ampunit = 0,
    $envampunit = 0,
    $timeunit = 0,
    $envtimeunit = 2,
    $interp = 0,
    $normalize = 0 -> (
        if $grains == null then printerror("you must provide a values for @grains in mix()");
        $numgrains = length($grains) + 1;
        [
            [ "fx" "mix" ]
            [ "params"
                [ "buffers" for $g in $grains collect $g.getkey("file") ]
                [ "gains" right(1 $gains, -$numgrains) ]
                [ "offsets" right(0 $offsets, -$numgrains) ]
                [ "resamplingfiltersize" $resamplingfiltersize ]
                [ "resamplingmode" $resamplingmode ]
                [ "resamplingpolicy" $resamplingpolicy ]
                [ "ampunit" $ampunit ]
                [ "envampunit" $envampunit ]
                [ "timeunit" $timeunit ]
                [ "envtimeunit" $envtimeunit ]
                [ "interp" $interp ]
                [ "normalize" $normalize ]
            ]
        ]
    )
);

$addref(
    @name "mix",
    @description "Audio process command for mixing multiple buffers. See #process.",
    @arguments (
        $addarg(@name "grains", @type "list/llll", @description "list of grains to mix.")
        $addarg(@name "gains", @default "null" @type "list/llll/null", @description "gain values for each grain to mix, as either a single number or envelope.")
        $addarg(@name "offsets", @default "null", @type "list/null", @description "time offset values for each grain to mix.")
        $addarg(@name "resamplingfiltersize", @default 11, @type "int", @description "resampling filter size.")
        $addarg(@name "resamplingmode", @default "sinc", @type "symbol", @description "resampling mode." @options
            GS_REF_RESAMPLINGMODE_OPTIONS
        )
        $addarg(@name "resamplingpolicy", @default 3, @type "int", @description "resampling policy." @options
            GS_REF_RESAMPLINGPOLICY_OPTIONS
        )
        $addarg(@name "ampunit", @default 0, @type "int", @description "amplitude unit." @options
            GS_REF_AMPUNIT_OPTIONS
        )
        $addarg(@name "envampunit", @default 0, @type "int", @description "envelope amplitude unit." @options
            GS_REF_AMPUNIT_OPTIONS
        )
        $addarg(@name "timeunit", @default 0, @type "int", @description "time unit." @options
            GS_REF_TIMEUNIT_OPTIONS
        )
        $addarg(@name "envtimeunit", @default 2, @type "int", @description "envelope time unit." @options
            GS_REF_TIMEUNIT_OPTIONS
        )
        $addarg(@name "interp", @default 0, @type "int", @description "band-limited interpolation via resampling for non-integer offsets." @options 
            GS_REF_SWITCH_OPTIONS
        )
        $addarg(@name "normalize", @default 0, @type "int", @description "normalization." @options 
            GS_REF_NORMALIZE_OPTIONS
        )
    ),
    @output $addout(@description "mix command" @type "llll")
);

## ------------------------------------------------------------

GS_BUFFER_ARITHMETIC_FUNC = (
    $name,
    $operand,
    $resamplingfiltersize = 11,
    $resamplingmode = "sinc",
    $resamplingpolicy = 3,
    $envtimeunit = 2 -> (
        ## raise error if @operand is null
        if $operand == null then printerror("you must provide a value for @operand in " + $name + "().");

        ## check if @operand is grain, envelope or scalar.
        $depth = depth($operand);
        $length = length($operand);
        if $depth > 1 || $length > 1 then (
            $file = $operand.getkey("file");
            ## if grain, assign file to @operand
            if $file != null then (
                $operand = $file
            ) else (
                ## if envelope, clean format and wrap if envelope
                $operand = [ bpf($operand) ]
            )
        );
        [
            [ "fx" $name ]
            [ "params"
                [ "operand" left($operand, 1) ]
                [ "resamplingfiltersize" $resamplingfiltersize ]
                [ "resamplingmode" $resamplingmode ]
                [ "resamplingpolicy" $resamplingpolicy ]
                [ "envtimeunit" $envtimeunit ]
            ]
        ]
    )
);

GS_BUFFER_ARITHMETIC_ARGS = (
    $addarg(@name "resamplingfiltersize", @default 11, @type "int", @description "resampling filter size.")
    $addarg(@name "resamplingmode", @default "sinc", @type "symbol", @description "resampling mode." @options
        GS_REF_RESAMPLINGMODE_OPTIONS
    )
    $addarg(@name "resamplingpolicy", @default 3, @type "int", @description "resampling policy." @options
        GS_REF_RESAMPLINGPOLICY_OPTIONS
    )
    $addarg(@name "envtimeunit", @default 2, @type "int", @description "envelope time unit." @options
        GS_REF_TIMEUNIT_OPTIONS
    )
);

## ------------------------------------------------------------

plus = (
    $operand,
    $resamplingfiltersize = 11,
    $resamplingmode = "sinc",
    $resamplingpolicy = 3,
    $envtimeunit = 2 -> (
        GS_BUFFER_ARITHMETIC_FUNC(
            @name "plus"
            @operand $operand
            @resamplingfiltersize $resamplingfiltersize
            @resamplingmode $resamplingmode
            @resamplingpolicy $resamplingpolicy
            @envtimeunit $envtimeunit
        )
    )
);

$addref(
    @name "plus",
    @description "Audio process command for performing addition on a buffer. See #process.",
    @arguments (
        $addarg(@name "operand", @type "int/float/llll", @description "value to add to buffer, either as a single number, envelope, or grain.")
        GS_BUFFER_ARITHMETIC_ARGS
    ),
    @output $addout(@description "plus command" @type "llll")
);

## ------------------------------------------------------------

multiply = (
    $operand,
    $resamplingfiltersize = 11,
    $resamplingmode = "sinc",
    $resamplingpolicy = 3,
    $envtimeunit = 2 -> (
        GS_BUFFER_ARITHMETIC_FUNC(
            @name "multiply"
            @operand $operand
            @resamplingfiltersize $resamplingfiltersize
            @resamplingmode $resamplingmode
            @resamplingpolicy $resamplingpolicy
            @envtimeunit $envtimeunit
        )
    )
);

$addref(
    @name "multiply",
    @description "Audio process command for performing multiplication on a buffer. See #process.",
    @arguments (
        $addarg(@name "operand", @type "int/float/llll", @description "value to multiply buffer by, either as a single number, envelope, or grain.")
        GS_BUFFER_ARITHMETIC_ARGS
    ),
    @output $addout(@description "multiply command" @type "llll")
);

## ------------------------------------------------------------

divide = (
    $operand,
    $resamplingfiltersize = 11,
    $resamplingmode = "sinc",
    $resamplingpolicy = 3,
    $envtimeunit = 2 -> (
        GS_BUFFER_ARITHMETIC_FUNC(
            @name "divide"
            @operand $operand
            @resamplingfiltersize $resamplingfiltersize
            @resamplingmode $resamplingmode
            @resamplingpolicy $resamplingpolicy
            @envtimeunit $envtimeunit
        )
    )
);

$addref(
    @name "divide",
    @description "Audio process command for performing division on a buffer. See #process.",
    @arguments (
        $addarg(@name "operand", @type "int/float/llll", @description "value to divide buffer by, either as a single number, envelope, or grain.")
        GS_BUFFER_ARITHMETIC_ARGS
    ),
    @output $addout(@description "divide command" @type "llll")
);

## ------------------------------------------------------------

wavesetrepeat = (
    $times = 2,
    $span = 1,
    $normalize = 0 -> (
        [
            [ "fx" "wavesetrepeat" ]
            [ "params"
                [ "times" max(1, $times) ]
                [ "span" $span ]
                [ "normalize" $normalize ]
            ]
        ]
    )
);

$addref(
    @name "wavesetrepeat",
    @description "Audio process command for applying waveset repetition to a buffer. See #process.",
    @arguments (
        $addarg(@name "times",  @default 2, @type "int", @description "number of repetitions.")
        $addarg(@name "span", @default 1, @type "int", @description "number of negative-to-positive zero crossing regions that form a waveset.")
        $addarg(@name "normalize", @default 0, @type "int", @description "waveset normalization." @options 
            GS_REF_SWITCH_OPTIONS
        )
    ),
    @output $addout(@description "waveset repeat command" @type "llll")
);

## ------------------------------------------------------------

wavesetshuffle = (
    $maxdist = 1,
    $span = 1 -> (
        [
            [ "fx" "wavesetshuffle" ]
            [ "params"
                [ "maxdist" $maxdist ]
                [ "span" $span ]
            ]
        ]
    )
);

$addref(
    @name "wavesetshuffle",
    @description "Audio process command for applying waveset shuffling to a buffer. See #process.",
    @arguments (
        $addarg(@name "maxdist", @default 1, @type "int", @description "maximum shuffling distance.")
        $addarg(@name "span", @default 1, @type "int", @description "number of negative-to-positive zero crossing regions that form a waveset.")
    ),
    @output $addout(@description "waveset shuffle command" @type "llll")
);

## ------------------------------------------------------------

onepole = (
    $cutoff,
    $highpass = 0 -> (
        if $cutoff == null then (
            printerror("you must provide @cutoff value in onepole()")
        );
        [
            [ "fx" "onepole" ]
            [ "params"
                [ "cutoff" $cutoff ]
                [ "highpass" $highpass ]
            ]
        ]
    )
);

$addref(
    @name "onepole",
    @description "Audio process command for applying single-pole lowpass or highpass filtering to a buffer. See #process.",
    @arguments (
        $addarg(@name "cutoff", @default 1, @type "int/float", @description "cutoff frequency.")
        $addarg(@name "highpass", @default 0, @type "int", @description "highpass filter mode." @options
            GS_REF_SWITCH_OPTIONS
        )
    ),
    @output $addout(@description "onepole command" @type "llll")
);

## ------------------------------------------------------------

timesquash = (
    $duration = 1,
    $timeunit = 2, 
    $timeblock = 4096,
    $mode = 1,
    $xfade = 4096,
    $xfadecurve = 0,
    $xfadetype = 2,
    $glbleed = 4,
    $glnumiter = 10,
    $glrandomize = 0,
    $glrect = 1,
    $batchsize = 1,
    $batchinterrupt = 0,
    $energy = 2,
    $forwardenergy = 1.,
    $forwardenergyembed = 1,
    $forwardenergytype = 1,
    $framesize = 2048,
    $hopsize = 1024,
    $phasehandling = 2,
    $regularization = 0.01,
    $wintype = "sqrthann" "sqrthann" -> (
        [
            [ "fx" "timesquash" ]
            [ "params"
                [ "duration" $duration ]
                [ "mode" $mode ]
                [ "timeblock" $timeblock ]
                [ "xfade" $xfade ]
                [ "xfadecurve" $xfadecurve ]
                [ "xfadetype" $xfadetype ]
                [ "glbleed" $glbleed ]
                [ "glnumiter" $glnumiter ]
                [ "glrandomize" $glrandomize ]
                [ "glrect" $glrect ]
                [ "batchsize" $batchsize ]
                [ "energy" $energy ]
                [ "forwardenergy" $forwardenergy ]
                [ "forwardenergyembed" $forwardenergyembed ]
                [ "forwardenergytype" $forwardenergytype ]
                [ "batchinterrupt" $batchinterrupt ]
                [ "phasehandling" $phasehandling ]
                [ "regularization" $regularization ]
                [ "hopsize" $hopsize ]
                [ "framesize" $framesize ]
                [ "wintype" $wintype ]
                [ "timeunit" $timeunit ]
            ]
        ]
    )
);

$addref(
    @name "timesquash",
    @description "Audio process command for applying timesquash time compression to a buffer. This removes time from a sample by shifting portions of the spectrogram while preserving the relevant content. See #process.",
    @arguments (
        $addarg(@name "duration", @default 1, @type "int/float", @description "target duration, based on @timeunit.")
        $addarg(@name "timeunit", @default 2, @type "int", @description "time unit for @duration."
            GS_REF_TIMEUNIT_OPTIONS
        )
        $addarg(@name "timeblock", @default 4096, @type "int", @description "duration of each time block to be removed.")
        $addarg(@name "mode", @default 1, @type "int", @description "working mode." @options 
            GS_REF_AUDIO_DOMAIN_OPTIONS
        )
        $addarg(@name "xfade", @default 4096, @type "int/float", @description "duration of the crossfade, in samples.")
        $addarg(@name "xfadecurve", @default 0, @type "int/float", @description "curve parameter for the crossfade.")
        $addarg(@name "xfadetype", @default 2, @type "int", @description "cross fade type.." @options 
            $addopt(@value 0, @description "none")
            $addopt(@value 1, @description "linear")
            $addopt(@value 2, @description "sine")
            $addopt(@value 3, @description "curve")
            $addopt(@value 4, @description "s-curve")
        )
        $addarg(@name "glbleed", @default 4, @type "int", @description "number of frames of invalidation for the Griffin-Lim algorithm, when @phasehandling is 2.")
        $addarg(@name "glnumiter", @default 10, @type "int", @description "number of Griffin-Lim iterations, when @phasehandling is 2.")
        $addarg(@name "glrandomize", @default 0, @type "int", @description "randomize the phases of the regions subject to the Griffin-Lim algorithm, when @phasehandling is 2." @options
            GS_REF_SWITCH_OPTIONS
        )
        $addarg(@name "glrect", @default 1, @type "int", @description "invalidate whole rectangular regions whose phases are recomputed via the Griffin-Lim algorithm, when @phasehandling is 2." @options 
            GS_REF_SWITCH_OPTIONS
        )
        $addarg(@name "batchsize", @default 1, @type "int", @description "number of seams processed in batch.")
        $addarg(@name "batchinterrupt", @default 0, @type "int", @description "interrupt batch when crossing.")
        $addarg(@name "energy", @default 2, @type "int", @description "energy function used for computing seams." @options
            $addopt(@value 0, @description "magnitude")
            $addopt(@value 1, @description "gradient magnitude")
            $addopt(@value 2, @description "Sobel")
        )
        $addarg(@name "forwardenergy", @default "1.", @type "int/float", @description "amount of forward energy contribution.")
        $addarg(@name "forwardenergyembed", @default 1, @type "int", @description "embed forward energy in cumulative matrix." @options
            GS_REF_SWITCH_OPTIONS
        )
        $addarg(@name "forwardenergytype", @default 1, @type "int", @description "forward energy type." @options
            $addopt(@value 0, @description "gradient L1 norm")
            $addopt(@value 1, @description "energy L2 norm")
        )
        $addarg(@name "framesize", @default 2048, @type "int", @description "window size, in samples")
        $addarg(@name "hopsize", @default 1024, @type "int", @description "hop size, in samples")
        $addarg(@name "phasehandling", @default 2, @type "int", @description "phase handling mode." @options
            $addopt(@value 0, @description "keep")
            $addopt(@value 1, @description "compensate")
            $addopt(@value 2, @description "Griffin-Lim")
        )
        $addarg(@name "regularization", @default 0.01, @type "int/float", @description "how much energy of a bin smears on the ones above and below, between 0 and 1.")
        $addarg(@name "wintype", @default "'sqrthann'" "'sqrthann'", @type "list/sym", @description "window type." @options GS_REF_WINDOW_OPTIONS)
    ),
    @output $addout(@description "timesquash command" @type "llll")
);

## ------------------------------------------------------------

resample = (
    $duration = 1,
    $timeunit = 2,
    $changesr = 0,
    $antimeunit = 1,
    $resamplingmode = "sinc",
    $resamplingfiltersize = 11 -> (
        [
            [ "fx" "resample" ]
            [ "params"
                [ "duration" $duration ]
                [ "timeunit" $timeunit ]
                [ "changesr" $changesr ]
                [ "antimeunit" $antimeunit ]
                [ "resamplingmode" $resamplingmode ]
                [ "resamplingfiltersize" $resamplingfiltersize ]
            ]
        ]
    )
);

$addref(
    @name "resample",
    @description "Audio process command for applying stretching/pitch shifting a buffer via resampling. See #process.",
    @arguments (
        $addarg(@name "duration", @default 1, @type "int/float", @description "target duration, based on @timeunit.")
        $addarg(@name "timeunit", @default 2, @type "int", @description "time unit for @duration." @options 
            GS_REF_TIMEUNIT_OPTIONS
        )
        $addarg(@name "changesr", @default 0, @type "int", @description "change sampling rate." @options
            GS_REF_SWITCH_OPTIONS
        )
        $addarg(@name "antimeunit", @default 1, @type "int", @description "time unit for analysis." @options 
            GS_REF_TIMEUNIT_OPTIONS
        )
        $addarg(@name "resamplingmode", @default "sinc", @type "symbol", @description "resampling mode." @options
            GS_REF_RESAMPLINGMODE_OPTIONS
        )
        $addarg(@name "resamplingfiltersize", @default 11, @type "int", @description "resampling filter size.")
    ),
    @output $addout(@description "resample command" @type "llll")
);

## ------------------------------------------------------------

normalize = (
    $level = 1,
    $mix = 1,
    $rms = 0,
    $ampunit = 1 -> (
        [
            [ "fx" "normalize" ]
            [ "params"
                [ "level" $level ]
                [ "mix" $mix ]
                [ "rms" $rms ]
                [ "ampunit" $ampunit ]
            ]
        ]
    )
);

$addref(
    @name "normalize",
    @description "Audio process command for normalizing the amplitude of a buffer. See #process.",
    @arguments (
        $addarg(@name "level", @default 1, @type "int/float", @description "reference level.")
        $addarg(@name "mix", @default 1, @type "int", @description "dry/wet mix, between 0 and 1.")
        $addarg(@name "rms", @default 0, @type "int", @description "use root mean square." @options
            GS_REF_SWITCH_OPTIONS
        )
        $addarg(@name "ampunit", @default 1, @type "int", @description "amplitude unit for @level." @options
            GS_REF_AMPUNIT_OPTIONS
        )
    ),
    @output $addout(@description "normalize command" @type "llll")
);

## ------------------------------------------------------------

gain = (
    $gain,
    $resamplingfiltersize = 11,
    $resamplingmode = 'sinc',
    $ampunit = 0,
    $envampunit = 0,
    $envtimeunit = 2 -> (
        if $gain == null then (
            printerror("you must provide a @gain value in gain().")
        );
        $gain = if depth($gain) > 1 || length($gain) > 1 then [ bpf($gain) ] else $gain;
        [
            [ "fx" "gain" ]
            [ "params"
                [ "gain" $gain ]
                [ "resamplingfiltersize" $resamplingfiltersize ]
                [ "resamplingmode" $resamplingmode ]
                [ "ampunit" $ampunit ]
                [ "envampunit" $envampunit ]
                [ "envtimeunit" $envtimeunit ]
            ]
        ]
    )
);

$addref(
    @name "gain",
    @description "Audio process command for modifying a buffer's gain. See #process.",
    @arguments (
        $addarg(@name "gain", @type "int/float/llll", @description "gain amount, as either a single number or envelope.")
        $addarg(@name "resamplingfiltersize", @default 11, @type "int", @description "resampling filter size, in samples.")
        $addarg(@name "resamplingmode", @default "sinc", @type "symbol", @description "resampling mode." @options
            GS_REF_RESAMPLINGMODE_OPTIONS
        )
        $addarg(@name "ampunit", @default 0, @type "int", @description "amplitude unit." @options
            GS_REF_AMPUNIT_OPTIONS
        )
        $addarg(@name "envampunit", @default 0, @type "int", @description "amplitude unit for @gain envelope." @options
            GS_REF_AMPUNIT_OPTIONS
        )
        $addarg(@name "envtimeunit", @default 2, @type "int", @description "time unit for @gain envelope." @options
            GS_REF_TIMEUNIT_OPTIONS
        )
    ),
    @output $addout(@description "gain command" @type "llll")
);

## ------------------------------------------------------------

dynamics = (
    $attack = 10,
    $release = 50,
    $knee = 0.7,
    $makeup = 0,
    $ratio = 1.5,
    $thresh = -20.,
    $ampunit = 1,
    $timeunit = 0 -> (
        [
            [ "fx" "dynamics" ]
            [ "params"
                [ "attack" $attack ]
                [ "release" $release ]
                [ "knee" $knee ]
                [ "makeup" $makeup ]
                [ "ratio" $ratio ]
                [ "thresh" $thresh ]
                [ "ampunit" $ampunit ]
                [ "timeunit" $timeunit ]
            ]
        ]
    )
);

$addref(
    @name "dynamics",
    @description "Audio process command for applying simple compression to a buffer. See #process.",
    @arguments (
        $addarg(@name "attack", @default 10, @type "int/float", @description "attack time.")
        $addarg(@name "release", @default 50, @type "int/float", @description "release time.")
        $addarg(@name "knee", @default "0.7", @type "int/float", @description "knee width.")
        $addarg(@name "makeup", @default 0, @type "int/float", @description "make-up gain.")
        $addarg(@name "ratio", @default "1.5", @type "int/float", @description "compression ratio.")
        $addarg(@name "thresh", @default -20, @type "int/float", @description "amplitude threshold.")
        $addarg(@name "ampunit", @default 1, @type "int", @description "amplitude unit." @options
            GS_REF_AMPUNIT_OPTIONS
        )
        $addarg(@name "timeunit", @default 0, @type "int", @description "time unit." @options
            GS_REF_TIMEUNIT_OPTIONS
        )
    ),
    @output $addout(@description "dynamics command" @type "llll")
);

## ------------------------------------------------------------

resynth = (
    $func,
    $frequnit = 2,
    $maxnsines = 100,
    $maxpeaks = 100,
    $magnitudethreshold = .0002,
    $framesize = 2048,
    $hopsize = 512,
    $minfrequency = 0,
    $maxfrequency = 22050,
    $wintype = "hann",
    $stochastic = 0,
    $stocf = 0.2 -> (
        if $func == null then (
            printerror("you must provide a lambda function to the @func argument in resynth()")
        );
        GS_RESYNTH_FUNC = $func ||| ($x, $y, $z, $w -> [$x] [$y] [$z] [$w]);
        [
            [ "fx" "resynth" ]
            [ "params"
                [ "stochastic" $stochastic ]
                [ "frequnit" $frequnit ]
                [ "maxnsines" $maxnsines ]
                [ "maxpeaks" $maxpeaks ]
                [ "magnitudethreshold" $magnitudethreshold ]
                [ "framesize" $framesize ]
                [ "hopsize" $hopsize ]
                [ "minfrequency" $minfrequency ]
                [ "maxfrequency" $maxfrequency ]
                (if $stochastic == 0 then [ "wintype" $wintype ])
                (if $stochastic == 1 then [ "stocf" $stocf ])
            ]
        ]
    )
);

$addref(
    @name "resynth",
    @description "Audio process command for applying partial tracking analysis/resynthesis to a buffer. See #process.",
    @arguments (
        $addarg(@name "func", @type "function", @description "pitch/frequency lambda function, with signature $oldpartials -> $newpartials.")
        $addarg(@name "frequnit", @default 2, @type "int", @description "unit for frequency components in @func." @options 
            $addopt(@value 0 @description "Hertz")
            $addopt(@value 1 @description "BPM")
            $addopt(@value 2 @description "midicents")
            $addopt(@value 3 @description "MIDI")
        )
        $addarg(@name "maxnsines", @default 100, @type "int", @description "max. number of sines per frame.")
        $addarg(@name "maxpeaks", @default 100, @type "int", @description "max. number of returned peaks.")
        $addarg(@name "magnitudethreshold", @default "0.0002", @type "float", @description "peak amplitude threshold.")
        $addarg(@name "framesize", @default 2048, @type "int", @description "window size, in samples")
        $addarg(@name "hopsize", @default 512, @type "int", @description "hop size, in samples")
        $addarg(@name "minfrequency", @default 0, @type "int/float", @description "min. frequency of the range to evaluate")
        $addarg(@name "maxfrequency", @default 22050, @type "int/float", @description "max. frequency of the range to evaluate")
        $addarg(@name "wintype", @default "'hann'", @type "sym/int", @description "window type. For instance, 'hann', 'sine', 'triangular', etc")
        $addarg(@name "stochastic", @default 0, @type "int", @description "analysis/resynthesis mode." @options
            $addopt(@value 0 @description "sinusoidal")
            $addopt(@value 1 @description "stochastic + sinusoidal")
        )
        $addarg(@name "stocf", @default '0.2', @type "int/float", @description "decimation factor of stochastic approximation. Ignored if @stochastic is 0.")
    ),
    @output $addout(@description "resynth command" @type "llll")
);

## ------------------------------------------------------------

buildtree = (
    $grains, $keys = "mfcc" -> (
        if $keys == null then (
            printerror("you must provide a one or more features to the @keys argument in buildtree()")
        );
        msg("kdtree", [ "features" $keys] ["grains" $grains])
    )
);

$addref(
    @name "buildtree",
    @description "Builds a k-dimensional tree on a set of grains, given one or more grain features. This tree can be queried via the #searchtree function. Note that there can only be one tree at a time.",
    @arguments (
        $addarg(@name "grains", @type "llll", @description "list of grains.")
        $addarg(@name "keys", @default "mfcc", @type "list/sym", @description "features to build tree on.")
    )
);

## ------------------------------------------------------------

searchtree = (
    $target -> (
        msg("kdtree", [ "query" $target]);
        GS_TREE_RESULT
    )
);

$addref(
    @name "searchtree",
    @description "k-nearest neighbor search on the current k-dimensional tree. The search input can be either a single grain or, more directly, the values associated with the features the tree was based on. See #buildtree.",
    @arguments (
        $addarg(@name "target", @type "llll", @description "target grain or feature value to find nearest neighbor for.")
    ),
    @output $addout(@description "nearest grain" @type "llll")
);

## ------------------------------------------------------------

null