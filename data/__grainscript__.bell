GS_GRAINS = null;
GS_REF = null;
GS_VERSION = "v0.0.0-beta";
PI = 3.14159265359;

## ------------------------------------------------------------

$addref = (
    $name, $description, $arguments, $output -> (
        GS_REF _= [
            $name
            [ "description:" $description ] 
            [ "arguments:" ($arguments ||| "none") ] 
            [ "output:" ($output ||| "null") ]
        ]
    )
);

## ------------------------------------------------------------

$addarg = (
    $name, $description, $type = "list", $default = null -> (
        [
            "@" + $name 
            [ "description:" $description ]
            [ "type:" $type ]
            (if $default != null then [ "default:" $default ])
        ]
    )
);

## ------------------------------------------------------------

$addout = (
    $description, $type -> [ "description:" $description ] [ "type:" $type ]
);

## ------------------------------------------------------------

msg = (
    $to, $msg -> (
        $do1 = [ $to $msg ]
    )
);

## ------------------------------------------------------------

pcdiff = (
	$a, $b, $mod = 12 -> ( 
		$a = fmod($a, $mod); 
		$b = fmod($b, $mod); 
		$da = $b - $a; 
		$db = $da + $mod * -(sgn($da) || 1); 
		$mask = for $xa in $da, $xb in $db collect int(abs($xa) < abs($xb)); 
		$da * $mask + $db * (1 - $mask)) 
);

$addref(
    @name "pcdiff",
    @description "Signed pitch class difference.",
    @arguments (
        $addarg(@name "a",  @type "int/float/list",@description "pitch classes.")
        $addarg(@name "b", @type "int/float/list",@description "pitch classes.")
    ),
    @output $addout(@description "signed difference", @type "int/float/list")
);

## ------------------------------------------------------------

setcorpus = (
    $filepath -> (
        GS_GRAINS = null;
        msg("db", "read" $filepath)
    )
);

$addref(
    @name "setcorpus",
    @description "Loads an audio corpus, given an absolute path to a .llll file. See #query function.",
    @arguments (
        $addarg(@name "filepath", @type "symbol", @description "file path to .llll corpus file.")
    )
);

## ------------------------------------------------------------

samplelist = (
    $x, $i -> (
        $N = length($x);
        $i = scale($i, 0, 1, 1, $N);
        $l = floor($i);
        $r = min($l + 1, $N);
        $m = fmod($i, 1);
        $x:$l * (1 - $m) + $x:$r * $m
    )
);

$addref(
    @name "samplelist",
    @description "Samples an interpolated value from a numeric list given a normalized index.",
    @arguments (
        $addarg(@name "x", @type "list", @description "list to sample from.")
    ),
    @output $addout(@description "interpolated sample", @type "int/float/list")
);

## ------------------------------------------------------------

query = (
    $x = "SELECT * FROM grains" -> (
        msg("db", "query" $x);
        GS_GRAINS
    )
);

$addref(
    @name "query",
    @description "Executes an sqlite3 query on the current audio corpus, and returns the results. Every query should use 'grains' as the table name. For instance: 'SELECT * FROM grains'. See #setcorpus.",
    @arguments (
        $addarg(@name "query", @type "symbol", @default "'SELECT * FROM grains'", @description "sqlite3 query.")
    ),
    @output $addout(@description "list of grains", @type "llll")
);

## ------------------------------------------------------------

getkey = (
    $grain, $key -> ($grain::1).$key
);

$addref(
    @name "getkey",
    @description "Returns value associated with a grain's key.",
    @arguments (
        $addarg(@name "grain", @type "llll", @description "grain.")
        $addarg(@name "key", @type "symbol", @description "name of grain key.")
    ),
    @output $addout(@description "value associated with key", @type "anything")
);

## ------------------------------------------------------------

setkey = ($grain, $key, $val -> [ ($grain::1).$key = $val ]);

$addref(
    @name "setkey",
    @description "Modifies the key of a grain.",
    @arguments (
        $addarg(@name "grain", @type "llll", @description "grain to modify.")
        $addarg(@name "key", @type "symbol", @description "name of grain key.")
        $addarg(@name "val", @type "anything", @description "new value for grain key.")
    ),
    @output $addout(@description "modified grain", @type "llll")
);

## ------------------------------------------------------------

mapkey = (
    $grain, $key, $func -> (
        setkey($grain, $key, $func(getkey($grain, $key)))
    )
);

$addref(
    @name "mapkey",
    @description "Modifies the key of a grain via a lambda function.",
    @arguments (
        $addarg(@name "grain", @type "llll", @description "grain to modify.")
        $addarg(@name "key", @type "symbol", @description "name of grain key.")
        $addarg(@name "func", @type "lambda function", @description "lambda function with signature $currentvalue -> $newvalue.")
    ),
    @output $addout(@description "modified grain", @type "llll")
);

## ------------------------------------------------------------

bpf = (
    $pts, $func = null -> (
        $depth = depth($pts);
        $size = length($pts);
        if $depth == 1 then (
            for $p $i in $pts collect [ ($i - 1.) / max(1, $size - 1.) (if $func then $func($p) else $p) 0. ]
        ) else if $depth == 2 then (
            $cols = trans($pts);
            $dims = length($cols);
            $norm = maximum(($cols::1) ||| 1.);
            $x = [sort(float($cols::1) / if $norm != 0 then $norm else 1.)];
            $y = [ if $func then $func($cols::2) else $cols::2 ];
            $curve = [for $i in 1...$size collect ($pts::($i 3)) ||| 0];
            trans($x $y $curve)
        )
    )
);

$addref(
    @name "bpf",
    @description "Formats an numeric list into a breaking point function, in the form of [<x> <y> <curve>] tuples, where <x> is normalized to the 0-1 range.",
    @arguments (
        $addarg(@name "pts", @type "list", @description "numeric list")
        $addarg(@name "func", @type "function", @description "optional mapping function for y axis")
    ),
    @output $addout(@description "breaking point function", @type "llll")
);

## ------------------------------------------------------------

scale = (
    $x, $inmin = 0, $inmax = 1, $outmin = 0, $outmax = 1 -> (
        (($x - $inmin) / ($inmax - $inmin)) * ($outmax - $outmin) + $outmin
    )
);

$addref(
    @name "scale",
    @description "Scales an input value or list from a given range to another.",
    @arguments (
        $addarg(@name "x", @type "int/float/list", @description "value to scale.")
        $addarg(@name "inmin", @type "int/float", @default 0, @description "input minimum value.")
        $addarg(@name "inmax", @type "int/float", @default 1, @description "input maxiumum value.")
        $addarg(@name "outmin", @type "int/float", @default 0, @description "output minimum value.")
        $addarg(@name "outmax", @type "int/float", @default 1, @description "output maxiumum value.")
    ),
    @output $addout(@description "scaled input", @type "int/float/list/llll")
);

## ------------------------------------------------------------

rand = (
    $a = 1, $b = null, $res = 1000 -> (
        if $b == null then (
            $min = 0;
            $max = $a
        ) else (
            $min = $a;
            $max = $b
        );
        scale(random(0, $res), 0, $res, $min, $max)
    )
);

$addref(
    @name "rand",
    @description "Random floating point number generator.",
    @arguments (
        $addarg(@name "a", @type "int/float", @description "max. value if @b is null, else min. value.")
        $addarg(@name "b", @type "int/float", @description "min. value.")
        $addarg(@name "res", @type "int", @default 1000, @description "random value resolution.")
    ),
    @output $addout(@description "random floating point number", @type "int/float")
);

## ------------------------------------------------------------

choose = (
    $x, $n = 1 -> (
        for $i in 1...$n collect $x:(random(1, length($x)))
    )
);

$addref(
    @name "choose",
    @description "Choose randomly one or more elements from list.",
    @arguments (
        $addarg(@name "x", @type "list", @description "list to choose from.")
        $addarg(@name "n", @type "int", @description "number of random choices.")
    ),
    @output $addout(@description "random elements", @type "anything")
);

## ------------------------------------------------------------

c2r = (
    $cents -> 2 ** ($cents / 1200)
);

$addref(
    @name "c2r",
    @description "Cents to ratio conversion.",
    @arguments (
        $addarg(@name "cents", @type "list/int/float", @description "cents to convert.")
    ),
    @output $addout(@description "list of ratios", @type "int/float/list")
);

## ------------------------------------------------------------

r2c = (
    $r -> log2($r) * 1200
);

$addref(
    @name "r2c",
    @description "Ratio to cents conversion.",
    @arguments (
        $addarg(@name "ratios", @type "list/int/float", @description "ratios to convert.")
    ),
    @output $addout(@description "list of cents", @type "list/int/float")
);

## ------------------------------------------------------------

sortgrains = (
    $grains, $key -> (
        sort($grains, ($a, $b -^ $key -> (getkey($a, $key) < getkey($b, $key))))
    )
);

$addref(
    @name "sortgrains",
    @description "Sorts grains by a given key (grain_id, file_id, pitch, pitchclass, pitchsalience, duration, centroid, zerox, loudness, etc.)",
    @arguments (
        $addarg(@name "grains", @type "llll", @description "grains to sort.")
        $addarg(@name "key", @type "symbol", @description "grain key to sort by.")
    ),
    @output $addout(@description "list of sorted grains", @type "llll")
);

## ------------------------------------------------------------

filtergrains = (
    $grains, $func, $max = 0, $maxdepth = 1, $unwrap = 1 -> (
        $lambda = (
            $x  -^ $func -> (
                $func($x)
            )
        );
        finditems($grains, $max, $lambda, @maxdepth $maxdepth, @unwrap $unwrap)
    )
);

## ------------------------------------------------------------

detuning = (
    $grain, $targets -> (
        $source = getkey($grain, "pitch");
        $distances = (
            for $pitch in $targets collect (
                if $pitch < 12 then (
                    pcdiff($source / 100., $pitch) * 100
                ) else (
                    $pitch - $source
                )
            )
        );
        $distances:(minmax(abs($distances)):2)
    )
);

$addref(
    @name "detuning",
    @description "Given a list of target midicents and/or pitch classes, returns the difference between a grains' original pitch and the nearest midicent/pitch class target. See #addgrain function.",
    @arguments (
        $addarg(@name "grain", @type "llll", @description "reference grain.")
        $addarg(@name "targets", @type "int/float/list", @description "list of midicent or pitch class targets.")
    ),
    @output $addout(@description "pitch shifting amount in cents", @type "int/float")
);

## ------------------------------------------------------------

addgrain = (
    $grain, $onset = 0, $pan = null, $gain = null, $detune = null -> (
        ## unpack grain
        $grain = $grain::1;

        ## check for non-zero detuning
        $rate = [ 11 (if $detune && $detune != 0 then c2r($detune)) ];

        ## get pitch value and keep a copy
        $mc = $grain."pitch";
        $mccopy = $mc; 
        
        ## check if detuning is applied
        if $rate::(1 2) then (
            ## update pitch value based on detuning
            $mc += r2c($rate::(1 2))
        ) else (
            ## nullify unused slot for optimization
            $rate = null
        );
        ## color note based on detuning
        $color = [ 6 fmod(abs(($mccopy - $mc) / 1200) + .5, 1) ];

        ## clean gain and panning slots
        $pan = if $pan != null then [ 2 bpf($pan) ];
        $gain = if $gain != null then [ 1 bpf($gain, ($y -> max(1, $y * 127.))) ];

        ## get chord velocity and duration
        $vel = if $gain then maximum(trans($gain.1)::2) else min(127, $grain."loudness" * 512);
        $dur = $grain."duration";

        ## format note and add to roll
        $note = [ $mc $dur $vel ["slots" [ 7 $grain."file" ] [ 10 $grain."offset" ] $pan $rate $gain $color ]];
        msg("roll", "addchord" [ $onset $note ])
    )
);

$addref(
    @name "addgrain",
    @description "Adds a grain to the rendering queue. See #setcorpus, #query, and #render functions.",
    @arguments (
        $addarg(@name "grain", @type "llll", @description "grain to add to rendering queue.")
        $addarg(@name "onset", @type "int/float", @default 0, @description "grain onset in milliseconds.")
        $addarg(@name "pan", @type "int/float/list/llll", @description "normalized panning value or envelope.")
        $addarg(@name "gain", @type "int/float/llll", @description "gain value or envelope.")
        $addarg(@name "detune", @type "int/float", @description "detuning amount in cents.")
    )
);

## ------------------------------------------------------------

render = (
   $panmode = 0, $numchannels = 2, $sr = 48000, $normalize = 0, $play = 0, $fx = null -> (
        msg("sampler", 
            [ "panmode" $panmode] 
            [ "numchannels" $numchannels ] 
            [ "sr" $sr ]
            [ "normalize" $normalize ]
        );
        msg("roll", "dump");
        ($fx &&& msg("sampler", [ "process" $fx ] ));
        ($play == 1 && msg("playtoggle", 1))
    )
);

$addref(
    @name "render",
    @description "Triggers script rendering into an audio buffer. See #addgrain function.",
    @arguments (
        $addarg(@name "panmode", @type "int", @default 0, @description "panning mode. 0: linear panning; 1: circular panning.")
        $addarg(@name "numchannels", @type "int", @default 2, @description "number of output channels.")
        $addarg(@name "sr", @type "int", @default 48000, @description "sampling rate.")
        $addarg(@name "normalize", @type "int", @default 0, @description "audio normalization.")
        $addarg(@name "play", @type "int", @default 0, @description "autoplay rendered buffer.")
    )
);

## ------------------------------------------------------------

export = (
    $path -> (
        msg("export", $path)
    )
);

$addref(
    @name "export",
    @description "Exports the rendered output as either a .wav, .mid/midi. or .llll file, given a output path. See #render function.",
    @arguments (
        $addarg(@name "path", @type "symbol", @description "output file path.")
    )
);

## ------------------------------------------------------------

hanning = ($N = 16 -> ($N -= 1; sin((PI * (0...$N)) / $N) ** 2.));

$addref(
    @name "hanning",
    @description "Generates a hanning window.",
    @arguments (
        $addarg(@name "N", @type "int", @default 16, @description "window resolution.")
    ),
    @output $addout(@description "hanning window" @type "list")
);

## ------------------------------------------------------------

#( 
    adapted from emmanuel jourdan: https://cycling74.com/forums/math-behind-function-curve
    NOTE: this is implementation is different from both bach's (closest) and Max.
)#

interpolate = (
    $x, $a, $b, $curve = 0 -> (
        $ca = 1.2;
        $cb = .41;
        $cc = .91;
        $m = 1e-20;
        $xrange = $b:1 - $a:1;
        $yrange = $b:2 - $a:2;
        if abs($curve) < .001 then (
            (($x - $a:1) / $xrange) * $yrange + $a:2
        ) else (
            if $curve < 0 then (
                $gx = ($b:1 - $x) / $xrange;
                $hp = (($m - $curve) * $ca) ** $cb * $cc;
                $fp = $hp / (1.0 - $hp);
                $gp = (exp($fp * $gx) - 1.) / (exp($fp) - 1.0);
                $b:2 - $gp * $yrange
            ) else (
                $gx = ($x - $a:1) / $xrange;
                $hp = (($curve + $m) * $ca)  ** $cb * $cc;
                $fp = $hp / (1.0 - $hp);
                $gp = (exp($fp * $gx) - 1.) / (exp($fp) - 1.0);
                $gp * $yrange + $a:2
            )
        )
    )
);

$addref(
    @name "interpolate",
    @description "Curve interpolation between two points.",
    @arguments (
        $addarg(@name "x", @type "int/float/list", @description "interpolation point")
        $addarg(@name "a", @type "list", @description "xy coordinates for point A")
        $addarg(@name "b", @type "list", @description "xy coordinates for point B")
        $addarg(@name "curve", @type "list", @default 0, @description "curvature between the two points, in the -1 to 1 range")
    ),
    @output $addout(@description "interpolated values" @type "int/float/list")
);

## ------------------------------------------------------------

samplebpf = (
    $bpf, $pts -> (
        $cols = trans($bpf);
        $xvals = $cols::1;
        $yvals = $cols::2;
        $cvals = $cols::3;
        $N = length($bpf);
        for $pt in $pts collect (
            $xdiffs = $xvals - $pt;
            $i = 1;
            $pos = null;
            while $i <= $N do (
                $dx = $xdiffs:$i;
                if $dx >= 0 then (
                    $pos = max(1, $i - 1);
                    $i = $N + 1
                ) else (
                    $i += 1
                )
            );
            $a = left(($bpf:$pos)::1, 2);
            $b = ($bpf:(min($pos + 1, $N)))::1;
            $curve = $b:3;
            $b = left($b, 2);
            interpolate($pt, $a, $b, $curve)
        )
    )
);

$addref(
    @name "samplebpf",
    @description "Samples an interpolated value from a breaking point function, given a list of normalized indices. See #bpf function.",
    @arguments (
        $addarg(@name "bpf", @type "llll", @description "breaking point function")
        $addarg(@name "pts", @type "int/float/list", @description "sampling point/s")
    ),
    @output $addout(@description "interpolated bpf values" @type "int/float/list")
);

## ------------------------------------------------------------

processgrain = (
    $grain, $fx -> (
        $offset = $grain.getkey("offset");
        msg(
            "process",
            [ "source" $grain.getkey("file") ]
            [ "process" 
                [
                    ["fx" "crop"]
                    ["params" 
                        ["start" $offset ]
                        ["end" $offset + $grain.getkey("duration") ]
                    ]
                ]
                $fx 
            ]
        );
        [ GS_TMP_GRAIN ]
    )
);

## ------------------------------------------------------------

fxrev = (
    -> [
        ["fx" "reverse"]
    ]
);

## ------------------------------------------------------------

fxfreeverb = (
    $roomsize = .5,
    $damp = .5,
    $width = 1.,
    $tail = -1,
    $dry = 1., 
    $wet = 1/3. -> (
        [
            ["fx" "freeverb"]
            [ "params" 
                [ "roomsize" $roomsize ]
                [ "damp" $damp ]
                [ "width" $width ]
                [ "tail" $tail ]
                [ "dry" if depth($dry) > 1 then [$dry] else $dry ]
                [ "wet" if depth($wet) > 1 then [$wet] else $wet ]
            ]
        ]
    )
);

## ------------------------------------------------------------

fxpaulstretch = (
    $factor -> (
        $factor = if depth($factor) > 1 then [$factor] else $factor;
        [
            [ "fx" "paulstretch" ]
            [ "params" [$factor ||| 1 ] ]
        ]
    )
);

## ------------------------------------------------------------

null