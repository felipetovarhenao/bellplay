BP_VERSION = "v0.2.8-beta";
BP_SUPPORTED_AUDIO_FORMATS = ".wav" ".aif" ".aiff" ".mp3";
BP_DATABASE_OUTPUT = null;
BP_TREE_NORM = null;
BP_REF_LABEL_UTILS = "utilities";
BP_REF_LABEL_PROCESS = "audio processing";
BP_REF_LABEL_GEN = "audio generation";
BP_REF_LABEL_ANALYSIS = "audio analysis";
BP_REF = (for $i in BP_REF_LABEL_UTILS BP_REF_LABEL_PROCESS BP_REF_LABEL_GEN BP_REF_LABEL_ANALYSIS collect [ $i ]);
BP_REF_TIMEUNIT_OPTIONS = null;
BP_REF_AUDIO_DOMAIN_OPTIONS = null;
BP_TMP_BUFF = null;
BP_TMP_BUFFINFO = null;
BP_TMP_ROLL_OUTPUT = null;
BP_INF = 1./0;
BP_RAND_RES = 2147483648;
BP_URN = null;
BP_SCRIPT_PATH = null;
BP_DEFAULT_EZSAMPLER_KEYMAP = [6000 'guitar.wav' ];
BP_BUFFER_CACHE = null;
BP_PLAY_TOGGLE = 0;
BP_SCORE_CONFIG = null;
BP_CONFIG = null;
BP_MAXOBJ_RANDOM = {max.random 2147483648 @seed 1};
BP_MAXOBJ_ATOI = {max.atoi};
BP_MAXOBJ_ITOA = {max.itoa};
BP_MAXOBJ_BACHINTEGRATE = {bach.integrate};
BP_MAXOBJ_BACHDERIVE = {bach.derive};
BP_FN_CONFIG = (
    $action, $value -> (
        $bpconfigpath = '~/bellplay.config.txt';
        $exists = exists($bpconfigpath);
        $update = $conf -^ $bpconfigpath -> (
            BP_CONFIG = $conf;
            write(@data $conf @path $bpconfigpath) 
        );
        if $action == 'init' then (
            $defaultconfig = (
                ## bellplay~ version
                [ 'version' BP_VERSION] 
                ## files to automatically run at launch
                [ 'imports' ] 
                ## default text editor
                [ 'defaulteditor' ] 
                ## default tutorials directory
                [
                    'tutorialsdir' '~/Documents' 
                ] 
                ## mute sound alert when getting errors
                [ 'mutealert' 0] 
            );
            if $exists == 0 then ($bpconfig = $defaultconfig) else (
                $bpconfig = read(@path $bpconfigpath);
                $defaultkeys = trans($defaultconfig)::1;
                for $key in $defaultkeys do (
                    $val = $bpconfig.$key;
                    if $val == null then ($bpconfig.$key = $defaultconfig.$key) 
                );
                $bpconfig.'version' = BP_VERSION
            );
            $update($bpconfig) 
        ) else if $exists == 1 then (
            $bpconfig = read($bpconfigpath);
            if $action == 'map' then (
                $bpconfig = $value($bpconfig);
                if $bpconfig != null then $update($bpconfig) 
            ) else if $action == 'read' then (
                $imports = $bpconfig.'imports';
                if $imports != null then (
                    $imports = for $import in $imports collect (
                        $importpath = parsepath($import);
                        $ext = getkey($importpath, 'extension');
                        if $ext == '.bell' && exists($import) == 1 then (
                            BP_FN_DISPATCH('loadscript', $import);
                            $import
                        ) else BP_FN_WARNING(@details 'invalid import file:' $import ||| 'null') 
                    );
                    $bpconfig.'imports' = $imports;
                    $update($bpconfig) 
                ) 
            ) else if $action == 'get' then ($bpconfig.$value) 
        ) else BP_FN_WARNING(@details 'configuration file not found.') 
    ) 
);
BP_FN_ON_LAUNCH = (
    -> (
        ## load imports
        BP_FN_CONFIG('init')
    ) 
);
BP_FN_ON_BEFORE = (
    -> (
        BP_FN_SANDBOX_CLEAR();
        setseed(1); 
        scoreconfig();
        BP_URN = null; 
        BP_BUFFER_INSPECTOR = null;
        BP_BUFFER_CACHE = null;
        BP_PLAY_TOGGLE = 0
    )
);
BP_FN_ON_AFTER = (
    -> (
        if BP_SCORE_CONFIG."showdynamics" == 1 then (
            BP_FN_DISPATCH("roll", 
                 "velocities2dynamics" "@unnecessary" 1 "@thresh" 1. "@maxchars" 3
            );
            BP_FN_DISPATCH("roll", 
                 "fixdynamics" "@inconsistent" 1 "@unnecessary" 1 
            )
        );
        BP_PLAY_TOGGLE == 1 && BP_FN_DISPATCH("playtoggle", BP_PLAY_TOGGLE)
    )
);

BP_FN_ERROR = (
    $origin,
    $details,
    $stop = 1 -> (
        BP_FN_DISPATCH("console",
            [ "code" $stop == 0 ]
            [ "type" 2 - $stop ]
            [ "text" ($origin &&& ($origin "→")) $details ]
        );
        null
    )
);

BP_FN_WARNING = (
    $origin,
    $details -> (
        BP_FN_ERROR(@origin $origin @details $details @stop 0)
    )
);

BP_FN_CHECK_ARGS = (
    $origin, <...> -> (
        $missing = null;
        for $i in (1...($argcount / 2)) * 2 do (
            if $args($i + 1) == null then ($missing _= $args($i)) 
        );
        if $missing == null then 1 else (
            $details = for $m in $missing collect '@' + $m;
            BP_FN_ERROR($origin, 'unexpected null value:' $details) 
        ) 
    ) 
);

BP_FN_VALIDATE_BUFFER = (
    $origin,
    $buffer -> (
        $source = getkey($buffer, "source");
        $source ||| BP_FN_ERROR($origin, 'invalid buffer:' $buffer)
    )
);

## ------------------------------------------------------------

BP_REF_NEW = (
    $name, $description, $arguments, $output, $category = BP_REF_LABEL_UTILS, $anmodes = 0...3, $ankeys = null -> (
        ## check if reference belongs to analysis/descriptor function
        if $category == BP_REF_LABEL_ANALYSIS then (
            ## check if descriptor supports multiple modes
            $mode = $arguments."@mode";
            if $mode != null then (
                ## if so, filter out unsupported modes
                $mode."options:" = for $i in $anmodes collect ($mode."options:"):($i + 1)
            );
            ## re-assign modified arguments
            $arguments."@mode" = $mode
        );
        ## if function has arguments, split required from optional ones.
        if $arguments != null then (
            $required = null;
            $optional = null;
            for $arg in $arguments do if ($arg::1)."default:" == null then (
                $required _= $arg 
            ) else (
                $optional _= $arg
            );
            $arguments = ($required &&& [ "required:" $required ]) ($optional &&& [ "optional:" $optional ])
        );

        BP_REF.$category _= [
            $name
            [ "description:" $description ] 
            [ "arguments:" ($arguments ||| "none") ] 
            (
                ## if function is a descriptor, show name of analysis keys
                if $category == BP_REF_LABEL_ANALYSIS then (
                    $ankeys = $ankeys ||| $name;
                    $ankeys = for $k in $ankeys collect [ "'" + $k + "'" ];
                    [ "resulting buffer keys:" $ankeys ]
                )
            )
            [ "output:" ($output ||| "null") ]
        ]
    )
);

## ------------------------------------------------------------

BP_REF_ARG = (
    $name, $description, $type = "list", $default = null, $options = null -> (
        [
            "@" + $name + (if $default == null then " ?" else "")
            [ "description:" $description ]
            [ "type:" $type ]
            ($default &&& [ "default:" $default ])
            ($options &&& [ "options:" $options ])
        ]
    )
);

BP_REF_OPT = (
    $value, $description -> (
        [ (if $description then (tosymbol($value) + ":") else $value) $description ]
    )
);

BP_REF_OUTPUT = (
    $description, $type -> [ "description:" $description ] [ "type:" $type ]
);

## ------------------------------------------------------------

BP_FN_DISPATCH = (
    $to, $msg -> (
        $do1 = [ $to $msg ];
        null
    )
);

## ------------------------------------------------------------

BP_FN_PATHINFO = (
    $x,
    $locate = 0 -> (
        BP_FN_DISPATCH("pathinfo", $x);
        if BP_PATH_INFO == null then (
            BP_FN_ERROR(@details "invalid path:" $x) 
        ) else if $locate == 1 && BP_PATH_INFO."extension" != null && BP_PATH_INFO."exists" == 0 then (
            BP_FN_ERROR(@details "file not found:" $x)
        );
        BP_PATH_INFO
    )
);

## ------------------------------------------------------------

parsepath = (
    $path -> (
        $info = BP_FN_PATHINFO($path);
        [for $key in "name" "parent" "extension" collect (
                $val = $info.$key;
                $val &&& [ $key $val ]
            )
        ]
    )
);

BP_REF_NEW(
    @name "parsepath",
    @description "Parses a given path into key-value pairs for the following properties: 'name' (file or folder name), 'parent' (path of parent directory), and 'extension' (file extension, if not a folder). See #getkey.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "path" @type "symbol" @description "file or folder path.")
    )
    @output BP_REF_OUTPUT(@description "parsed path" @type "llll")
);

## ------------------------------------------------------------

thispath = (
    $parse = 0
    -> if $parse then BP_SCRIPT_PATH.parsepath() else BP_SCRIPT_PATH
);

BP_REF_NEW(
    @name "thispath",
    @description "Returns the path of the current script, as either a symbol or a parsed llll path. See #parsepath.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "parse" @default 0 @type "int" @description "parse path." @options 
            BP_REF_SWITCH_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "path to current script" @type "llll")
);

## ------------------------------------------------------------

exists = (
    $path -> (
        $info = BP_FN_PATHINFO($path);
        $info."exists"
    )
);

BP_REF_NEW(
    @name "exists"
    @description "Checks if a file or folder exists. Returns 1 if true or 0 if false."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "path" @type "symbol" @description "file or folder path.")
    )
    @output BP_REF_OUTPUT(@description "1 if true, 0 if false." @type "int")
);

## ------------------------------------------------------------

readfolder = (
    $path,
    $filetype = "audio" -> (
        $self = 'readfolder';
        BP_FN_CHECK_ARGS($self, 'path', $path);
        BP_TMP_FOLDER = null;
        $info = BP_FN_PATHINFO($path @locate 1);
        if $info."extension" != null then BP_FN_ERROR($self, "invalid folder path:" $path);
        $path = $info."path";
        $types = (
            [ "audio" "WAVE" "AIFF" "Mp3" ]
            [ "midi" "Midi" ]
            [ "text" "TEXT" ]
            [ "folder" "fold" ]
            [ "all" ]
        ).$filetype;
        if $filetype != "all" && $types == null then BP_FN_ERROR($self, "invalid file type:" $filetype);
        BP_FN_DISPATCH("folder",
            [ "types" $types ]
            [ $path ]
        );
        BP_TMP_FOLDER
    )
);

BP_REF_NEW(
    @name "readfolder",
    @description "Returns a list of file paths in specified folder directory.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "path" @type "symbol" @description "folder path.")
        BP_REF_ARG(@name "filetype" @default "'audio'" @type "symbol" @description "file type." @options
            BP_REF_OPT(@value "'audio'" @description "audio" "files")
            BP_REF_OPT(@value "'midi'" @description "midi" "files")
            BP_REF_OPT(@value "'text'" @description "text" "files")
            BP_REF_OPT(@value "'folder'" @description "folders")
            BP_REF_OPT(@value "'all'" @description "all" "folder" "contents")
        )
    )
    @output BP_REF_OUTPUT(@description "list of file paths", @type "list")
);

## ------------------------------------------------------------

BP_GET_BUFFER_INFO = (
    $buffer -> (
        BP_FN_DISPATCH("bufferinfo", $buffer);
        BP_TMP_BUFFINFO
    )
);

## ------------------------------------------------------------

interrupt = (
    $print = null -> (
        BP_FN_DISPATCH("console",
            [ "code" 0 ]
            [ "type" 2 ]
            ($print &&& [ "text" $print ])
        );
        null
    )
);

BP_REF_NEW(
    @name "interrupt",
    @description "Disables communication between the current script and the bellplay~ application, interrupting any remaining script operations.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "print" @default "null" @type "anything" @description "something to print.")
    )
);

## ------------------------------------------------------------

BP_MEDIA_FILES = [
    [ "audio"
        "badinerie.wav"
        "drums.wav"
        "poem.wav"
        "singing.wav"
        "trumpet.wav"
        "guitar.wav"
        "flute.wav"
        "viola.wav"
    ]
    [ "midi"
        "bach.mid"
        "satie.mid"
    ]
    [ "llll"
        "corpus_demo.llll"
    ]
];

## ------------------------------------------------------------

inspect = (
    $buffer, 
    $label = null -> (
        $self = 'inspect';
        BP_FN_CHECK_ARGS($self, 'buffer', $buffer);
        $source = BP_FN_VALIDATE_BUFFER($self, $buffer);
        BP_BUFFER_INSPECTOR _= [
            [ "label" $label ||| $source ]
            [ "data" left($buffer, 1) ]
        ];
        $buffer
    )
);

BP_REF_NEW(
    @name "inspect",
    @description "Adds input buffer to the buffer inspector window, which opens up once the script evaluation is over, displaying relevant buffer information — useful for debugging buffers.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "buffer" @type "llll" @description "media file type.")
        BP_REF_ARG(@name "label" @default "null" @type "symbol/null" @description "optional buffer inspector label.")
    )
    @output BP_REF_OUTPUT(@description "buffer", @type "llll")
);

## ------------------------------------------------------------

getmediafiles = (
    $type = null -> (
        if $type == null then (
            for $x in BP_MEDIA_FILES::1 collect right($x::1, 1)
        ) else BP_MEDIA_FILES.getkey($type)
    )
);

BP_REF_NEW(
    @name "getmediafiles",
    @description "Returns a list of built-in media files in bellplay~.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "type" @default "null" @type "symbol/null" @description "media file type" @options
            BP_REF_OPT(@value "null" @description "all" "files")
            BP_REF_OPT(@value "'audio'" @description "audio" "files")
            BP_REF_OPT(@value "'midi'" @description "midi" "files")
            BP_REF_OPT(@value "'llll'" @description "llll" "files")
        )
    ),
    @output BP_REF_OUTPUT(@description "list of media files", @type "list")
);

## ------------------------------------------------------------

BP_FN_NEWBUFF = (
    $source,
    $offset = 0,
    $info = 1,
    $pitch = 6000,
    $extras = null -> (
        $source ||| BP_FN_ERROR(@details "null buffer source encountered");
        $buffer = (
            [ "source" $source ]
            [ "sr" BP_SR ]
            [ "numchannels" 1 ]
            [ "max" 0. ]
            [ "min" 0. ]
            [ "maxabs" 0. ]
            [ "rms" 0. ]
            [ "duration" 50 ]
            [ "offset" $offset ]
            [ "pitch" $pitch ]
        );
        $info = if $info == 1 then BP_GET_BUFFER_INFO($source);
        $info _= [ "source_end" if $info then $info."duration" else $buffer."duration" ];
        $buffer = [$buffer];
        for $x in $info $extras do (
            $key = $x:(1 1);
            ($key &&& $buffer = setkey($buffer, $key, $x.$key @mode 1))
        );
        $buffer
    )
);

## ------------------------------------------------------------

tosymbol = (
    $x -> (
        BP_FN_DISPATCH("sym", $x);
        BP_SYMBOL
    )
);

BP_REF_NEW(
    @name "tosymbol",
    @description "Casts input value as a symbol.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "x",  @type "anything" @description "value to cast")
    ),
    @output BP_REF_OUTPUT(@description "symbol", @type "symbol")
);

## ------------------------------------------------------------

isnan = ($x -> tosymbol($x) == 'nan');

BP_REF_NEW(
    @name "isnan",
    @description "Checks if the input argument is strictly a nan — i.e., 'not a number' — value.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "x",  @type "anything" @description "value to check")
    ),
    @output BP_REF_OUTPUT(@description "0 if false, 1 if true.", @type "int")
);

## ------------------------------------------------------------

BP_REF_BUFFER_KEYS_OPTIONS = sort(for $x in BP_FN_NEWBUFF("dummy" @info 0)::1 collect BP_REF_OPT(@value "'" + $x::(1 1) + "'"));

BP_REF_TIMEUNIT_OPTIONS = (
    BP_REF_OPT(@value 0, @description "milliseconds")
    BP_REF_OPT(@value 1, @description "samples")
    BP_REF_OPT(@value 2, @description "duration" "ratio")
    BP_REF_OPT(@value 3, @description "milliseconds" "difference")
    BP_REF_OPT(@value 4, @description "samples" "difference")
);

BP_REF_ANTIMEUNIT_OPTIONS = (
    BP_REF_OPT(@value 0, @description "milliseconds")
    BP_REF_OPT(@value 1, @description "samples")
    BP_REF_OPT(@value 2, @description "duration" "ratio")
);

BP_REF_ANGLEUNIT_OPTIONS = (
    BP_REF_OPT(@value 0 @description "radians")
    BP_REF_OPT(@value 1 @description "degrees")
    BP_REF_OPT(@value 2 @description "turns")
);

BP_REF_FREQUNIT_OPTIONS = (
    BP_REF_OPT(@value 0 @description "Hertz")
    BP_REF_OPT(@value 1 @description "BPM")
    BP_REF_OPT(@value 2 @description "midicents")
    BP_REF_OPT(@value 3 @description "MIDI")
);

BP_REF_PITCHUNIT_OPTIONS = (
    BP_REF_OPT(@value 0 @description "midicents")
    BP_REF_OPT(@value 1 @description "MIDI")
    BP_REF_OPT(@value 2 @description "Hertz")
    BP_REF_OPT(@value 3 @description "ratio")
);

BP_REF_AUDIO_DOMAIN_OPTIONS = (
    BP_REF_OPT(@value 0, @description "frequency" "domain")
    BP_REF_OPT(@value 1, @description "time" "domain")
);

BP_REF_PITCH_FORMAT_OPTIONS = (
    BP_REF_OPT(@value 0 @description "cents")
    BP_REF_OPT(@value 1 @description "MIDI" )
    BP_REF_OPT(@value 2 @description "Hertz")
    BP_REF_OPT(@value 3 @description "frequency" "ratio")
);

BP_REF_SWITCH_OPTIONS = (
    BP_REF_OPT(@value 0 @description "off")
    BP_REF_OPT(@value 1 @description "on" )
);

BP_REF_NORMALIZE_OPTIONS = (
    BP_REF_OPT(@value 0 @description "never")
    BP_REF_OPT(@value 1 @description "always")
    BP_REF_OPT(@value 2 @description "overload" "protection" "only" )
);

BP_REF_WINDOW_OPTIONS = (
    BP_REF_OPT(@value "'rectangular'")
    BP_REF_OPT(@value "'triangular'")
    BP_REF_OPT(@value "'sine'")
    BP_REF_OPT(@value "'hann'")
    BP_REF_OPT(@value "'hamming'")
    BP_REF_OPT(@value "'blackman'")
    BP_REF_OPT(@value "'nuttall'")
    BP_REF_OPT(@value "'blackmannuttall'")
    BP_REF_OPT(@value "'blackmanharris'")
    BP_REF_OPT(@value "'gaussian'")
    BP_REF_OPT(@value "'sqrthann'")
    BP_REF_OPT(@value "'sqrthamming'")
);

BP_REF_AMPUNIT_OPTIONS = (
    BP_REF_OPT(@value 0, @description "linear")
    BP_REF_OPT(@value 1, @description "decibels")
);

BP_REF_CURVE_OPTIONS = (
    BP_REF_OPT(@value 0, @description "linear")
    BP_REF_OPT(@value 1, @description "sine")
    BP_REF_OPT(@value 2, @description "curve")
    BP_REF_OPT(@value 3, @description "s-curve")
);

BP_REF_RESAMPLINGMODE_OPTIONS = (
    BP_REF_OPT(@value "'sinc'")
    BP_REF_OPT(@value "'nearest" "neighbor'")
    BP_REF_OPT(@value "'sample" "and" "hold'")
    BP_REF_OPT(@value "'linear'")
    BP_REF_OPT(@value "'quad'")
    BP_REF_OPT(@value "'cubic'")
);

BP_REF_RESAMPLINGPOLICY_OPTIONS = (
    BP_REF_OPT(@value 0 @description "don't")
    BP_REF_OPT(@value 1 @description "to" "lowest")
    BP_REF_OPT(@value 2 @description "to" "highest")
    BP_REF_OPT(@value 3 @description "to" "most" "common")
    BP_REF_OPT(@value 4 @description "to" "max." "current")
);

BP_REF_ESSENTIA_ANALYSIS_OPTIONS = (
    BP_REF_OPT(@value 0 @description "global")
    BP_REF_OPT(@value 1 @description "time" "series")
    BP_REF_OPT(@value 2 @description "time-tagged" "time" "series")
    BP_REF_OPT(@value 3 @description "buffer")
);

BP_REF_ESSENTIA_ONSET_METHOD = (
    BP_REF_OPT(@value "'hfc'" @description "high frequency content.")
    BP_REF_OPT(@value "'complex'" @description "the complex-domain spectral difference function.")
    BP_REF_OPT(@value "'complex_phase'" @description "the simplified complex-domain spectral difference function taking into account phase changes, weighted by magnitude.")
    BP_REF_OPT(@value "'flux'" @description "spectral flux.")
    BP_REF_OPT(@value "'melflux'" @description "similar to spectral flux, but using half-rectified energy changes in Mel-frequency bands.")
    BP_REF_OPT(@value "'rms'" @description "difference function, measuring the half-rectified change of the RMS of the magnitude spectrum.")
);

BP_REF_USE_CACHE_ARG = BP_REF_ARG(@name "usecache" @default 1 @type "int" @description "use buffer cache to optimize memory usage." @options BP_REF_SWITCH_OPTIONS);

## ------------------------------------------------------------

addmarker = (
    $onset,
    $names = null,
    $role = null -> (
        $self = 'addmarker';
        BP_FN_CHECK_ARGS($self, 'onset', $onset);
        if $role:1 == 'timesig' then (
            ($role:2 &&& $role:3) ||| BP_FN_ERROR($self, "'timesig' role must be followed by a time signature: <num> <den>");
            $role = $role:1 [ right($role, 1) ]
        ) else if $role:1 == 'tempo' then (
            ($role:2 &&& $role:3) ||| BP_FN_ERROR($self, "'tempo' role must be followed by a tempo assignment: <beat_unit> <bpm>");
            $role = $role:1 [ right($role, 1) ]
        ) else if $role &&& $role.intersection('barline' 'division' 'subdivision') == null then (
            BP_FN_ERROR($self, "invalid marker role")
        );
        BP_FN_DISPATCH("roll", "addmarker" $onset [ $names ] $role)
    )
);

BP_REF_NEW(
    @name "addmarker"
    @description "Inserts a marker into the transcription score, given an onset time and, optionally, a list of names and/or role associated with that marker. Note that if marker role is assigned, names are not displayed in the score but are still associated with the marker. Roles are particularly useful when exporting scores as llll files for quantization purposes."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "onset" @type "int/float" @description "marker onset position.")
        BP_REF_ARG(@name "names" @default "null" @type "symbol/list/null" @description "optional list of marker names.")
        BP_REF_ARG(@name "role" @default "null" @type "symbol/list/null" @description "optional marker role." @options
            BP_REF_OPT(@value 'tempo <unit> <bpm>' @description "tempo marker role, followed by a tempo specification, as a unit ratio and bpm value.")
            BP_REF_OPT(@value 'timesig <time_sig_num> <time_sig_den>' @description "time signature marker role, followed by a time signature, as a pair of numerator and denominator.")
            BP_REF_OPT(@value 'barline' @description "barline marker role")
            BP_REF_OPT(@value 'division' @description "beat division marker role")
            BP_REF_OPT(@value 'subdivision' @description "beat subdivision marker role")
        )
    )
);

## ------------------------------------------------------------

pcdiff = (
    $a, $b, $mod = 12 -> ( 
        BP_FN_CHECK_ARGS('pcdiff', 'a', $a, 'b', $b);
        $a = fmod($a, $mod); 
        $b = fmod($b, $mod); 
        $da = $b - $a;
        $db = $da + $mod * -sgn($da); 
        $mask = max(0, sgn(abs($db) - abs($da)));
        $da * $mask + $db * (1 - $mask)
    ) 
);

BP_REF_NEW(
    @name "pcdiff"
    @description "Signed pitch class difference."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "a" @type "int/float/list" @description "pitch classes.")
        BP_REF_ARG(@name "b" @type "int/float/list" @description "pitch classes.")
        BP_REF_ARG(@name "mod" @default 12 @type "int/float/list" @description "modulo.")
    )
    @output BP_REF_OUTPUT(@description "signed difference", @type "int/float/list")
);

## ------------------------------------------------------------

buildcorpus = (
    $files = null,
    $descriptors = null,
    $outpath = null,
    $segmode = 1,
    $overlap = 1,
    $segsize = 100,
    $alpha = 0.1,
    $delay = 5,
    $framerate = 86.1328,
    $silencethreshold = 0.02,
    $usecache = 1 -> (
        $self = 'buildcorpus';
        BP_FN_CHECK_ARGS($self, 'files', $files, 'descriptors', $descriptors);
        if $files.contains() != 16 then BP_FN_ERROR($self, 'all elements in @files must by of type symbol');
        if $segmode.intersection(0...2) == null then BP_FN_ERROR($self, "invalid @segmode:" $segmode);
        if $segsize <= 0 then BP_FN_ERROR($self, "segmentation size must be greater than zero");

        if $outpath != null then (
            $pathinfo = BP_FN_PATHINFO($outpath);
            $ext = $pathinfo."extension";
            if $ext != ".llll" then (
                BP_FN_ERROR($self, "invalid corpus extension:" $ext)
            ) else if $path."type" == 3 then (
                BP_FN_ERROR($self, "invalid @outpath:" $outpath)
            );
            $outpath = $pathinfo."path" + $pathinfo."extension"
        );

        BP_DATABASE_OUTPUT = null;

        $corpus = null;

        $onsetdescriptor = onsets(
            @alpha $alpha
            @delay $delay
            @framerate $framerate
            @silencethreshold $silencethreshold
        );
        
        for $file in $files do (
            $pathinfo = BP_FN_PATHINFO($file);
            if ($pathinfo."extension").intersection(BP_SUPPORTED_AUDIO_FORMATS) == null then (
                BP_FN_ERROR($self, "invalid audio file:" $file)
            ) else (
                $path = $pathinfo."path" + $pathinfo."extension";
                $buff = importaudio($path @usecache $usecache);
                $segref = $buff;
                $segments = null;
                if $segmode != 0 then (
                    if $segmode == 1 then (
                        $buff = $buff.analyze(
                            @descriptors $onsetdescriptor
                        );
                        $onsets = $buff.getkey("onsets") ||| 0;
                        $durations = ($onsets $buff.getkey("source_end")).x2dx()
                    ) else if $segmode == 2 then (
                        $hopsize = $segsize / $overlap;
                        $numsegs = max(1, ceil($buff.getkey("duration") / $hopsize));
                        $onsets = (0...($numsegs - 1)) * $hopsize;
                        $durations = $segsize :* $onsets.length()
                    );
                    for $onset in $onsets, $duration in $durations do (
                        $segments _= $segref.setkey("offset", $onset).setkey("duration", $duration)
                    )
                ) else (
                    $segments _= $buff
                );
                for $seg in $segments do (
                    $seg = $seg.analyze(
                        @descriptors $descriptors
                    ).setkey("source", $path);
                    $corpus _= $seg
                )
            )
        );
        $template = for $keyval in $corpus::1 with @unwrap 1 collect (
            $key = $keyval.left(1);
            $val = $keyval.right(1);
            $type = null;
            $contains = $val.contains();
            $type = if $val == null || $val.length() > 1 || $val.depth() > 1 then (
                "l"
            ) else if $contains == 2 then (
                "i"
            ) else if $contains == 4 then (
                "r"
            ) else if $contains == 8 then (
                "f"
            ) else if $contains == 16 then (
                "s"
            ) else if $contains == 256 then (
                "p"
            ) else (
                "l"
            );
            [ $key $type ]
        );
        BP_FN_DISPATCH("db", [ "erase" ] [ "addtable" "buffers" $template ]);
        for $entry in $corpus do (
            $entry = ($entry::1).map(
                ## nullify inf and nan values
                $x -> (
                    if $x.contains() <= 8 && ($x.abs() == BP_INF || $x.isnan()) then null else $x
                )
            @maxdepth -1);
            BP_FN_DISPATCH("db", [ "addentry" "buffers" $entry ])
        );

        if $outpath != null then (
            BP_FN_DISPATCH("db", [ "write" $outpath ] )
        )
    )
);

BP_REF_NEW(
    @name "buildcorpus"
    @description "Creates a buffer corpus from a list of audio file paths, and writes it into disk as a .llll file. See #analyze and #onsets."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "files" @type "symbol/list" @description "list of audio file paths.")
        BP_REF_ARG(@name "descriptors" @type "llll" @description "list of audio descriptors.")
        BP_REF_ARG(@name "outpath" @default "null" @type "symbol/null" @description "optional output corpus path, as an .llll file. If null, the corpus is not written into memory.")
        BP_REF_ARG(@name "segmode" @default 1 @type "int" @description "buffer segmentation mode." @options 
            BP_REF_OPT(@value 0 @description "no" "segmentation")
            BP_REF_OPT(@value 1 @description "'onsets'-based" "segmentation")
            BP_REF_OPT(@value 2 @description "blind" "segmentation")
        )
        BP_REF_ARG(@name "overlap" @default 1 @type "int/float" @description "segment overlap factor, when @segmode is 2.")
        BP_REF_ARG(@name "segsize" @default 100 @type "int" @description "segment duration in milliseconds, when @segmode is 2.")
        BP_REF_ARG(@name "alpha" @default 0.1 @type "float" @description "proportion of the mean included to reject smaller peaks — filters very short onsets.")
        BP_REF_ARG(@name "delay" @default 5 @type "int" @description "number of frames used to compute the threshold — size of short-onset filter.")
        BP_REF_ARG(@name "framerate" @default 86.1328 @type "float" @description "frames per second.")
        BP_REF_ARG(@name "silencethreshold" @default 0.02 @type "float" @description "threshold for silence.")
        BP_REF_USE_CACHE_ARG
    )
);

## ------------------------------------------------------------

setcorpus = (
    $filepath -> (
        $self = 'setcorpus';
        BP_FN_CHECK_ARGS($self, 'filepath', $filepath);
        $pathinfo = BP_FN_PATHINFO($filepath @locate 1);
        $path = $pathinfo."path";
        $extension = $pathinfo."extension";
        if $extension != ".llll" then BP_FN_ERROR($self, if $extension == null then "you must provide a file path" else "invalid corpus extension:" $extension);
        BP_DATABASE_OUTPUT = null;
        BP_FN_DISPATCH("db", [ "read" $path + $extension ])
    )
);

BP_REF_NEW(
    @name "setcorpus",
    @description "Loads an audio corpus, given a path to a .llll file. See #query function.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "filepath" @type "symbol" @description "file path to .llll corpus file.")
    )
);

## ------------------------------------------------------------

getcorpuskeys = (
   $typed = 1 -> (
        BP_FN_DISPATCH('db', [ "getcols" ]);
        $keys = (BP_DATABASE_OUTPUT::1).right(1);
        if $typed == 1 then $keys else for $x in $keys collect $x.flat():1
    )
);

BP_REF_NEW(
    @name "getcorpuskeys"
    @description "Returns a list with the current corpus' keys. See #setcorpus, #buildcorpus, and #query."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "typed" @default 1 @type "int" @description "include the data type for each key." @options 
            BP_REF_SWITCH_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "corpus keys" @type "list/llll")
);

## ------------------------------------------------------------

samplelist = (
    $x, $i -> (
        BP_FN_CHECK_ARGS('samplelist', 'x', $x, 'i', $i);
        $i = min(1, max(0, $i));
        $N = length($x);
        $i = scale($i, 0, 1, 1, $N);
        $l = floor($i);
        $r = min($l + 1, $N);
        $m = fmod($i, 1);
        $x:[$l] * (1 - $m) + $x:[$r] * $m
    )
);

BP_REF_NEW(
    @name "samplelist"
    @description "Samples an interpolated value from a numeric list given a normalized index."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "x" @type "list" @description "list to sample from.")
        BP_REF_ARG(@name "i" @type "list" @description "normalized sampling index.")
    )
    @output BP_REF_OUTPUT(@description "interpolated sample", @type "int/float/list")
);

## ------------------------------------------------------------

median = (
    $x -> (
        $x = sort($x);
        $n = length($x);
        $odd = $n % 2;
        if $odd == 0 then (
            $i = ($n // 2);
            ($x:$i + $x:($i + 1)) * 0.5
        ) else (
            $x:(($n + 1) // 2)
        )
    )
);

BP_REF_NEW(
    @name "median"
    @description "Returns the median element of a numeric list."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "x" @type "list" @description "numeric list.")
    )
    @output BP_REF_OUTPUT(@description "median element", @type "int/float")
);

## ------------------------------------------------------------

mean = (
    $x, $weights = null -> (
        $N = length($x);
        if $weights != null then (
            if length($weights) != $N then BP_FN_ERROR("mean", "the number of weights must match the number of elements.");
            $x *= $weights;
            $N = reduce($weights, #+)
        );
        float(reduce($x, #+) / $N)
    )
);

BP_REF_NEW(
    @name "mean",
    @description "Returns the mean value of a numeric list.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "x",  @type "list" @description "numeric list.")
        BP_REF_ARG(@name "weights" @default "null" @type "list/null" @description "optional weights.")
    ),
    @output BP_REF_OUTPUT(@description "mean value", @type "float")
);

## ------------------------------------------------------------

query = (
    $sql = "SELECT * FROM buffers", 
    $usecache = 1 -> (
        BP_FN_CHECK_ARGS('query', 'sql', $sql);
        BP_FN_DISPATCH("db", [ "query" $sql ]);
        (if BP_DATABASE_OUTPUT == null then BP_FN_ERROR('query', "query did not yield any results:" tosymbol($sql)));
        $sources = thin(for $buff in BP_DATABASE_OUTPUT collect $buff.getkey("source"));
        $sourcemap = for $source in $sources collect [ $source importaudio($source @usecache $usecache).getkey("source") ];
        BP_DATABASE_OUTPUT = for $buff in BP_DATABASE_OUTPUT collect $buff.mapkey("source", $x -^ $sourcemap -> $sourcemap.$x);    
        BP_DATABASE_OUTPUT
    )
);

BP_REF_NEW(
    @name "query",
    @description "Executes a #sqlite3 query on the current audio corpus, and returns the results. Every query should use 'buffers' as the table name. For instance: 'SELECT * FROM buffers'. See #setcorpus.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "sql" @type "symbol" @default "'SELECT * FROM buffers'" @description "sqlite3 query.")
        BP_REF_USE_CACHE_ARG
    ),
    @output BP_REF_OUTPUT(@description "list of buffers", @type "llll")
);

## ------------------------------------------------------------

getkey = (
    $llll, $key -> (
        $ok = BP_FN_CHECK_ARGS('getkey', 'llll', $llll, 'key', $key);
        if $ok == 1 then ($llll::1).$key
    )
);

BP_REF_NEW(
    @description "Returns value associated with an llll key."
    @name "getkey"
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "llll" @type "llll" @description "list to get key of.")
        BP_REF_ARG(@name "key" @type "symbol" @description "name of llll key.")
    )
    @output BP_REF_OUTPUT(@description "value associated with key" @type "anything")
);

## ------------------------------------------------------------

setkey = (
    $llll, $key, $val, $mode = 0 -> (
        $ok = BP_FN_CHECK_ARGS('setkey', 'llll', $llll, 'key', $key);
        if $ok == 1 then (
            if $mode == 0 || ($llll::1).$key != null then [ ($llll::1).$key = $val ] else [ $llll::1 [ $key $val ] ] 
        )
    )
);

BP_REF_NEW(
    @name "setkey"
    @description "Sets the value of a given key in a llll. If @mode is 0 (default), values for non-existent keys are ignored."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "llll" @type "llll" @description "llll to modify.")
        BP_REF_ARG(@name "key" @type "symbol" @description "name of llll key.")
        BP_REF_ARG(@name "val" @type "anything" @description "new value for llll key.")
        BP_REF_ARG(@name "mode" @default 0 @type "int" @description "behavior mode." @options 
            BP_REF_OPT(@value 0 @description "only set values for existing keys")        
            BP_REF_OPT(@value 1 @description "always set values and create new keys when necessary.")        
        )
    )
    @output BP_REF_OUTPUT(@description "modified llll", @type "llll")
);

## ------------------------------------------------------------

mapkey = (
    $llll, $key, $func -> (
        BP_FN_CHECK_ARGS('mapkey', 'llll', $llll, 'key', $key, 'func', $func);
        setkey($llll, $key, $func(getkey($llll, $key), $llll))
    )
);

## $newvalue = dummy
BP_REF_NEW(
    @name "mapkey"
    @description "Modifies an existing llll key via a lambda function."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "llll" @type "llll" @description "llll to modify.")
        BP_REF_ARG(@name "key" @type "symbol" @description "name of llll key.")
        BP_REF_ARG(@name "func" @type "lambda function" @description "lambda function with signature $currentvalue, $currentbuffer -> $newvalue.")
    )
    @output BP_REF_OUTPUT(@description "modified llll" @type "llll")
);

## ------------------------------------------------------------

bpf = (
    $pts,
    ## by default, x axis is sorted and normalized
    $xfunc = ($x -> ($norm = maximum($x ||| 1.); sort(float($x) / if $norm != 0 then $norm else 1.))),
    $yfunc = null,
    $sfunc = null -> (
        BP_FN_CHECK_ARGS('bpf', 'pts', $pts);
        $depth = depth($pts);
        $size = length($pts);
        if $depth == 1 then (
            $x = arithmser(0, 1, null, $size);
            if $xfunc != null then $x = $xfunc($x);
            $y = (if $yfunc then $yfunc($pts) else $pts);
            $s = 0 :* $size;
            if $sfunc != null then $s = $xfunc($s);
            trans([$x] [$y] [$s])
        ) else if $depth == 2 then (
            $cols = trans($pts);
            $x = [ if $xfunc != null then $xfunc($cols::1) else $cols::1 ];
            $y = [ if $yfunc != null then $yfunc($cols::2) else $cols::2 ];
            $slope = for $i in 1...$size collect ($pts::($i 3)) ||| 0;
            if $sfunc then (
                $slope = $sfunc($slope)
            );
            trans($x $y [ $slope ])
        )
    )
);

BP_REF_NEW(
    @name "bpf"
    @description "Formats an numeric list into a breakpoint function, in the form of [<x> <y> <slope>] tuples. By default, <x> is normalized to the 0-1 range. To prevent this, set @xfunc to null."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "pts" @type "list" @description "numeric list")
        BP_REF_ARG(@name "xfunc" @default "<normalization_function>" @type "function/null" @description "optional lambda function for x axis")
        BP_REF_ARG(@name "yfunc" @default "null" @type "function/null" @description "optional lambda function for y axis")
        BP_REF_ARG(@name "sfunc" @default "null" @type "function/null" @description "optional lambda function for bpf slope")
    )
    @output BP_REF_OUTPUT(@description "breakpoint function" @type "llll")
);


## ------------------------------------------------------------

x2dx = (
    $x -> (
        BP_FN_CHECK_ARGS('x2dx', 'x', $x);
        right($x, 1) - left($x, -1)
    )
);

BP_REF_NEW(
    @name "x2dx"
    @description "Takes a list of numbers and returns the differences — i.e., deltas — between adjacent elements. Inverse of #dx2x."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "x" @type "list" @description "list of numeric values.")
    )
    @output BP_REF_OUTPUT(@description "difference between adjacent elements, as a list." @type "list")
);

## ------------------------------------------------------------

dx2x = (
    $dx, $st = 0 -> (
        BP_FN_CHECK_ARGS('dx2x', 'dx', $dx);
        $st for $x in $dx collect $st += $x
    )
);

BP_REF_NEW(
    @name "dx2x"
    @description "Takes a list of differences — i.e., deltas — and an optional starting value, and returns the cumulative sum between adjacent elements, as a list. Inverse of #x2dx."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "dx" @type "list" @description "list of differences/deltas.")
        BP_REF_ARG(@name "st" @default 0 @type "int/float" @description "optional starting value.")
    )
    @output BP_REF_OUTPUT(@description "cumulative sum of differences from starting value." @type "list")
);

## ------------------------------------------------------------

r2dr = (
    $r -> (
        BP_FN_CHECK_ARGS('r2dr', 'r', $r);
        $r.right(1) / $r.left(-1)
    )
);

BP_REF_NEW(
    @name "r2dr"
    @description "Takes a list of ratios or factors and returns the quotients between adjacent elements. Inverse of #dr2r."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "r" @type "list" @description "list of ratios.")
    )
    @output BP_REF_OUTPUT(@description "list of quotients between adjacent elements" @type "list")
);

## ------------------------------------------------------------

dr2r = (
    $dr, $st = 1 -> (
        BP_FN_CHECK_ARGS('dr2r', 'dr', $dr);
        $st for $x in $dr collect $st *= $x
    )
);

BP_REF_NEW(
    @name "dr2r"
    @description "Takes a list of ratios and an optional starting value, and returns the cumulative multiplication between adjacent elements, as a list. Inverse of #r2dr."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "dr" @type "list" @description "list of ratios.")
        BP_REF_ARG(@name "st" @default 1 @type "int/float" @description "starting value")
    )
    @output BP_REF_OUTPUT(@description "cumulative multiplication between adjacent elements." @type "list")
);

## ------------------------------------------------------------

revbpf = (
    $bpf -> (
        BP_FN_CHECK_ARGS('revbpf', 'bpf', $bpf);
        bpf($bpf, 
            ($x -> dx2x(rev(x2dx($x)))), 
            ($y -> rev($y)), 
            ($s -> left($s, 1) rev(right($s, 1)) * -1)
        )
    )
);

BP_REF_NEW(
    @name "revbpf",
    @description "Reverses a breakpoint function. See #bpf.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "bpf", @type "llll", @description "breakpoint function to reverse")
    ),
    @output BP_REF_OUTPUT(@description "breakpoint function", @type "llll")
);

## ------------------------------------------------------------

scale = (
    $x, $inmin = 0, $inmax = 1, $outmin = 0, $outmax = 1, $slope = 0 -> (
        BP_FN_CHECK_ARGS('scale', 'x', $x);
        $s = max(-1, min(1, $slope));
        $n = ($x - $inmin) / ($inmax - $inmin);
        $n = BP_FN_GET_BPF_INTERPOLATION_WEIGHT($n, $s);
        $n * float($outmax - $outmin) + $outmin
    )
);

BP_REF_NEW(
    @name "scale"
    @description "Scales an input value or list from a given range to another, with optional slope for non-linear scaling."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "x" @type "int/float/list", @description "value to scale.")
        BP_REF_ARG(@name "inmin" @type "int/float" @default 0 @description "input minimum value.")
        BP_REF_ARG(@name "inmax" @type "int/float" @default 1 @description "input maxiumum value.")
        BP_REF_ARG(@name "outmin" @type "int/float" @default 0 @description "output minimum value.")
        BP_REF_ARG(@name "outmax" @type "int/float" @default 1 @description "output maxiumum value.")
        BP_REF_ARG(@name "slope" @type "int/float" @default 0 @description "slope between -1 and 1. 0 means no slope.")
    )
    @output BP_REF_OUTPUT(@description "scaled input" @type "int/float/list/llll")
);

## ------------------------------------------------------------

rand = (
    $a = 1, $b = null -> (
        if $b == null then (
            $min = 0;
            $max = $a
        ) else (
            $min = $a;
            $max = $b
        );
        scale(random(0, BP_RAND_RES), 0, BP_RAND_RES, $min, $max)
    )
);

BP_REF_NEW(
    @name "rand"
    @description "Random floating point number generator."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "a" @default 1 @type "int/float" @description "max. value if @b is null, else min. value.")
        BP_REF_ARG(@name "b" @default 'null' @type "int/float/null" @description "max. value.")
    )
    @output BP_REF_OUTPUT(@description "random floating point number", @type "int/float")
);

## ------------------------------------------------------------

nearest = (
    $list = null, 
    $target = null, 
    $mode = 0 -> (
        BP_FN_CHECK_ARGS('nearest', 'list', $list, 'target', $target);
        $list = sort($list);
        $left = 1;
        $right = length($list);
        $nearest = null;  
        
        while $left <= $right do (
            $mid = ($left + $right) // 2;
            $midval = $list:$mid;
            
            ## update the nearest value
            if $nearest == null || (abs($midval - $target) < abs($nearest - $target)) then (
                $nearest = $midval
            );
            
            ## decision to move the search boundaries
            if $midval == $target then (
                ## exit loop as the exact match is the nearest
                $left = $right + 1
            ) else if $midval < $target then (
                ## Target might be in the right half
                $left = $mid + 1
            ) else (
                ## Target might be in the left half
                $right = $mid - 1
            )
        );
        ## The nearest value is returned as the last expression
        $nearest
    )
);

BP_REF_NEW(
    @name "nearest"
    @description "Given a target number, finds the nearest value in a numeric list via binary search."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "list" @type "list" @description "numeric list to search.")
        BP_REF_ARG(@name "target" @type "int/float" @description "target number to find nearest value for.")
        BP_REF_ARG(@name "mode" @default 0 @type "int" @description "output mode." @options 
            BP_REF_OPT(@value 0 @description "output value.")        
            BP_REF_OPT(@value 1 @description "output address.")        
        )
    )
    @output BP_REF_OUTPUT(@description "nearest value or address" @type "int/float")
);

## ------------------------------------------------------------

BP_FN_RANDOM_CHOICE = (
    $choices, 
    $n = 1, 
    $weights = null,
    $mode = 0 -> (
        if $mode == 0 then (
            $random = random;
            $rand = rand
        ) else (
            $random = xrandom;
            $rand = xrand
        );
        $len = length($choices);
        $sum = if $weights == null then 0 else reduce($weights, #+);
        for $i in 1...$n collect (
            if $sum == 0 then (
                $choices:$random(1, $len)
            ) else (    
                $choice = null;
                $prob = $rand() * $sum;
                for $x in $choices, $w in $weights as $choice == null with @iterationmode 1 do (
                    if $prob < $w then $choice = $x;
                    $prob -= $w 
                );
                $choice  
            )
        )
    )
);

## ------------------------------------------------------------

choose = (
    $choices, 
    $n = 1, 
    $weights = null -> (
        BP_FN_RANDOM_CHOICE($choices, $n, $weights)
    )
);

BP_REF_NEW(
    @name "choose",
    @description "Choose randomly one or more elements from a list, with optional probability weights.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "choices", @type "list", @description "list to choose from.")
        BP_REF_ARG(@name "n" @default 1 @type "int", @description "number of random choices.")
        BP_REF_ARG(@name "weights" @default "null" @type "list/null", @description "optional probability weights for each element.")
    ),
    @output BP_REF_OUTPUT(@description "chosen elements" @type "anything")
);

## ------------------------------------------------------------

setseed = (
    $seed -> (
        $self = 'setseed';
        BP_FN_CHECK_ARGS($self, 'seed', $seed);
        if $seed.contains() == 2 then BP_MAXOBJ_RANDOM("seed" $seed) else BP_FN_ERROR($self, "invalid seed value:" $seed);
        null
    )
);

BP_REF_NEW(
    @name "setseed"
    @description "Sets the random seed for the #xrand, #xrandom, #xchoose, #xscramble, and #urn functions."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "seed", @type "int", @description "random seed")
    )
);

## ------------------------------------------------------------

xrand = (
    $a = 1,
    $b = null -> (
        $min = $a;
        $max = $b;
        if $max == null then (
            $max = $min;
            $min = 0
        );
        BP_MAXOBJ_RANDOM('bang').scale(0, 2147483647, $min, $max)
    )
);

BP_REF_NEW(
    @name "xrand",
    @description "Seed-based random floating point number generator. See #setseed.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "a" @default 1 @type "int/float", @description "max. value if @b is null, else min. value.")
        BP_REF_ARG(@name "b" @default "null" @type "int/float/null", @description "max. value.")
    ),
    @output BP_REF_OUTPUT(@description "random number", @type "float")
);

## ------------------------------------------------------------

xrandom = (
    $a = 1,
    $b = null -> (
        xrand($a, $b).round().int()
    )
);

BP_REF_NEW(
    @name "xrandom",
    @description "Seed-based random integer number generator. See #setseed.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "a" @default 1 @type "int", @description "max. value if @b is null, else min. value.")
        BP_REF_ARG(@name "b" @default "null" @type "int/null", @description "max. value.")
    ),
    @output BP_REF_OUTPUT(@description "random number", @type "integer")
);

## ------------------------------------------------------------

xchoose = (
    $choices, $n = 1, $weights = null -> BP_FN_RANDOM_CHOICE($choices, $n, $weights @mode 1)
);

BP_REF_NEW(
    @name "xchoose",
    @description "Choose randomly one or more elements from a list, with optional probability weights. See #setseed.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "choices", @type "list", @description "list to choose from.")
        BP_REF_ARG(@name "n", @default 1, @type "int", @description "number of random choices.")
        BP_REF_ARG(@name "weights", @default "null" @type "list/null", @description "optional probability weights for each element.")
    ),
    @output BP_REF_OUTPUT(@description "chosen elements" @type "anything")
);

## ------------------------------------------------------------

xscramble = (
    $llll -> (
        BP_FN_CHECK_ARGS('xscramble', 'llll', $llll);
        $indices = 1...$llll.length();
        $order = for $id in $indices collect xrand();
        $indices = $indices.sort(@function $a, $b -^ $order -> $order:$a <= $order:$b);
        $llll:[$indices]
    )
);

BP_REF_NEW(
    @name "xscramble"
    @description "Seed-based random shuffling of elements. See #setseed."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "llll" @type "list/llll", @description "list to scramble.")
    )
    @output BP_REF_OUTPUT(@description "scrambled list", @type "list/llll")
);

## ------------------------------------------------------------

initurn = (
    $size = 10, $id = 0, $useseed = 0 -> (
        BP_FN_CHECK_ARGS('initurn', 'size', $size, 'id', $id);
        $shuffler = if $useseed == 0 then scramble else xscramble;
        $urn = [
            "pool" (
                0...($size.max(1) - 1)
            ).$shuffler()
        ] ["size" $size];
        if BP_URN.$id == null then BP_URN _= [$id $urn] else BP_URN.$id = $urn;
        null
    )
);

BP_REF_NEW(
    @name "initurn"
    @description "Initializes a new unique random number generator (URN), given a size and a URN identifier. Once initialized, the identifier can be used to generate unique random numbers with the #urn function. This allows for independent URNs of different sizes to be used within the same script. If a URN associated with the identifier already exists, the URN is reset. The initialized URN can be optionally be seed-based. See #setseed."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "size" @default 10 @type "int", @description "number of unique random numbers.")
        BP_REF_ARG(@name "id" @default 0 @type "int/float/symbol", @description "identifier for unique random number generator.")
        BP_REF_ARG(@name "useseed" @default 0 @type "list/llll", @description "use random seed for URN associated with @id.")
    )
);

## ------------------------------------------------------------

urn = (
    $id = 0 -> (
        $self = 'urn';
        BP_FN_CHECK_ARGS($self, 'id', $id);
        $urn = BP_URN.$id;
        if $urn == null then BP_FN_ERROR($self, "a unique random number generator with id of" $id "doesn't exist yet. Use initurn() to initialize a new unique random number generator.") else (
            $pool = $urn."pool";
            $next = $pool.left(1);
            $pool = $pool.right(1);
            if $pool == null then (
                initurn(
                    @size $urn."size" 
                    @id $id 
                    @useseed $urn."useseed"
                )
            ) else (BP_URN.$id."pool" = $pool);
            $next
        )
    )
);

BP_REF_NEW(
    @name "urn"
    @description "Returns a unique random number for a given URN identifier. Note that you must call #initurn first to initialize the URN."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "id" @default 0 @type "int/float/symbol", @description "identifier for URN.")
    )
    @output BP_REF_OUTPUT(@description "unique random number", @type "int")
);

## ------------------------------------------------------------

atodb = ($a -> 20 * log10($a));

BP_REF_NEW(
    @name "atodb"
    @description "Linear amplitude to decibels conversion."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "a" @type "int/float", @description "linear amplitude.")
    )
    @output BP_REF_OUTPUT(@description "decibels", @type "int/float")
);

## ------------------------------------------------------------

dbtoa = ($db -> 10 ** ($db/20));

BP_REF_NEW(
    @name "dbtoa"
    @description "Decibels to linear amplitude conversion."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "db" @type "int/float", @description "decibels.")
    )
    @output BP_REF_OUTPUT(@description "linear amplitude.", @type "int/float")
);

## ------------------------------------------------------------

c2r = (
    $cents -> 2 ** ($cents / 1200)
);

BP_REF_NEW(
    @name "c2r",
    @description "Cents to ratio conversion.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "cents" @type "list/int/float", @description "cents to convert.")
    ),
    @output BP_REF_OUTPUT(@description "list of ratios", @type "int/float/list")
);

## ------------------------------------------------------------

octreduce = ($ratios -> $ratios * 2 ** -int(floor(log2($ratios))));

BP_REF_NEW(
    @name "octreduce",
    @description "Reduces ratios to fit within the 1-2 range.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "ratios", @type "list/int/rat/float", @description "ratios to reduce.")
    ),
    @output BP_REF_OUTPUT(@description "list of pitch classes", @type "list/int/float")
);

## ------------------------------------------------------------

r2pc = (
    $ratios,
    $pc = 0 -> (
        $ref = c2r($pc * 100);
        r2c(octreduce($ratios * $ref)) / 100.
    )
);

BP_REF_NEW(
    @name "r2pc",
    @description "Ratio to pitch class conversion, assuming octave equivalence.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "ratios", @type "list/int/float", @description "ratios to convert.")
        BP_REF_ARG(@name "pc", @default 0 @type "int/float", @description "pitch class of fundamental")
    ),
    @output BP_REF_OUTPUT(@description "list of pitch classes", @type "list/int/float")
);

## ------------------------------------------------------------

mc2pc = ($mc -> fmod($mc, 1200.) / 100);

BP_REF_NEW(
    @name "mc2pc",
    @description "midicent to pitch class conversion.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "mc", @type "list/int/float", @description "midicents to convert.")
    ),
    @output BP_REF_OUTPUT(@description "list of pitch classes", @type "list/int/float")
);

## ------------------------------------------------------------

r2mc = (
    $ratios,
    $mc = 6000 -> (
        f2mc(mc2f($mc) * $ratios)
    )
);

BP_REF_NEW(
    @name "r2mc",
    @description "Ratio to midicent conversion.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "ratios", @type "list/int/float", @description "ratios to convert.")
        BP_REF_ARG(@name "mc", @default 6000 @type "int/float", @description "fundamental in midicents")
    ),
    @output BP_REF_OUTPUT(@description "list of midicents", @type "list/int/float")
);

## ------------------------------------------------------------

r2c = (
    $ratios -> log2($ratios) * 1200
);

BP_REF_NEW(
    @name "r2c",
    @description "Ratio to cents conversion.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "ratios", @type "list/int/float", @description "ratios to convert.")
    ),
    @output BP_REF_OUTPUT(@description "list of cents", @type "list/int/float")
);

## ------------------------------------------------------------

sortbykeys = (
    $llll, $keys -> (
        for $k in rev($keys) do $llll = sort($llll, ($a, $b -^ $k -> (getkey($a, $k) < getkey($b, $k))))
    )
);

BP_REF_NEW(
    @name "sortbykeys"
    @description "Sorts llll elements by a given set of keys. It assumes all keys are associated with single, quantifiable values."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "llll" @type "llll" @description "list to sort.")
        BP_REF_ARG(@name "keys" @type "list/symbol" @description "one or more keys to sort list by.")
    )
    @output BP_REF_OUTPUT(@description "list of sorted items" @type "llll")
);

## ------------------------------------------------------------

fold = $x -> abs(fmod($x * 2 + 1, 2) - 1);

BP_REF_NEW(
    @name "fold",
    @description "Triangular function. Linearly folds numeric values to the 0-to-1 range.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "x", @type "int/float/list/llll", @description "input number.")
    ),
    @output BP_REF_OUTPUT(@description "output number.", @type "int/float/list/llll")
);

## ------------------------------------------------------------

pitchdiff = (
    $source, $targets -> (
        BP_FN_CHECK_ARGS('pitchdiff', 'targets', $targets);
        if $source > 0 && $source.isnan() == 0 then (
            $distances = (
                if $targets:1 < 12 then (
                    pcdiff($source / 100., $targets) * 100
                ) else (
                    $targets - $source
                )
            );
            $diff = $distances:(minmax(abs($distances)):2);
            if $diff.isnan() == 1 then 0 else $diff
        ) else 0
    )
);

BP_REF_NEW(
    @name "pitchdiff",
    @description "Given a list of target midicents and/or pitch classes, returns the signed difference between a pitch in midicents and the nearest midicent/pitch class target.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "source" @type "int/float" @description "reference pitch in midicents.")
        BP_REF_ARG(@name "targets" @type "int/float/list" @description "list of midicent or pitch class targets.")
    ),
    @output BP_REF_OUTPUT(@description "signed difference to closest target, in cents." @type "int/float")
);

## ------------------------------------------------------------

transcribe = (
    $buffer, 
    $onset = 0, 
    $pan = null, 
    $gain = null, 
    $detune = null, 
    $voice = 1, 
    $pitchkey = "pitch",
    $keepduration = 1,
    $metadata = null,
    $annotation = null -> (
        $self = 'transcribe';
        BP_FN_CHECK_ARGS($self, 'buffer', $buffer);
        $source = BP_FN_VALIDATE_BUFFER($self, $buffer);
        if $voice > BP_SCORE_CONFIG."numvoices" then BP_FN_ERROR($self, "@voice exceeds the number of voices. Use scoreconfig() to change the number of voices.");
        ## unpack buffer
        $buffer = $buffer::1;

        ## check for non-zero detuning
        $rate = [ 11 (if $detune && $detune != 0 then c2r($detune)) ];

        ## get pitch value
        $mc = $pitchkey &&& ($buffer.$pitchkey).flat().left(1);

        $notehead = 85;
        
        if $mc == null || $mc <= 0 || $mc.isnan() then (
            $mc = 6000;
            $notehead = 88
        );

        $notehead = [ 23 $notehead ];

        ## keep copy before pitch shifting
        $mccopy = $mc; 
        
        ## check if detuning is applied
        if $rate::(1 2) then (
            ## update pitch value based on detuning
            $mc += r2c($rate::(1 2))
        ) else (
            ## nullify unused slot for optimization
            $rate = null
        );
        ## color note based on detuning
        $color = [ 6 fmod(abs(($mccopy - $mc) / 1200) + .66, 1) ];

        ## clean gain and panning slots
        $pan = if $pan != null then [ 2 bpf($pan) ];
        $gain = if $gain != null then [ 1 bpf($gain @yfunc $y -> $y * 127.) ];

        ## get chord velocity and duration
        $vel = if $gain then maximum(trans($gain.1)::2) else 64;
        $dur = $buffer."duration";

        if $keepduration == 0 && $rate != null then (
            $dur /= $rate::(1 2)
        );
        
        if $dur == null || $dur <= 0 then BP_FN_ERROR($self, "invalid buffer duration:" $dur ||| 'null');
        
        ## make size slot based on duration
        $size = [ 4 scale(log2(min(16384, max(1, $dur))), 0, 14, 25, 150) ];

        ## format note and add to roll
        $note = [ $mc $dur $vel ["slots" [ 7 $source ] [ 10 $buffer."offset" ] ($metadata &&& [ 3 $metadata ]) ($annotation &&& [ 24 $annotation ]) $pan $rate $gain $color $notehead $size ]];
        BP_FN_DISPATCH("roll", "addchord" ($voice ||| 1) [ ($onset ||| 0) $note ])
    )
);

BP_REF_NEW(
    @name "transcribe",
    @description "Adds input buffer to the rendering sequence. See #render function."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "buffer" @type "llll" @description "buffer to add to rendering sequence.")
        BP_REF_ARG(@name "onset" @type "int/float" @default 0, @description "buffer onset in milliseconds.")
        BP_REF_ARG(@name "pan" @type "int/float/list/llll" @default "null" @description "normalized panning value or envelope.")
        BP_REF_ARG(@name "gain" @type "int/float/llll" @default "null" @description "linear gain value or envelope. Use the #gain function for values greater than 1.")
        BP_REF_ARG(@name "detune" @type "int/float" @default "null" @description "detuning amount in cents.")
        BP_REF_ARG(@name "voice" @type "int" @default 1 @description "voice assignment in score. See #scoreconfig function.")
        BP_REF_ARG(@name "pitchkey" @type "symbol" @default "'pitch'" @description "key to use for pitch value in score transcription.")
        BP_REF_ARG(@name "keepduration" @type "int" @default 1 @description "keep buffer's nominal duration value when detuning buffer via @detune.")
        BP_REF_ARG(@name "metadata" @default 'null' @type "anything" @default 1 @description "data to associate with buffer. Useful when exporting roll in llll format.")
        BP_REF_ARG(@name "annotation" @default 'null' @type "symbol/null" @default 1 @description "optional label to display next to transcribed buffer.")
    )
);

## ------------------------------------------------------------

render = (
   $numchannels = 2, 
   $panmode = 0, 
   $sr = 48000, 
   $normalize = 0, 
   $play = 0, 
   $spread = 1,
   $fade = 5,
   $reset = 0,
   $process = null -> (
        if $numchannels < 1 then BP_FN_ERROR('render', "number of channels must be greater than 0");
        BP_FN_DISPATCH("sampler", 
            [ "panmode" $panmode] 
            [ "numchannels" $numchannels ] 
            [ "sr" $sr ]
            [ "fadein" $fade ]
            [ "fadeout" $fade ]
            [ "normalize" $normalize ]
            [ "spread" $spread ]
        );
        BP_FN_DISPATCH("roll", "getlength");
        BP_FN_DISPATCH("roll", "dump");
        ($process &&& BP_FN_DISPATCH("sampler", [ "process" $process ] ));
        BP_FN_DISPATCH("roll", "getdomain");
        BP_PLAY_TOGGLE = $play;
        ($reset == 1 && BP_FN_DISPATCH("roll", "clear"));
        BP_FN_NEWBUFF(@source BP_RENDER_BUFF)
    )
);

BP_REF_NEW(
    @name "render",
    @description "Triggers audio rendering of all transcribed buffers via #transcribe, and returns the rendered buffer. Note that it's possible to apply post-rendering processing by passing audio processing operations (e.g., #reverse, #freeverb, #clip, etc.) to the @process arguments, but these audio modifications won't be accurately reflected in the score transcription. See #process function.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "numchannels", @type "int", @default 2, @description "number of output channels.")
        BP_REF_ARG(@name "panmode", @type "int", @default 0, @description "panning mode." @options 
            BP_REF_OPT(@value 0, @description "linear")
            BP_REF_OPT(@value 1, @description "circular")
        )
        BP_REF_ARG(@name "sr", @type "int", @default 48000, @description "sampling rate.")
        BP_REF_ARG(@name "normalize", @type "int", @default 0, @description "audio normalization." @options 
            BP_REF_NORMALIZE_OPTIONS
        )
        BP_REF_ARG(@name "play" @default 0 @type "int" @description "autoplay rendered buffer.", @options
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "spread" @default 1 @type "int/float" @description "multichannel panning spread, between 0 and 1.")
        BP_REF_ARG(@name "fade" @default 5 @type "int/float" @description "fade in/out applied to every buffer, in milliseconds")
        BP_REF_ARG(@name "reset", @default 0 @type "int", @description "remove all previously transcribed buffers after rendering." @options
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "process" @default "null" @type "list/llll/null", @description "optional post-rendering audio processing operations.")
    )
    @output BP_REF_OUTPUT(@description "rendered buffer" @type "llll")
);

## ------------------------------------------------------------

scoreconfig = (
    $voicenames = "output",
    $clefs = "FFGG",
    $tonedivision = 8,
    $showdurations = 0,
    $showdynamics = 0,
    $midichannels = 1 -> (
        $config = for $clef in $clefs, $channel in $midichannels, $name in $voicenames with @iterationmode 1 collect (
            [ ($clef ||| "G") ($channel ||| 1) ($name ||| "output") ]
        );
        $numvoices = length($config);
        $config = trans($config);
        $clefs = $config::1;
        $midichannels = $config::2;
        $voicenames = $config::3;
        BP_SCORE_CONFIG = (
            [ "numvoices" $numvoices ]
            [ "clefs" $clefs ]
            [ "midichannels" $midichannels ]
            [ "voicenames" $voicenames ]
            [ 'showdurations' $showdurations ]
            [ 'tonedivision' $tonedivision ]
            [ 'showdynamics' $showdynamics ]
        );
        for $msg in BP_SCORE_CONFIG with @unwrap 1 do BP_FN_DISPATCH('roll', $msg);
        null
    )
);

BP_REF_NEW(
    @name "scoreconfig",
    @description "Configures the score appearance, such as the clefs, voice names, tone division, etc. See #transcribe.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "voicenames", @default "'output'" @type "list/symbol", @description "voice names.")
        BP_REF_ARG(@name "clefs", @default "'FFGG'" @type "list/symbol", @description "clef type for each voice, as a symbol." @options
            BP_REF_OPT(@value "'G'" @description "treble" "clef")
            BP_REF_OPT(@value "'F'" @description "bass" "clef")
            BP_REF_OPT(@value "'FG'" @description "grand" "staff")
            BP_REF_OPT(@value "'FFGG'" @description "full" "staff")
            BP_REF_OPT(@value "'FGG'" @description "bass" "+" "treble" "clef")
            BP_REF_OPT(@value "'FFG'" @description "double" "bass" "+" "treble" "clef")
            BP_REF_OPT(@value "'FF'" @description "double" "bass" "clef")
            BP_REF_OPT(@value "'GG'" @description "double" "treble" "clef")
            BP_REF_OPT(@value "'G8va'" @description "8va" "treble" "clef")
            BP_REF_OPT(@value "'G8vb'" @description "8vb" "treble" "clef")
            BP_REF_OPT(@value "'G15ma'" @description "15ma" "treble" "clef")
            BP_REF_OPT(@value "'G15mb'" @description "15mb" "treble" "clef")
            BP_REF_OPT(@value "'F8va'" @description "8va" "bass" "clef")
            BP_REF_OPT(@value "'F8vb'" @description "8vb" "bass" "clef")
            BP_REF_OPT(@value "'F15ma'" @description "15ma" "bass" "clef")
            BP_REF_OPT(@value "'F15mb'" @description "15mb" "bass" "clef")
            BP_REF_OPT(@value "'Tenor'" @description "tenor" "clef")
            BP_REF_OPT(@value "'Barytone'" @description "baritone" "clef")
            BP_REF_OPT(@value "'Alto'" @description "alto" "clef")
            BP_REF_OPT(@value "'Mezzo'" @description "mezzo" "clef")
            BP_REF_OPT(@value "'Soprano'" @description "soprano" "clef")
            BP_REF_OPT(@value "'Percussion'" @description "percussion" "clef")
        )
        BP_REF_ARG(@name "tonedivision", @default 8 @type "int", @description "symbolic tone division." @options
            BP_REF_OPT(@value 2 @description "semitones")
            BP_REF_OPT(@value 4 @description "quarter" "tones")
            BP_REF_OPT(@value 8 @description "eighth" "tones")
        )
        BP_REF_ARG(@name "showdurations", @default 0 @type "int", @description "show note durations as lines." @options
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "showdynamics" @default 0 @type "int" @description "show note dynamics based on buffer gain." @options
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "midichannels", @default 1 @type "int/list", @description "midichannel for each voice")
    )
);

## ------------------------------------------------------------

read = (
    $path,
    $ignore = 0 -> (
        $self = 'read';
        BP_FN_CHECK_ARGS($self, 'path', $path);
        BP_LLLL_READ = null;
        $info = BP_FN_PATHINFO($path @locate 1);
        if (".txt" ".llll").intersection($info."extension") == null then (
            BP_FN_ERROR($self, "invalid file extension")
        );
        $path = $info."path" + $info."extension";
        for $msg in ['ignore' $ignore] ['read' $path] with @unwrap 1 do (
            BP_FN_DISPATCH("llllio", "read" $msg)
        );
        BP_LLLL_READ
    )
);

BP_REF_NEW(
    @name "read",
    @description "Read .txt or native .llll data. The ignore attribute allows preventing some categories of symbols, such as parens, pitches and more, to be read according to the usual bell syntax.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "path", @type "symbol", @description "input file path.")
        BP_REF_ARG(@name "ignore" @default 0 @type "symbol/null" @description "The ignore attribute can be set to any combination of the following characters" @options 
            BP_REF_OPT(@value "'l'" @description "parens inside symbols are not llll levels, but symbols composed by parens only are kept as llll levels!")
            BP_REF_OPT(@value "'L'" @description "all parens are not parsed as llll levels")
            BP_REF_OPT(@value "'p'" @description "ignore pitches, keep them as symbols")
            BP_REF_OPT(@value "'r'" @description "ignore rationals, keep them as symbols")
            BP_REF_OPT(@value "'e'" @description "ignore floating-point scientific notation, keep it as symbol")
            BP_REF_OPT(@value "'s'" @description "keep the special symbols nil and null as symbols")
            BP_REF_OPT(@value "'b'" @description "symbols with a backtick are interpreted literally, with the backtick included")
            BP_REF_OPT(@value 0 @description "don't ignore anything")
            BP_REF_OPT(@value 1 @description "ignore everything")
            BP_REF_OPT(@value "'-'" @description "invert selection")
        )
    )
    @output BP_REF_OUTPUT(@description "file content" @type "anything")
);

## ------------------------------------------------------------

write = (
    $data = null,
    $path = null,
    $escape = 3,
    $wrap = 0,
    $indent = 'tab',
    $maxdecimals = 10,
    $maxdepth = -1,
    $negativeoctaves = 0,
    $parens = 0 -> (
        $self = 'write';
        BP_FN_CHECK_ARGS($self, 'data', $data, 'path', $path);
        $info = BP_FN_PATHINFO($path);
        if (".txt" ".llll").intersection($info."extension") == null then (
            BP_FN_ERROR($self, "invalid file extension for @path in write().")
        );
        if exists($info."parent") == 0 then (
            BP_FN_ERROR($self, "invalid destination directory:" $info."parent")
        );
        $ext = $info."extension";
        $path = $info."path" + $ext;
        $cmd = if $ext == ".txt" then "writetxt" else "write";
        BP_FN_DISPATCH("llllio", "write"
            [ "data" $data ]
            [ "config" 
                [ "escape" $escape ]
                [ "wrap" $wrap ]
                [ "indent" $indent ]
                [ "maxdecimals" $maxdecimals ]
                [ "maxdepth" $maxdepth ]
                [ "negativeoctaves" $negativeoctaves ]
                [ "parens" $parens ]
                [ $cmd $path ]
            ]
        );
        BP_LLLL_READ
    )
);

BP_REF_NEW(
    @name "write",
    @description "Writes data into disk in either .txt or native .llll format.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "data" @type "anything" @description "data to write.")
        BP_REF_ARG(@name "path" @type "symbol" @description "output file path.")
        BP_REF_ARG(@name "escape" @default 3 @type "int" @description "escaping style" @options 
            BP_REF_OPT(@value 0 @description "none")
            BP_REF_OPT(@value 1 @description "backtick")
            BP_REF_OPT(@value 2 @description "double" "quotes")
            BP_REF_OPT(@value 3 @description "smart")
        )
        BP_REF_ARG(@name "wrap" @default 0 @type "int" @description "column at which the text should be hard-wrapped in .txt format. 0 means no wrapping")
        BP_REF_ARG(@name "indent" @default "'tab'" @type "symbol/int" @description "if value is integer, number of spaces per depth level used for indentation.")
        BP_REF_ARG(@name "maxdecimals" @default 10 @type "int" @description "maximum number of decimal digits for .txt format.")
        BP_REF_ARG(@name "maxdepth" @default -1 @type "int" @description "maximum depth level at which text indentation is performed for .txt format.")
        BP_REF_ARG(@name "negativeoctaves" @default 0 @type "int" @description "use negative octaves, when in .txt format." @options 
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "parens" @default 0 @type "int" @description "use parens." @options 
            BP_REF_SWITCH_OPTIONS
        )
    )
);

## ------------------------------------------------------------

export = (
    $path, $stems = 0, $format = "float32", $vbrmode = "VBR", $bitrate = 0 -> (
        $self = 'export';
        BP_FN_CHECK_ARGS($self, 'path', $path);
        ## get path info
        $pathinfo = BP_FN_PATHINFO($path);
        $path = $pathinfo.'path';
        $ext = $pathinfo.'extension';
        $filepath = $path + $ext;

        ## check file type
        if $ext.intersection(BP_SUPPORTED_AUDIO_FORMATS) != null then (
            ## get audio format
            BP_FN_DISPATCH("audioexport", [ "settings" [ "format" $format ] [ "vbrmode" $vbrmode ] [ "bitrate" $bitrate ] ] ["mode" $stems != 0] $pathinfo )
        ) else if $ext == ".mid" || $ext == ".midi" then (
            BP_FN_DISPATCH("roll", "exportmidi" $filepath)
        ) else if $ext == ".llll" then (
            BP_FN_DISPATCH(
                'roll', 'dump' '@router' 'copy' 
            );
            write('roll' BP_TMP_ROLL_OUTPUT, $filepath)
        ) else (
            BP_FN_ERROR($self, "file format is not supported:" $ext)
        )
    )
);

BP_REF_NEW(
    @name "export",
    @description "Exports the rendered output as either an audio (.wav/aif/aiff/mp3), midi (.mid/midi), or roll (.llll) file, given a output path. For audio files, mono stem files can be separately exported with the @stems argument. See #render function.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "path", @type "symbol", @description "output file path.")
        BP_REF_ARG(@name "stems", @default 0 @type "int", @description "stem export mode for audio files." @options
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "format" @default "'float32'" @type "symbol", @description "sample format." @options 
            BP_REF_OPT(@value "'int8'")
            BP_REF_OPT(@value "'int16'")
            BP_REF_OPT(@value "'int24'")
            BP_REF_OPT(@value "'int32'")
            BP_REF_OPT(@value "'float32'")
            BP_REF_OPT(@value "'float64'")
            BP_REF_OPT(@value "'mulaw'")
            BP_REF_OPT(@value "'alaw'")
        )
        BP_REF_ARG(@name "vbrmode" @default "'VBR'" @type "symbol", @description "mp3 variable bitrate mode." @options 
            BP_REF_OPT(@value "'CBR'" @description 'constant' 'bitrate')
            BP_REF_OPT(@value "'VBR'" @description 'variable' 'bitrate')
            BP_REF_OPT(@value "'ABR'" @description 'average' 'bitrate')
        )
        BP_REF_ARG(@name "bitrate" @default 0 @type "int", @description "mp3 bitrate in kbps. If 0, uses default.")
    )
);

## ------------------------------------------------------------

importaudio = (
    $path, 
    $usecache = 1 -> (
        $self = 'importaudio';
        BP_FN_CHECK_ARGS($self, 'path', $path);
        $buffer = null;
        if $usecache == 1 then (
            $buffer = BP_BUFFER_CACHE.$path
        );
        if $buffer == null then (
            BP_TMP_BUFF = null;
            $pathinfo = BP_FN_PATHINFO($path @locate 1);
            $ext = $pathinfo."extension";
            $filepath = $pathinfo."path" + $ext;
            if $ext.intersection(BP_SUPPORTED_AUDIO_FORMATS) != null then (
                BP_FN_DISPATCH("import", [
                    "audio"
                    $filepath
                ])
            ) else (
                BP_FN_ERROR($self, if $ext == null then "you must provide a file path" else "invalid file extension:" $ext)
            );
            $buffer = BP_FN_NEWBUFF(@source BP_TMP_BUFF @extras [ "file" $filepath ]);
            if BP_BUFFER_CACHE.$path == null then BP_BUFFER_CACHE _= [$path $buffer]
        );
        $buffer
    )
);

BP_REF_NEW(
    @name "importaudio",
    @description "Imports an audio file (.wav/aif/aiff/mp3) as a buffer, given a file path.",
    @category BP_REF_LABEL_GEN,
    @arguments (
        BP_REF_ARG(@name "path", @type "symbol", @description "input audio file path.")
        BP_REF_USE_CACHE_ARG
    ),
    @output BP_REF_OUTPUT(@description "buffer" @type "llll")
);

## ------------------------------------------------------------

importmidi = (
    $path -> (
        $self = 'importmidi';
        BP_FN_CHECK_ARGS($self, 'path', $path);
        BP_TMP_ROLL_OUTPUT = null;
        $pathinfo = BP_FN_PATHINFO($path @locate 1);
        $ext = $pathinfo."extension";
        $path = $pathinfo."path";
        $filepath = $path + $ext;
        if $ext == ".midi" || $ext == ".mid" then (
            BP_FN_DISPATCH("import", [
                "roll"
                $filepath
            ])
        ) else (
            BP_FN_ERROR($self, if $ext == null then "you must provide a file path" else "invalid file extension:" $ext)
        );
        BP_TMP_ROLL_OUTPUT
    )
);

BP_REF_NEW(
    @name "importmidi",
    @description "Imports a midi file, as a list of events, each with the following keys: 'pitch' , 'velocity', 'onset', 'voice', 'channel', and 'duration'",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "path", @type "symbol", @description "input midi file path.")
    ),
    @output BP_REF_OUTPUT(@description "midi events" @type "llll")
);

## ------------------------------------------------------------

hanning = ($length = 16 -> ($length -= 1; sin((pi * (0...$length)) / $length) ** 2.));

BP_REF_NEW(
    @name "hanning",
    @description "Generates a hanning window as a numeric list.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "length", @type "int", @default 16, @description "window length.")
    ),
    @output BP_REF_OUTPUT(@description "hanning window" @type "list")
);

## ------------------------------------------------------------

#( 
    bach bpf slope implementation from: https://www.bachproject.net/forum/viewtopic.php?f=2&t=1208&p=4000#p3998 
    
    Curve function is
    y = t^((1+slope)/(1-slope))
    for positive slopes and
    y = 1-(1-t)^((1-slope)/(1+slope))
    for negative slopes.
)#
BP_FN_GET_BPF_INTERPOLATION_WEIGHT = (
    $t, $s -> (
        if $s >= 0 then (
            $t ** ((1 + $s) / (1 - $s)) 
        ) else (
            1 - (1 - $t) ** ((1 - $s) / (1 + $s)) 
        ) 
    ) 
);

samplebpf = (
    $bpf, $x -> (
        BP_FN_CHECK_ARGS('samplebpf', 'bpf', $bpf, 'x', $x);
        ## x-wise point sorting
        $bpf = $bpf.sort(
            @function $a, $b -> $a::(1 1) < $b::(1 1) 
        );
        ## create left-right point pairs
        $bpfpairs = $bpf.group(@modulos 2 @overlap 1);
        ## copy $x into $pts to use $x in loop
        $pts = $x;
        ## loop through each sampling point
        for $x in $pts collect (
            ## initialize sample with null
            $y = null;
            for $bpfpair in $bpfpairs as $y == null with @unwrap 1 do (
                ## left and right points
                $left = $bpfpair:1;
                $right = $bpfpair:2;
                ## left and right x values
                $lx = $left::(1 1);
                $rx = $right::(1 1);
                ## if sampling point falls within pair
                if $x >= $lx && $x <= $rx then (
                    ## left and right y points
                    $ly = $left::(1 2);
                    $ry = $right::(1 2);
                    ## slope
                    $s = $right::(1 3);
                    ## normalize x
                    $t = $x.scale($lx, $rx, 0, 1);
                    ## get interpolation weight
                    $w = BP_FN_GET_BPF_INTERPOLATION_WEIGHT($t, $s);
                    ## apply weights
                    $y = $ly * (1 - $w) + $ry * $w
                ) 
            );
            ## return sampled value
            $y
        ) 
    ) 
);

BP_REF_NEW(
    @name "samplebpf",
    @description "Samples an interpolated value from a breakpoint function, given a list of normalized indices. See #bpf function.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "bpf" @type "llll" @description "breakpoint function")
        BP_REF_ARG(@name "pts" @type "int/float/list" @description "sampling point/s")
    ),
    @output BP_REF_OUTPUT(@description "interpolated bpf values" @type "int/float/list")
);

## ------------------------------------------------------------

analyze = (
    $buffer, 
    $descriptors,
    $winstartfromzero = 0,
    $framesize = 512,
    $hopsize = 512,
    $numframes = "auto",
    $overlap = 1.,
    $wintype = 'hann',
    $winnormalized = 1,
    $envattack = 10,
    $envrelease = 100,
    $onsetdetectionmethod = 'complex',
    $peaksmaxnum = 100,
    $peaksorderby = 'complex',
    $peaksmagthresh = 0,
    $peaksmaxfreq = 5000,
    $peaksminfreq = 0,
    $summary = 3,
    $summaryweight = 1,
    $summarypositive = 0,
    $ampunit = 0,
    $antimeunit = 1,
    $envtimeunit = 0,
    $frequnit = 0,
    $pitchunit = 0,
    $timeunit = 0,
    $yinmaxfreq = 22050,
    $yinminfreq = 20,
    $yintolerance = 1,
    $frametime = 0,
    $bufinterp = 0 -> (
        $self = 'analyze';
        BP_FN_CHECK_ARGS('analyze', 'buffer', $buffer, 'descriptors', $descriptors);
        $source = BP_FN_VALIDATE_BUFFER($self, $buffer);
        BP_ESSENTIA_OUTPUT = null;
        $source = $buffer.process(bpthru()).getkey("source");
        BP_FN_DISPATCH("essentia",
            [ "buffer" $source ]
            [ "settings"
                "@winstartfromzero" $winstartfromzero
                "@framesize" $framesize
                "@hopsize" $hopsize
                "@numframes" $numframes
                "@overlap" $overlap
                "@wintype" $wintype
                "@winnormalized" $winnormalized
                "@envattack" $envattack
                "@envrelease" $envrelease
                "@onsetdetectionmethod" $onsetdetectionmethod
                "@peaksmaxnum" $peaksmaxnum
                "@peaksorderby" $peaksorderby
                "@peaksmagthresh" $peaksmagthresh
                "@peaksmaxfreq" $peaksmaxfreq
                "@peaksminfreq" $peaksminfreq
                "@summary" $summary
                "@summaryweight" $summaryweight
                "@summarypositive" $summarypositive
                "@ampunit" $ampunit
                "@antimeunit" $antimeunit
                "@envtimeunit" $envtimeunit
                "@frequnit" $frequnit
                "@pitchunit" $pitchunit
                "@timeunit" $timeunit
                "@yinmaxfreq" $yinmaxfreq
                "@yinminfreq" $yinminfreq
                "@yintolerance" $yintolerance
                "@bufinterp" $bufinterp
            ]
            [ "descriptors"
                $descriptors
                (if $frametime then BP_FN_ESSENTIA(@name 'frametime' @mode 1))
            ]
        );
        $features = for $x in BP_ESSENTIA_OUTPUT collect [ ($x::1).flat(1) ];
        for $descr in $descriptors do (
            $name = $descr.getkey("name");
            $lastchar = $name.getchar(-1);
            if $lastchar == '~' then (
                $outkeys = $descr.getkey("output");
                for $k in $outkeys do (
                    $features.$k = BP_FN_NEWBUFF(@source $features.$k).process(bpthru())
                )
            )
        );
        BP_FN_DISPATCH("essentia", [ "clear" "bang" ]);
        $buffer = [ $buffer.flat(1) $features ]
    )
);

BP_REF_NEW(
    @name "analyze",
    @description "Applies a sequence of audio analysis operations to the input buffer, via audio descriptors. These descriptors are generated through functions (e.g., see #flux, #dissonance, #spectrum), which contain the parameters for that specific audio analysis.",
    @category BP_REF_LABEL_ANALYSIS,
    @arguments (
        BP_REF_ARG(@name "buffer" @type "llll", @description "buffer to analyze.")
        BP_REF_ARG(@name "descriptors" @type "llll" @description "list of audio descriptors.")
        BP_REF_ARG(@name "winstartfromzero" @default 0 @type "int" @description "center first window at @framesize / 2 instead of 0." @options 
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "framesize" @default 2048 @type "int" @description "analysis frame size or window size.")
        BP_REF_ARG(@name "hopsize" @default 1024 @type "int" @description "analysis hop size.")
        BP_REF_ARG(@name "numframes" @default "'auto'" @type "int/symbol" @description "number of analysis frames." @options
            BP_REF_OPT(@value "'auto'" @description "infer from @framesize and @hopsize.")
            BP_REF_OPT(@value ">0" @description "ignores @hopsize.")
        )
        BP_REF_ARG(@name "overlap" @default 1 @type "int" @description "overlap factor between analysis window size and hop size.")
        BP_REF_ARG(@name "wintype" @default "'hann'" @type "int" @description "window type" @options
            BP_REF_WINDOW_OPTIONS
        )
        BP_REF_ARG(@name "winnormalized" @default 1 @type "int" @description "normalize analysis windows to have an area of 1 and then scaled by a factor of 2.")
        BP_REF_ARG(@name "envattack" @default 10 @type "int/float" @description "attack time for computing envelopes.")
        BP_REF_ARG(@name "envrelease" @default 100 @type "int" @description "release time for computing envelopes.")
        BP_REF_ARG(@name "onsetdetectionmethod" @default "'complex'" @type "symbol" @description "onset detection method." @options
            BP_REF_ESSENTIA_ONSET_METHOD
        )
        BP_REF_ARG(@name "peaksmaxnum" @default 100 @type "int" @description "maximum number of peaks for peaks analyis.")
        BP_REF_ARG(@name "peaksorderby" @default "'complex'" @type "symbol" @description "ordering method of the peaks in the peaks analysis." @options 
            BP_REF_ESSENTIA_ONSET_METHOD
        )
        BP_REF_ARG(@name "peaksmagthresh" @default 0 @type "int/float" @description "magnitude threshold for the peaks analyis.")
        BP_REF_ARG(@name "peaksmaxfreq" @default 5000 @type "int/float" @description "maximum frequency for the peaks analyis.")
        BP_REF_ARG(@name "peaksminfreq" @default 0 @type "int/float" @description "minimum frequency for the peaks analyis.")
        BP_REF_ARG(@name "summary" @default 3 @type "int" @description "summarization mode, for global analyses that are computed on a frame-by-frame basis." @options 
            BP_REF_OPT(@value 0 @description "use" "first" "frame.")
            BP_REF_OPT(@value 1 @description "use" "last" "frame.")
            BP_REF_OPT(@value 2 @description "use" "middle" "frame.")
            BP_REF_OPT(@value 3 @description "average" "through" "frames.")
            BP_REF_OPT(@value 4 @description "median" "through" "frames.")
            BP_REF_OPT(@value 5 @description "mode" "through" "frames.")
        )
        BP_REF_ARG(@name "summaryweight" @default 1 @type "int" @description "summarization weight, when @summary is 4." @options 
            BP_REF_OPT(@value 0 @description "none.")
            BP_REF_OPT(@value 1 @description "rms.")
            BP_REF_OPT(@value 2 @description "loudness.")
        )
        BP_REF_ARG(@name "summarypositive" @default 0 @type "int" @description "only summarize with positive values." @options
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "ampunit" @default 0 @type "int" @description "amplitude unit" @options
            BP_REF_AMPUNIT_OPTIONS
        )
        BP_REF_ARG(@name "antimeunit" @default 1 @type "int" @description "analysis time unit" @options
            BP_REF_ANTIMEUNIT_OPTIONS
        )
        BP_REF_ARG(@name "envtimeunit" @default 0 @type "int" @description "envelope time unit" @options
            BP_REF_TIMEUNIT_OPTIONS
        )
        BP_REF_ARG(@name "frequnit" @default 0 @type "int" @description "frequency unit" @options 
            BP_REF_FREQUNIT_OPTIONS   
        )
        BP_REF_ARG(@name "pitchunit" @default 0 @type "int" @description "pitch unit" @options 
            BP_REF_PITCHUNIT_OPTIONS
        )
        BP_REF_ARG(@name "timeunit" @default 0 @type "int" @description "time unit"
            BP_REF_TIMEUNIT_OPTIONS
        )
        BP_REF_ARG(@name "yinmaxfreq" @default 22050 @type "int/float" @description "maximum frequency for the YIN analysis.")
        BP_REF_ARG(@name "yinminfreq" @default 20 @type "int/float" @description "minimum frequency for the YIN analysis.")
        BP_REF_ARG(@name "yintolerance" @default 1 @type "int/float" @description "tolerance for the YIN analysis.")
        BP_REF_ARG(@name "frametime" @default 0 @type "int" @description "retrieve analysis window time positions as a separate feature." @options
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "bufinterp" @default 0 @type "int" @description "interpolation mode" @options 
            BP_REF_OPT(@value 0 @description "no" "interpolation")
            BP_REF_OPT(@value 1 @description "lower" "neighbor")
            BP_REF_OPT(@value 2 @description "linear")
        )
    ),
    @output BP_REF_OUTPUT(@description "analyzed buffer" @type "llll")
);

## ------------------------------------------------------------

BP_FN_ESSENTIA = (
    $name,
    $settings = null,
    $output,
    $mode = 0,
    $modes = 0...3 -> (
        $mode = intersection($mode, $modes);
        if $mode == null then (
            BP_FN_ERROR($name, "invalid value for @mode. available modes:" $modes)
        ) else (
            $mode = ("" "..." ":::" "~"):($mode + 1);
            [ 
                [ "name" $name + $mode ] 
                [ "settings" 
                    $settings
                ] 
                [ "output" $output ||| $name ] 
            ]
        )
    )
);

## ------------------------------------------------------------

effectiveduration = (
    $thresholdratio = 0.02,
    $samplerate = 44100 -> (
        BP_FN_ESSENTIA(
            @name "effectiveduration"
            @settings (
                "@samplerate" $samplerate
                "@thresholdratio" $thresholdratio
            )
        )
    )
);

BP_REF_NEW(
    @name "effectiveduration",
    @description "Audio descriptor to compute the effective duration of an envelope signal. The effective duration is a measure of the time the signal is perceptually meaningful. This is approximated by the time the envelope is above or equal to a given threshold and is above the -90db noise floor. This measure allows to distinguish percussive sounds from sustained sounds but depends on the signal length. By default, this algorithm uses 40% of the envelope maximum as the threshold which is suited for short sounds. Note, that the 0% thresold corresponds to the duration of signal above -90db noise floor, while the 100% thresold corresponds to the number of times the envelope takes its maximum value. See #analyze.",
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        BP_REF_ARG(@name "thresholdratio" @default 0.02 @type "int/float" @description "ratio of the envelope maximum to be used as the threshold.")
        BP_REF_ARG(@name "samplerate" @default 44100 @type "int" @description "sampling rate.")
    )
    @output BP_REF_OUTPUT(@description "effectiveduration descriptor" @type "llll")
);

## ------------------------------------------------------------

envmaxtime = ( -> BP_FN_ESSENTIA(@name "envmaxtime"));

BP_REF_NEW(
    @name "envmaxtime",
    @description "Audio descriptor to extract the time at which the global maxima of the buffer's envelope occurs. See #analyze.",
    @category BP_REF_LABEL_ANALYSIS,
    @output BP_REF_OUTPUT(@description "envmaxtime descriptor" @type "llll")
);

## ------------------------------------------------------------

envmintime = ( -> BP_FN_ESSENTIA(@name "envmintime"));

BP_REF_NEW(
    @name "envmintime",
    @description "Audio descriptor to extract the time at which the global minima of the buffer's envelope occurs. See #analyze.",
    @category BP_REF_LABEL_ANALYSIS,
    @output BP_REF_OUTPUT(@description "envmintime descriptor" @type "llll")
);

## ------------------------------------------------------------

pitchyin = ( 
    $framesize = 2048,
    $interpolate = 1,
    $maxfrequency = 22050,
    $minfrequency = 20,
    $samplerate = 44100,
    $tolerance = 0.15,
    $mode = 0 -> (
        BP_FN_ESSENTIA(
            @name "pitchyin"
            @settings (
                "@framesize" $framesize
                "@interpolate" $interpolate
                "@maxfrequency" $maxfrequency
                "@minfrequency" $minfrequency
                "@samplerate" $samplerate
                "@tolerance" $tolerance
            )
            @output "pitchyin" "pitchyin_confidence"
            @mode $mode
        )
    )
);

BP_REF_NEW(
    @name "pitchyin",
    @description "Audio descriptor to estimate the fundamental frequency of a monophonic buffer. It is an implementation of the Yin algorithm for computations in the time domain. See #analyze.",
    @category BP_REF_LABEL_ANALYSIS
    @ankeys "pitchyin" "pitchyin_confidence"
    @arguments (
        BP_REF_ARG(@name "framesize" @default 2048 @type "int" @description "number of samples in the input frame.")
        BP_REF_ARG(@name "interpolate" @default 1 @type "int" @description "enable interpolation." @options 
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "maxfrequency" @default 22050 @type "int/float" @description "the maximum allowed frequency.")
        BP_REF_ARG(@name "minfrequency" @default 20 @type "int/float" @description "the minimum allowed frequency.")
        BP_REF_ARG(@name "samplerate" @default 44100 @type "int" @description "sampling rate of the input audio.")
        BP_REF_ARG(@name "tolerance" @default 0.15 @type "int/float" @description "tolerance for peak detection.")
        BP_REF_ARG(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "pitchyin descriptor" @type "llll")
);

## ------------------------------------------------------------

## BUGGY
## snr = ( 
##     $maalpha = 0.95,
##     $mmsealpha = 0.98,
##     $noisealpha = 0.9,
##     $framesize = 512,
##     $noisethreshold = 0.01,
##     $samplerate = 44100,
##     $usebroadbadnoisecorrection = 1,
##     $mode = 0 -> (
##         BP_FN_ESSENTIA(
##             @name "snr"
##             @settings (
##                 "@maalpha" $maalpha
##                 "@mmsealpha" $mmsealpha
##                 "@noisealpha" $noisealpha
##                 "@framesize" $framesize
##                 "@noisethreshold" $noisethreshold
##                 "@samplerate" $samplerate
##                 "@usebroadbadnoisecorrection" $usebroadbadnoisecorrection
##             )
##             @mode $mode
##         )
##     )
## );

## BP_REF_NEW(
##     @name "snr",
##     @description "Audio descriptor to compute the signal-to-noise ratio for a buffer in a frame-wise manner. The algorithm assumes that the noise is gaussian and that there is a region of noise, without signal, at the beginning of the buffer in order to estimate the power spectral density of the noise. See #analyze.",
##     @category BP_REF_LABEL_ANALYSIS,
##     @arguments (
##         BP_REF_ARG(@name "maalpha" @default 0.95 @type "int/float" @description "alpha coefficient for the EMA SNR estimation.")
##         BP_REF_ARG(@name "mmsealpha" @default 0.98 @type "int/float" @description "alpha coefficient for the MMSE estimation.")
##         BP_REF_ARG(@name "noisealpha" @default 0.9 @type "int/float" @description "alpha coefficient for the EMA noise estimation.")
##         BP_REF_ARG(@name "framesize" @default 512 @type "int" @description "size of the input frame.")
##         BP_REF_ARG(@name "noisethreshold" @default 0.01 @type "int/float" @description "threshold to detect frames without signal.")
##         BP_REF_ARG(@name "samplerate" @default 44100 @type "int" @description "sampling rate of the audio signal.")
##         BP_REF_ARG(@name "usebroadbadnoisecorrection" @default 1 @type "int" @description "flag to apply the broadband noise correction factor." @options 
##             BP_REF_SWITCH_OPTIONS
##         )
##     )
##     @output BP_REF_OUTPUT(@description "snr descriptor" @type "llll")
## );

## ------------------------------------------------------------

spectralkurtosis = (
    $mode = 0 -> (
        BP_FN_ESSENTIA(
            @name "spectralkurtosis"
            @mode $mode
            @modes 0...2
        )
    )
);

BP_REF_NEW(
    @name "spectralkurtosis"
    @description "Audio descriptor to compute the spectral kurtosis of a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @anmodes 0...2
    @arguments (
        BP_REF_ARG(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "spectralkurtosis descriptor" @type "llll")
);

## ------------------------------------------------------------

temporalkurtosis = ( -> BP_FN_ESSENTIA(@name "temporalkurtosis"));

BP_REF_NEW(
    @name "temporalkurtosis"
    @description "Audio descriptor to compute the temporal kurtosis of a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @output BP_REF_OUTPUT(@description "temporalkurtosis descriptor" @type "llll")
);

## ------------------------------------------------------------

spectralskewness = (
    $mode = 0 -> (
        BP_FN_ESSENTIA(
            @name "spectralskewness"
            @mode $mode
        )
    )
);

BP_REF_NEW(
    @name "spectralskewness"
    @description "Audio descriptor to compute the spectral skewness of a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        BP_REF_ARG(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "spectralskewness descriptor" @type "llll")
);

## ------------------------------------------------------------

temporalskewness = ( -> BP_FN_ESSENTIA(@name "temporalskewness"));

BP_REF_NEW(
    @name "temporalskewness"
    @description "Audio descriptor to compute the temporal skewness of a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @output BP_REF_OUTPUT(@description "temporalskewness descriptor" @type "llll")
);

## ------------------------------------------------------------

spectralspread = (
    $mode = 0 -> (
        BP_FN_ESSENTIA(
            @name "spectralspread"
            @mode $mode
        )
    )
);

BP_REF_NEW(
    @name "spectralspread"
    @description "Audio descriptor to compute the spectral spread of a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        BP_REF_ARG(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "spectralspread descriptor" @type "llll")
);

## ------------------------------------------------------------

temporalspread = ( -> BP_FN_ESSENTIA(@name "temporalspread"));

BP_REF_NEW(
    @name "temporalspread"
    @description "Audio descriptor to compute the temporal spread of a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @output BP_REF_OUTPUT(@description "temporalspread descriptor" @type "llll")
);

## ------------------------------------------------------------

spectralvariance = (
    $mode = 0 -> (
        BP_FN_ESSENTIA(
            @name "spectralvariance"
            @mode $mode
        )
    )
);

BP_REF_NEW(
    @name "spectralvariance"
    @description "Audio descriptor to compute the spectral variance of a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        BP_REF_ARG(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "spectralvariance descriptor" @type "llll")
);

## ------------------------------------------------------------

temporalvariance = ( -> BP_FN_ESSENTIA(@name "temporalvariance"));

BP_REF_NEW(
    @name "temporalvariance"
    @description "Audio descriptor to compute the temporal variance of a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @output BP_REF_OUTPUT(@description "temporalvariance descriptor" @type "llll")
);

## ------------------------------------------------------------

energy = (
    $mode = 0 -> (
        BP_FN_ESSENTIA(
            @name "energy"
            @mode $mode
        )
    )
);

BP_REF_NEW(
    @name "energy"
    @description "Audio descriptor to compute the energy of a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        BP_REF_ARG(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "energy descriptor" @type "llll")
);

## ------------------------------------------------------------

energyband = (
    $startcutofffrequency = 0,
    $stopcutofffrequency = 100,
    $samplerate = 44100,
    $mode = 0 -> (
        BP_FN_ESSENTIA(
            @name "energyband"
            @settings (
                "@startcutofffrequency" $startcutofffrequency
                "@stopcutofffrequency" $stopcutofffrequency
                "@samplerate" $samplerate
            )
            @mode $mode
        )
    )
);

BP_REF_NEW(
    @name "energyband"
    @description "Audio descriptor to compute energy in a given frequency band of a spectrum including both start and stop cutoff frequencies. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        BP_REF_ARG(@name "startcutofffrequency" @type "int" @default 0 @description "start frequency from which to sum the energy.")
        BP_REF_ARG(@name "stopcutofffrequency" @type "int" @default 100 @description "stop frequency to which to sum the energy.")
        BP_REF_ARG(@name "samplerate" @type "int" @default 44100 @description "audio sampling rate.")
        BP_REF_ARG(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "energyband descriptor" @type "llll")
);

## ------------------------------------------------------------

dissonance = ($mode = 0 -> BP_FN_ESSENTIA(@name "dissonance" @mode $mode));

BP_REF_NEW(
    @name "dissonance"
    @description "Audio descriptor to compute the sensory dissonance of a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        BP_REF_ARG(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "dissonance descriptor" @type "llll")
);

## ------------------------------------------------------------

strongpeak = ($mode = 0 -> BP_FN_ESSENTIA(@name "strongpeak" @mode $mode));

BP_REF_NEW(
    @name "strongpeak"
    @description "Audio descriptor to compute the strong peak of a buffer, defined as the ratio between the spectrum's maximum peak's magnitude and the 'bandwidth' of the peak above a threshold — i.e., half its amplitude. This ratio reveals whether the spectrum presents a very 'pronounced' maximum peak — i.e., the thinner and the higher the maximum of the spectrum is, the higher the ratio value. Note that 'bandwidth' is defined as the width of the peak in the log10-frequency domain. Using the log10-frequency domain allows this algorithm to compare strong peaks at lower frequencies with those from higher frequencies. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        BP_REF_ARG(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "strongpeak descriptor" @type "llll")
);

## ------------------------------------------------------------

inharmonicity = ($mode = 0 -> BP_FN_ESSENTIA(@name "inharmonicity" @mode $mode));

BP_REF_NEW(
    @name "inharmonicity"
    @description "Audio descriptor to calculate the inharmonicity of a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        BP_REF_ARG(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "inharmonicity descriptor" @type "llll")
);

## ------------------------------------------------------------

zerocrossingrate = (
    $threshold = 0,
    $mode = 0 -> (
        BP_FN_ESSENTIA(
            @name "zerocrossingrate" 
            @mode $mode
            @settings (
                "@threshold" $threshold
            )
        )
    )
);

BP_REF_NEW(
    @name "zerocrossingrate"
    @description "Audio descriptor to compute the zero-crossing rate of a buffer, defined as the number of sign changes between consecutive signal values divided by the total number of values. Noisy signals tend to have higher zero-crossing rate. In order to avoid small variations around zero caused by noise, a threshold around zero is given to consider a valid zerocrosing whenever the boundary is crossed. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        BP_REF_ARG(@name "threshold" @default 0 @type "int/float" @description "the threshold which will be taken as the zero axis in both positive and negative sign.")
        BP_REF_ARG(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "zerocrossingrate descriptor" @type "llll")
);

## ------------------------------------------------------------

strongdecay = ( -> BP_FN_ESSENTIA(@name "strongdecay"));

BP_REF_NEW(
    @name "strongdecay"
    @description "Audio descriptor to compute the strong decay of a buffer. The strong decay is built from the non-linear combination of the signal energy and the signal temporal centroid, the latter being the balance of the absolute value of the signal. A signal containing a temporal centroid near its start boundary and a strong energy is said to have a strong decay. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        BP_REF_ARG(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "strongdecay descriptor" @type "llll")
);

## ------------------------------------------------------------

## BUGGY
## harmonicpeaks = (
##     $maxharmonics = 20,
##     $tolerance = 0.2,
##     $mode = 0 -> (
##         BP_FN_ESSENTIA(
##             @name "harmonicpeaks" 
##             @mode $mode
##             @settings (
##                 "@maxharmonics" $maxharmonics
##                 "@tolerance" $tolerance
##             )
##         )
##     )
## );

## ------------------------------------------------------------

spectrum = (
    $size = 2048,
    $mode = 0 -> (
        BP_FN_ESSENTIA(
            @name "spectrum" 
            @mode $mode
            @settings "@size" $size
        )
    )
);

BP_REF_NEW(
    @name "spectrum"
    @description "Audio descriptor to compute the magnitude spectrum of a buffer. The resulting magnitude spectrum has a size which is half the size of the input array plus one. Bins contain raw (linear) magnitude values. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        BP_REF_ARG(@name "size" @default 2048 @type "int", @description "frame size.")
        BP_REF_ARG(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "spectrum descriptor" @type "llll")
);

## ------------------------------------------------------------

rhythm = (
    $maxtempo = 208,
    $mintempo = 40,
    $method = 'multifeature' -> (
        BP_FN_ESSENTIA(
            @name "rhythmextractor2013" 
            @settings (
                "@maxtempo" $maxtempo
                "@method" $method
                "@mintempo" $mintempo
            )
            @output (
                "rhythm_bpm"
                "rhythm_ticks"
                "rhythm_estimates"
                "rhythm_intervals"
            )
        )
    )
);

BP_REF_NEW(
    @name "rhythm"
    @description "Audio descriptor for extract the beat positions and estimate their confidence as well as tempo in bpm for a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @ankeys "rhythm_bpm" "rhythm_ticks" "rhythm_estimates" "rhythm_intervals"
    @arguments (
        BP_REF_ARG(@name "maxtempo" @default 208 @type "int", @description "fastest tempo to detect, between 60 and 250.")
        BP_REF_ARG(@name "mintempo" @default 40 @type "int", @description "slowest tempo to detect, between 40 and 180.")
        BP_REF_ARG(@name "method" @default "'multifeature'" @type "symbol", @description "method used for beat tracking." @options
            BP_REF_OPT(@value "'degara'" @description "degara" "method")
            BP_REF_OPT(@value "'multifeature'" @description "multifeature" "method")
        )
    )
    @output BP_REF_OUTPUT(@description "rhythm descriptor" @type "llll")
);

## ------------------------------------------------------------

logattack = ( -> BP_FN_ESSENTIA(
        @name "logattacktime"
        @output (
            "logattack"
            "logattack_start"
            "logattack_stop"
        )
    )
);

BP_REF_NEW(
    @name "logattack"
    @description "Audio descriptor to compute the log (base 10) of the attack time of buffer's envelope. The attack time is defined as the time duration from when the sound becomes perceptually audible to when it reaches its maximum intensity. By default, the start of the attack is estimated as the point where the signal envelope reaches 20% of its maximum value in order to account for possible noise presence. Also by default, the end of the attack is estimated as as the point where the signal envelope has reached 90% of its maximum value, in order to account for the possibility that the max value occurres after the log-attack, as in trumpet sounds. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @ankeys "logattack" "logattack_start" "logattack_stop"
    @output BP_REF_OUTPUT(@description "logattack descriptor" @type "llll")
);

## ------------------------------------------------------------

chordsdetection = (
    $mode = 0 -> ( 
        BP_FN_ESSENTIA(
            @name "chordsdetection"
            @mode $mode
            @modes 0...2
        )
    )
);

BP_REF_NEW(
    @name "chordsdetection"
    @description "Audio descriptor to perform chord estimation on a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @anmodes 0...2
    @arguments (
        BP_REF_ARG(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "chordsdetection descriptor" @type "llll")
);

## ------------------------------------------------------------

pitchmelodia = (
    $binresolution = 10,
    $filteriterations = 3,
    $framesize = 2048,
    $guessunvoiced = 0,
    $harmonicweight = 0.8,
    $hopsize = 1024,
    $magnitudecompression = 1,
    $magnitudethreshold = 40,
    $maxfrequency = 20000,
    $minduration = 50,
    $minfrequency = 40,
    $numberharmonics = 20,
    $peakdistributionthreshold = 0.9,
    $peakframethreshold = 0.9,
    $pitchcontinuity = 27.5625,
    $referencefrequency = 55,
    $samplerate = 44100,
    $timecontinuity = 100,
    $polyphonic = 0,
    $mode = 0 -> ( 
        BP_FN_ESSENTIA(
            @name (if $polyphonic == 0 then "pitchmelodia" else "predominantpitchmelodia")
            @output "pitchmelodia" "pitchmelodia_confidence"
            @settings (
                "@binresolution" $binresolution
                "@filteriterations" $filteriterations
                "@framesize" $framesize
                "@guessunvoiced" $guessunvoiced
                "@harmonicweight" $harmonicweight
                "@hopsize" $hopsize
                "@magnitudecompression" $magnitudecompression
                "@magnitudethreshold" $magnitudethreshold
                "@maxfrequency" $maxfrequency
                "@minduration" $minduration
                "@minfrequency" $minfrequency
                "@numberharmonics" $numberharmonics
                "@peakdistributionthreshold" $peakdistributionthreshold
                "@peakframethreshold" $peakframethreshold
                "@pitchcontinuity" $pitchcontinuity
                "@referencefrequency" $referencefrequency
                "@samplerate" $samplerate
                "@timecontinuity" $timecontinuity
            )
            @mode $mode
        )
    )
);

BP_REF_NEW(
    @name "pitchmelodia"
    @description "Audio descriptor to estimate the fundamental frequency corresponding to the melody of a monophonic music signal based on the MELODIA algorithm. While the algorithm is originally designed to extract the predominant melody from polyphonic music, this implementation is adapted for monophonic signals. The approach is based on the creation and characterization of pitch contours, time continuous sequences of pitch candidates grouped using auditory streaming cues. It is strongly advised to use the default parameter values which are optimized for this task, except for @minfrequency and @maxfrequency, which will be context-dependent. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @ankeys "pitchmelodia" "pitchmelodia_confidence"
    @arguments (
        BP_REF_ARG(@name "binresolution" @default 10 @type "int" @description "salience function bin resolution, in cents.")
        BP_REF_ARG(@name "filteriterations" @default 3 @type "int" @description "number of iterations for the octave errors / pitch outlier filtering process.")
        BP_REF_ARG(@name "framesize" @default 2048 @type "int" @description "frame size for computing pitch salience.")
        BP_REF_ARG(@name "guessunvoiced" @default 0 @type "int" @description "estimate pitch for non-voiced segments." @options
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "harmonicweight" @default 0.8 @type "int/float" @description "weight decay ratio between two consequent harmonics. Use 1 for no decay.")
        BP_REF_ARG(@name "hopsize" @default 1024 @type "int" @description "hop size with which the pitch salience function was computed.")
        BP_REF_ARG(@name "magnitudecompression" @default 1 @type "int" @description "magnitude compression parameter for the salience function." @options
            BP_REF_OPT(@value 0 @description "maximum compression")
            BP_REF_OPT(@value 1 @description "no compression")
        )
        BP_REF_ARG(@name "magnitudethreshold" @default 40 @type "int" @description "spectral peak magnitude threshold, in decibels.")
        BP_REF_ARG(@name "maxfrequency" @default 20000 @type "int/float" @description "the maximum allowed frequency for salience function peaks.")
        BP_REF_ARG(@name "minduration" @default 100 @type "int" @description "the minimum allowed contour duration.")
        BP_REF_ARG(@name "minfrequency" @default 40 @type "int/float" @description "the minimum allowed frequency for salience function peaks.")
        BP_REF_ARG(@name "numberharmonics" @default 20 @type "int" @description "number of considered harmonics.")
        BP_REF_ARG(@name "peakdistributionthreshold" @default 0.9 @type "int/float" @description "allowed deviation below the peak salience mean over all frames.")
        BP_REF_ARG(@name "peakframethreshold" @default 0.9 @type "int/float" @description "per-frame salience threshold factor.")
        BP_REF_ARG(@name "pitchcontinuity" @default 27.5625 @type "int/float" @description "maximum allowed pitch change during 1 ms time period, in cents.")
        BP_REF_ARG(@name "referencefrequency" @default 55 @type "int/float" @description "the reference frequency to cent conversion corresponding to the 0th cent bin.")
        BP_REF_ARG(@name "samplerate" @default 44100 @type "int" @description "the sampling rate of the audio signal.")
        BP_REF_ARG(@name "timecontinuity" @default 100 @type "int" @description "maximum allowed gap duration for a pitch contour, in milliseconds.")
        BP_REF_ARG(@name "polyphonic" @default 0 @type "int" @description "optimize for polyphonic buffer." @options 
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "voicevibrato" @default 0 @type 'int' @description "detect voice vibrato, when @polyphonic is 1." @options 
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "voicingtolerance" @default 0.2 @type 'int/float' @description "voicing tolerance between -1 and 1.4, when @polyphonic is 1.")
        BP_REF_ARG(@name "mode" @default 0 @type "int" @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "pitchmelodia descriptor" @type "llll")
);

## ------------------------------------------------------------

mfcc = (
    $dcttype = 2,
    $highfrequencybound = 11000,
    $inputsize = 1025,
    $liftering = 0,
    $logtype = 'dbamp',
    $lowfrequencybound = 0,
    $normalize = 'unit_sum',
    $numberbands = 40,
    $numbercoefficients = 13,
    $samplerate = 44100,
    $silencethreshold = 1e-10,
    $type = 'power',
    $warpingformula = 'htkmel',
    $weighting = 'warping',
    $mode = 0 -> (
        BP_FN_ESSENTIA(
            @name "mfcc"
            @settings (      
                "@dcttype" $dcttype
                "@highfrequencybound" $highfrequencybound
                "@inputsize" $inputsize
                "@liftering" $liftering
                "@logtype" $logtype
                "@lowfrequencybound" $lowfrequencybound
                "@normalize" $normalize
                "@numberbands" $numberbands
                "@numbercoefficients" $numbercoefficients
                "@samplerate" $samplerate
                "@silencethreshold" $silencethreshold
                "@type" $type
                "@warpingformula" $warpingformula
                "@weighting" $weighting
            )
            @output "mfcc_bands" "mfcc"
            @mode $mode
        )
    )
);

BP_REF_NEW(
    @name "mfcc"
    @description "Audio descriptor to compute the mel-frequency cepstrum coefficients of a buffer's spectrum. As there is no standard implementation, the MFCC-FB40 is used by default. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @ankeys "mfcc_bands" "mfcc"
    @arguments (
        BP_REF_ARG(@name "dcttype" @default 2 @type "int" @description "DCT type.")
        BP_REF_ARG(@name "highfrequencybound" @default 11000 @type "int/float" @description "upper bound of the frequency range, in Hz.")
        BP_REF_ARG(@name "inputsize" @default 1025 @type "int" @description "size of input spectrum.")
        BP_REF_ARG(@name "liftering" @default 0 @type "int" @description "liftering coefficient. Use '0' to bypass it.")
        BP_REF_ARG(@name "logtype" @default "'dbamp'" @type "symbol" @description "logarithmic compression type." @options 
            BP_REF_OPT(@value "'natural'")
            BP_REF_OPT(@value "'dbpow'")
            BP_REF_OPT(@value "'dbamp'")
            BP_REF_OPT(@value "'log'")
        )
        BP_REF_ARG(@name "lowfrequencybound" @default 0 @type "float" @description "lower bound of the frequency range, in Hz.")
        BP_REF_ARG(@name "normalize" @default "'unit_sum'" @type "symbol" @description "spectrum bin weights to use for each mel band." @options 
            BP_REF_OPT(@value "'unit_sum'")
            BP_REF_OPT(@value "'unit_tri'")
            BP_REF_OPT(@value "'unit_max'")
        )
        BP_REF_ARG(@name "numberbands" @default 40 @type "int" @description "number of mel-bands in the filter.")
        BP_REF_ARG(@name "numbercoefficients" @default 13 @type "int" @description "number of output mel coefficients.")
        BP_REF_ARG(@name "samplerate" @default 44100 @type "int" @description "sampling rate of the audio signal, in Hz.")
        BP_REF_ARG(@name "silencethreshold" @default 1e-10 @type "int/float" @description "silence threshold for computing log-energy bands.")
        BP_REF_ARG(@name "type" @default "'power'" @type "symbol" @description "use magnitude or power spectrum." @options 
            BP_REF_OPT(@value "'magnitude'")
            BP_REF_OPT(@value "'power'")
        )
        BP_REF_ARG(@name "warpingformula" @default "'htkmel'" @type "symbol" @description "scale implementation type." @options 
            BP_REF_OPT(@value "'slaneymel'")
            BP_REF_OPT(@value "'htkmel'")
        )
        BP_REF_ARG(@name "weighting" @default "'warping'" @type "symbol" @description "type of weighting function for determining triangle area." @options
            BP_REF_OPT(@value "'warping'")
            BP_REF_OPT(@value "'linear'")
        )
        BP_REF_ARG(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "mfcc descriptor" @type "llll")
);

## ------------------------------------------------------------

flux = (
    $halfrectify = 0,
    $norm = "L2",
    $mode = 0 -> ( 
        BP_FN_ESSENTIA(
            @name "flux"
            @settings (
                "@halfrectify" $halfrectify
                "@norm" $norm
            )
            @mode $mode
        )
    )
);

BP_REF_NEW(
    @name "flux"
    @description "Audio descriptor to compute the spectral flux of a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        BP_REF_ARG(@name "halfrectify" @default 0 @type "int", @description "half-rectify the differences in each spectrum bin." @options
            BP_REF_SWITCH_OPTIONS    
        )
        BP_REF_ARG(@name "norm" @default "'L2'" @type "symbol", @description "norm to use for difference computation." @options 
            BP_REF_OPT(@value "'L1'" @description "L1 norm")
            BP_REF_OPT(@value "'L2'" @description "L2 norm")
        )
        BP_REF_ARG(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "flux descriptor" @type "llll")
);

## ------------------------------------------------------------

larm = (
    $attacktime = 10,
    $power = 1.5,
    $releasetime = 1500,
    $samplerate = 44100,
    $mode = 0 -> ( 
        BP_FN_ESSENTIA(
            @name "larm"
            @mode $mode
            @settings (
                "@attacktime" $attacktime
                "@power" $power
                "@releasetime" $releasetime
                "@samplerate" $samplerate
            )
        )
    )
);

BP_REF_NEW(
    @name "larm"
    @description "Audio descriptor to estimate the long-term loudness of a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        BP_REF_ARG(@name "attacktime" @default 10 @type "int" @description "attack time of the first order lowpass in the attack phase.")
        BP_REF_ARG(@name "power" @default 1.5 @type "int/float" @description "power used for averaging.")
        BP_REF_ARG(@name "releasetime" @default 1500 @type "int" @description "release time of the first order lowpass in the release phase.")
        BP_REF_ARG(@name "samplerate" @default 44100 @type "int" @description "sampling rate.")
        BP_REF_ARG(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "larm descriptor" @type "llll")
);

## ------------------------------------------------------------

spectralcentroid = (
    $mode = 0 -> ( 
        BP_FN_ESSENTIA(
            @name "spectralcentroid"
            @mode $mode
        )
    )
);

BP_REF_NEW(
    @name "spectralcentroid"
    @description "Audio descriptor to calculate the spectral centroid of a buffer, defined as the 'center of mass' of the spectrum, in Hertz. Perceptually, it has a robust connection with the impression of 'brightness' of a sound, and therefore is used to characterize musical timbre. It is calculated as the weighted mean of the frequencies present in the signal, with their magnitudes as the weights. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        BP_REF_ARG(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "spectralcentroid descriptor" @type "llll")
);

## ------------------------------------------------------------

temporalcentroid = ( 
    -> ( 
        BP_FN_ESSENTIA(
            @name "temporalcentroid"
        )
    )
);

BP_REF_NEW(
    @name "temporalcentroid"
    @description "Audio descriptor to calculate the temporal centroid of a buffer, defined as the point in time that is a temporal balancing point of the sound's energy. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
    )
    @output BP_REF_OUTPUT(@description "temporalcentroid descriptor" @type "llll")
);

## ------------------------------------------------------------

spectralflatness = (
    $mode = 0 -> ( 
        BP_FN_ESSENTIA(
            @name "spectralflatness"
            @mode $mode
        )
    )
);

BP_REF_NEW(
    @name "spectralflatness"
    @description "Audio descriptor to calculate the spectral flatness of a buffer, defined as the ratio between the spectrum's geometric mean and arithmetic mean. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        BP_REF_ARG(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "spectralflatness descriptor" @type "llll")
);

## ------------------------------------------------------------

temporalflatness = ( 
    -> ( 
        BP_FN_ESSENTIA(
            @name "temporalflatness"
        )
    )
);

BP_REF_NEW(
    @name "temporalflatness"
    @description "Audio descriptor to calculate the temporal flatness of a buffer, defined as the ratio between the buffer envelope's geometric mean and arithmetic mean. Flatness is undefined for empty input and negative values, therefore an exception is thrown in any both cases. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
    )
    @output BP_REF_OUTPUT(@description "temporalflatness descriptor" @type "llll")
);

## ## ------------------------------------------------------------
## BUGGY DESCRIPTOR

## spectralcontrast = (
##     $framesize = 2048,
##     $highfrequencybound = 11000,
##     $lowfrequencybound = 20,
##     $neighbourratio = 0.4,
##     $numberbands = 6,
##     $samplerate = 22050,
##     $staticdistribution = 0.15,
##     $mode = 0 -> ( 
##         BP_FN_ESSENTIA(
##             @name "spectralcontrast"
##             @mode $mode
##             @settings (
##                 "@framesize" $framesize
##                 "@highfrequencybound" $highfrequencybound
##                 "@lowfrequencybound" $lowfrequencybound
##                 "@neighbourratio" $neighbourratio
##                 "@numberbands" $numberbands
##                 "@samplerate" $samplerate
##                 "@staticdistribution" $staticdistribution
##             )
##             @output "spectralcontrast" "spectralvalley"
##         )
##     )
## );

## BP_REF_NEW(
##     @name "spectralcontrast"
##     @description "Audio descriptor to calculate the spectral contrast of a buffer. See #analyze."
##     @category BP_REF_LABEL_ANALYSIS
##     @arguments (
##         BP_REF_ARG(@name "framesize" @default 2048 @type "int" @description "size of the fft frames.")
##         BP_REF_ARG(@name "highfrequencybound" @default 11000 @type "int" @description "upper bound of the highest band.")
##         BP_REF_ARG(@name "lowfrequencybound" @default 20 @type "int" @description "lower bound of the lowest band.")
##         BP_REF_ARG(@name "neighbourratio" @default "0.4" @type "int/float" @description "ratio of the bins in the sub band used to calculate the peak and valley.")
##         BP_REF_ARG(@name "numberbands" @default 6 @type "int" @description "number of bands in the filter.")
##         BP_REF_ARG(@name "samplerate" @default 22050 @type "int" @description "sampling rate.")
##         BP_REF_ARG(@name "staticdistribution" @default "0.15" @type "int/float" @description "ratio of the bins to distribute equally.")
##         BP_REF_ARG(@name "mode" @default 0 @type "int", @description "analysis mode." @options
##             BP_REF_ESSENTIA_ANALYSIS_OPTIONS
##         )
##     )
##     @output BP_REF_OUTPUT(@description "spectralcontrast descriptor" @type "llll")
## );

## ------------------------------------------------------------

barkbands = (
    $numberbands = 27,
    $samplerate = 44100,
    $mode = 0 -> (
        BP_FN_ESSENTIA(
            @name "barkbands"
            @settings (
                "@numberbands" $numberbands
                "@samplerate" $samplerate
            )
            @mode $mode
        )
    )
);

BP_REF_NEW(
    @name "barkbands"
    @description "Audio descriptor to compute the Bark bands of a spectrum. For each bark band the power-spectrum — i.e., mag-squared — is summed. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        BP_REF_ARG(@name "numberbands" @default 27 @type "int" @description "number of desired barkbands.")
        BP_REF_ARG(@name "samplerate" @default 44100 @type "int" @description "sampling rate.")
        BP_REF_ARG(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "barkbands descriptor" @type "llll")
);

## ------------------------------------------------------------

beatsloudness = (
    $beats = null,
    $beatduration = 0.05,
    $beatwindowduration = 0.1,
    $frequencybands = 20 150 400 3200 7000 22000,
    $samplerate = 44100 -> (
        BP_FN_CHECK_ARGS('beatsloudness', 'beats', $beats);
        BP_FN_ESSENTIA(
            @name "beatsloudness"
            @settings (
                "@beats" $beats
                "@beatduration" $beatduration
                "@beatwindowduration" $beatwindowduration
                "@frequencybands" $frequencybands
                "@samplerate" $samplerate
            )
            @output "beatsloudness" "beatsloudness_bandratio"
        )
    )
);

BP_REF_NEW(
    @name "beatsloudness"
    @description "Audio descriptor to compute the spectrum energy of beats in an audio signal given their positions. The energy is computed both on the whole frequency range and for each of the specified frequency bands. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @ankeys "beatsloudness" "beatsloudness_bandratio"
    @arguments (
        BP_REF_ARG(@name "beats" @type "list" @description "duration of the window in which the beat will be restricted.")
        BP_REF_ARG(@name "beatduration" @type "int/float" @default 0.05 @description "duration of the window in which to look for the beginning of the beat, centered around the values in @beats.")
        BP_REF_ARG(@name "beatwindowduration" @type "int/float" @default 0.1 @description "list of beat positions.")
        BP_REF_ARG(@name "frequencybands"  @type "list" @default 20 150 400 3200 7000 22000 @description "list of bands to compute energy ratios.")
        BP_REF_ARG(@name "samplerate" @type "int"  @default 44100 @description "audio sampling rate.")
        BP_REF_ARG(@name "mode" @type "int" @default 0 @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "beatsloudness descriptor" @type "llll")
);

## ------------------------------------------------------------

bfcc = (
    $dcttype = 2,
    $highfrequencybound = 11000,
    $inputsize = 1025,
    $liftering = 0,
    $logtype = 'dbamp',
    $lowfrequencybound = 0,
    $normalize = "unit_sum",
    $numberbands = 40,
    $numbercoefficients = 13,
    $samplerate = 44100,
    $type = 'power',
    $weighting = 'warping',
    $mode = 0 -> (
        BP_FN_ESSENTIA(
            @name "bfcc"
            @settings (
                "@dcttype" $dcttype
                "@highfrequencybound" $highfrequencybound
                "@inputsize" $inputsize
                "@liftering" $liftering
                "@logtype" $logtype
                "@lowfrequencybound" $lowfrequencybound
                "@numberbands" $numberbands
                "@numbercoefficients" $numbercoefficients
                "@samplerate" $samplerate
                "@type" $type
                "@weighting" $weighting
                "@mode" $mode
            )
            @output "bfcc_bands" "bfcc"
        )
    )
);

BP_REF_NEW(
    @name "bfcc"
    @description "Audio descriptor to compute the bark-frequency cepstrum coefficients of a spectrum. Bark bands and their subsequent usage in cepstral analysis have shown to be useful in percussive content. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @ankeys "bfcc_bands" "bfcc"
    @arguments (
        BP_REF_ARG(@name "dcttype" @default 2 @type "int" @description "DCT type.")
        BP_REF_ARG(@name "highfrequencybound" @default 11000 @type "int/float" @description "upper bound of the frequency range.")
        BP_REF_ARG(@name "inputsize" @default 1025 @type "int" @description "size of input spectrum.")
        BP_REF_ARG(@name "liftering" @default 0 @type "int" @description "liftering coefficient. Use 0 to bypass it.")
        BP_REF_ARG(@name "logtype" @default "'dbamp'" @type "int" @description "logarithmic compression type." @options 
            BP_REF_OPT(@value "'dbpow'" @description "Use if working with power.")
            BP_REF_OPT(@value "'dbamp'" @description "Use if working with magnitudes.")
        )
        BP_REF_ARG(@name "lowfrequencybound" @default 0 @type "int" @description "lower bound of the frequency range.")
        BP_REF_ARG(@name "normalize" @default "'unit_sum'" @type "int" @description "normalization mode" @options 
            BP_REF_OPT(@value "'unit_max'" @description "makes the vertex of all the triangles equal to 1.")
            BP_REF_OPT(@value "'unit_sum'" @description "makes the area of all the triangles equal to 1.")
        )
        BP_REF_ARG(@name "numberbands" @default 40 @type "int" @description "number of bark bands in the filter.")
        BP_REF_ARG(@name "numbercoefficients" @default 13 @type "int" @description "number of output cepstrum coefficients.")
        BP_REF_ARG(@name "samplerate" @default 44100 @type "int" @description "sampling rate of the audio signal.")
        BP_REF_ARG(@name "type" @default "'power'" @type "int" @description "magnitude or power spectrum." @options 
            BP_REF_OPT(@value "'power'")
            BP_REF_OPT(@value "'magnitude'")
        )
        BP_REF_ARG(@name "weighting" @default "'warping'" @type "int" @description "type of weighting function for determining triangle area." @options 
            BP_REF_OPT(@value "'warping'")
            BP_REF_OPT(@value "'linear'")
        )
        BP_REF_ARG(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "bfcc descriptor" @type "llll")
);

## ------------------------------------------------------------

rolloff = (
    $cutoff = 0.85,
    $samplerate = 44100,
    $mode = 0 -> ( 
        BP_FN_ESSENTIA(
            @name "rolloff"
            @settings (
                "@cutoff" $cutoff
                "@samplerate" $samplerate
            )
            @mode $mode
        )
    )
);

BP_REF_NEW(
    @name "rolloff"
    @description "Audio descriptor to compute the roll-off frequency of a spectrum. The roll-off frequency is defined as the frequency under which some percentage — i.e., cutoff — of the total energy of the spectrum is contained. The roll-off frequency can be used to distinguish between harmonic — i.e., below roll-off — and noisy sounds — i.e., above roll-off. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        BP_REF_ARG(@name "cutoff" @default 0.85 @type "float" @description "the ratio of total energy to attain before yielding the roll-off frequency.")
        BP_REF_ARG(@name "samplerate" @default 44100 @type "int" @description "sampling rate.")
        BP_REF_ARG(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "rolloff descriptor" @type "llll")
);

## ------------------------------------------------------------

maxmagfreq = (
    $samplerate = 44100,
    $mode = 0 -> ( 
        BP_FN_ESSENTIA(
            @name "maxmagfreq"
            @settings (
                "@samplerate" $samplerate
            )
            @mode $mode
        )
    )
);

BP_REF_NEW(
    @name "maxmagfreq"
    @description "Audio descriptor to compute the frequency with the largest magnitude in a spectrum. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        BP_REF_ARG(@name "samplerate" @default 44100 @type "int" @description "sampling rate.")
        BP_REF_ARG(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "maxmagfreq descriptor" @type "llll")
);

## ------------------------------------------------------------

onsets = (
    $alpha = 0.1,
    $delay = 5,
    $framerate = 86.1328,
    $silencethreshold = 0.02 -> ( 
        BP_FN_ESSENTIA(
            @name "onsets"
            @settings (
                "@alpha" $alpha
                "@delay" $delay
                "@framerate" $framerate
                "@silencethreshold" $silencethreshold
            )
        )
    )
);

BP_REF_NEW(
    @name "onsets"
    @description "Audio descriptor to compute the onset positions in a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        BP_REF_ARG(@name "alpha" @default 0.1 @type "float" @description "proportion of the mean included to reject smaller peaks — filters very short onsets.")
        BP_REF_ARG(@name "delay" @default 5 @type "int" @description "number of frames used to compute the threshold — size of short-onset filter.")
        BP_REF_ARG(@name "framerate" @default 86.1328 @type "float" @description "frames per second.")
        BP_REF_ARG(@name "silencethreshold" @default 0.02 @type "float" @description "threshold for silence.")
    )
    @output BP_REF_OUTPUT(@description "onsets descriptor" @type "llll")
);

## ------------------------------------------------------------

## BUGGY
## onsetrate = (
##     -> ( 
##         BP_FN_ESSENTIA(
##             @name "onsetrate"
##         )
##     )
## );

## BP_REF_NEW(
##     @name "onsetrate"
##     @description "Audio descriptor to compute the number of onsets per second and their position in time for an audio signal. Onset detection functions are computed using both high frequency content and complex-domain methods available in #onsetdetection. Please note that due to a dependence on #onsets, this descriptor is only valid for audio signals with a sampling rate of 44100 Hz. See #analyze."
##     @category BP_REF_LABEL_ANALYSIS
##     @output BP_REF_OUTPUT(@description "onsetrate descriptor" @type "llll")
## );

## ------------------------------------------------------------

onsetdetection = (
    $method = "hfc",
    $samplerate = 44100,
    $mode = 1 -> ( 
        BP_FN_ESSENTIA(
            @name "onsetdetection"
            @mode $mode
            @modes 1...3
            @settings (
                "@method" $method
                "@samplerate" $samplerate
            )
        )
    )
);

BP_REF_NEW(
    @name "onsetdetection"
    @description "Audio descriptor to compute buffer onsets, given various onset detection functions. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @arguments (
        BP_REF_ARG(@name "method" @default "'hfc'" @description "the method used for onset detection." @options 
            BP_REF_ESSENTIA_ONSET_METHOD
        )
        BP_REF_ARG(@name "samplerate" @default 44100 @type "int" @description "sampling rate.")
        BP_REF_ARG(@name "mode" @default 1 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "onsetdetection descriptor" @type "llll")
);

## ------------------------------------------------------------

tonalkey = (
    $numharmonics = 4,
    $pcpsize = 36,
    $profiletype = 'bgate',
    $slope = 0.6,
    $usemajmin = 0,
    $usepolyphony = 1,
    $usethreechords = 1,
    $mode = 0 -> ( 
        BP_FN_ESSENTIA(
            @name "key"
            @settings (
                "@numharmonics" $numharmonics
                "@pcpsize" $pcpsize
                "@profiletype" $profiletype
                "@slope" $slope
                "@usemajmin" $usemajmin
                "@usepolyphony" $usepolyphony
                "@usethreechords" $usethreechords
            )
            @mode $mode
            @modes 0...2
        )
    )
);

BP_REF_NEW(
    @name "tonalkey"
    @description "Audio descriptor to perform tonal key signature estimation on a buffer. See #analyze."
    @category BP_REF_LABEL_ANALYSIS
    @anmodes 0...2
    @arguments (
        BP_REF_ARG(@name "numharmonics" @default 4 @type "int" @description "number of harmonics that should contribute to the polyphonic profile.")
        BP_REF_ARG(@name "pcpsize" @default 36 @type "int" @description "pitch class profile size.")
        BP_REF_ARG(@name "profiletype" @default "'bgate'" @description "the type of polyphic profile to use for correlation calculation." @options
            BP_REF_OPT(@value "'diatonic'" @description "binary profile with diatonic notes of both modes.")
            BP_REF_OPT(@value "'tonic triad'" @description "just the notes of the major and minor chords. exclusively for testing.")
            BP_REF_OPT(@value "'krumhansl'" @description "reference key profiles based on cognitive experiments — useful for pop music.")
            BP_REF_OPT(@value "'temperley'" @description "key profiles extracted from corpus analysis of euroclassical music, especially in minor keys.")
            BP_REF_OPT(@value "'shaath'" @description "profiles based on Krumhansl's specifically tuned to popular and electronic music.")
            BP_REF_OPT(@value "'noland'" @description "profiles from Bach's 'Well Tempered Klavier'.")
            BP_REF_OPT(@value "'edma'" @description "automatic profiles extracted from corpus analysis of EDM — better than Shaath's")
            BP_REF_OPT(@value "'edmm'" @description "same as edma, but manually tweaked according to heuristic observation.")
            BP_REF_OPT(@value "'braw'" @description "profiles obtained by calculating the median profile for each mode from a subset of BeatPort dataset.")
            BP_REF_OPT(@value "'bgate'" @description "same as braw but zeroing the 4 less relevant elements of each profile.")
        )
        BP_REF_ARG(@name "slope" @default 0.6 @type "int/float" @description "value of the slope of the exponential harmonic contribution to the polyphonic profile.")
        BP_REF_ARG(@name "usemajmin" @default 0  @type "int" @description "use a third profile called 'majmin' for ambiguous tracks. Only avalable for the edma, bgate and braw profiles." @options
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "usepolyphony" @default 1 @type "int"  @description "enables the use of polyphonic profiles to define key profiles — this includes the contributions from triads as well as pitch harmonics." @options
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "usethreechords" @default 1 @type "int"  @description "consider only the 3 main triad chords of the key — i.e., T, D, SD — to build the polyphonic profiles." @options
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "mode" @default 0 @type "int", @description "analysis mode." @options
            BP_REF_ESSENTIA_ANALYSIS_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "tonalkey descriptor" @type "llll")
);

## ------------------------------------------------------------

process = (
    $buffer = null, 
    $operations = null, 
    $prefade = 0,
    $keepkeys = null -> (
        $self = 'process';
        BP_FN_CHECK_ARGS($self, 'buffer', $buffer, 'operations', $operations);
        for $op in $operations do if $op.getkey("fx") == null then BP_FN_ERROR($self, "invalid processing operation:" $op);
        $source = BP_FN_VALIDATE_BUFFER($self, $buffer);
        $offset = getkey($buffer, "offset");
        $duration = getkey($buffer, "duration");
        $crop = $offset != 0 || $duration != getkey($buffer, "source_end");
        BP_FN_DISPATCH("process",
            [ "source" $source ]
            [ "process" 
                (if $crop then crop(@start $offset, @end $offset + $duration))
                ($prefade &&& $prefade > 0 &&& fade(@fadein $prefade, @fadeout $prefade))
                $operations 
            ]
        );
        $extrakeys = for $k in thin($keepkeys) collect (
            $val = $buffer.getkey($k);
            $val &&& [ $k $val ]
        );
        for $buf in BP_TMP_BUFF collect BP_FN_NEWBUFF(
            @source $buf
            @pitch $buffer.getkey("pitch") 
            @extras $extrakeys
        )
    )
);

BP_REF_NEW(
    @name "process",
    @description "Applies a sequence of DSP operations to the input buffer, prior to rendering, via audio processing operations. These operations are generated through functions (e.g., see #reverse, #paulstretch, #freeverb, #rubberband), which contain the parameters for that specific DSP operation. This results in a newly created buffer, with updated keys. To keep keys from the input buffer, such as keys associated with previous feature analyses, use the @keepkeys argument by passing an optional list of keys. See @process argument in #render.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "buffer", @type "llll", @description "buffer to process.")
        BP_REF_ARG(@name "operations", @type "llll", @description "list of audio process operations.")
        BP_REF_ARG(@name "prefade", @default 0 @type "llll/null", @description "optional pre-fade amount, in milliseconds.")
        BP_REF_ARG(@name "keepkeys", @default "null" @type "symbol/list/null", @description "optional list of keys to keep from input buffer.")
    ),
    @output BP_REF_OUTPUT(@description "processed buffer" @type "llll")
);


## ------------------------------------------------------------

fade = (
    $fadein = 5, 
    $fadeout = 5,
    $fadeincurve = -0.25,
    $fadeoutcurve = 0.25,
    $fadeintype = 0,
    $fadeouttype = 0,
    $timeunit = 0 -> (
        [
            [ "fx" "fade" ]
            [ "params"
                [ "fadein" $fadein ]
                [ "fadeout" $fadeout ]
                [ "timeunit" $timeunit ]
                [ "fadeincurve" $fadeincurve ]
                [ "fadeoutcurve" $fadeoutcurve ]
                [ "fadeintype" $fadeintype + 1 ]
                [ "fadeouttype" $fadeouttype + 1 ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "fade",
    @description "Audio process operation for applying fadein/fadeout to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "fadein", @default 5, @type "int/float", @description "fade-in duration.")
        BP_REF_ARG(@name "fadeout", @default 5, @type "int/float", @description "fade-out duration.")
        BP_REF_ARG(@name "fadeintype", @default 0, @type "int", @description "fade-in type.", @options 
            BP_REF_CURVE_OPTIONS
        )
        BP_REF_ARG(@name "fadeouttype",@default 0, @type "int", @description "fade-out type.", @options 
            BP_REF_CURVE_OPTIONS
        )
        BP_REF_ARG(@name "fadeincurve", @default -0.25, @type "int/float", @description "fade-in curve amount, between -1 and 1.")
        BP_REF_ARG(@name "fadeoutcurve", @default 0.25, @type "int/float", @description "fade-out curve amount, between -1 and 1.")
        BP_REF_ARG(@name "timeunit", @default 0 @type "int", @description "time unit for @start and @end." @options
            BP_REF_TIMEUNIT_OPTIONS
        )
    ),
    @output BP_REF_OUTPUT(@description "fade operation" @type "llll")
);

## ------------------------------------------------------------

crop = (
    $start = 0,
    $end = 1000,
    $timeunit = 0 -> (
        $self = 'crop';
        BP_FN_CHECK_ARGS($self, 'start', $start, 'end', $end);
        if $end > 0 && $end <= $start then BP_FN_ERROR($self, "@end must be greater than @start");
        [
            ["fx" "crop"]
            ["params" 
                [ "timeunit" $timeunit ]
                [ "start" $start ]
                [ "end" $end ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "crop",
    @description "Audio process operation for cropping a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "start" @default 0 @type "int/float", @description "start time.")
        BP_REF_ARG(@name "end" @default 1000 @type "int/float", @description "end time. if negative, it counts from the end.")
        BP_REF_ARG(@name "timeunit", @default 0 @type "int", @description "time unit for @start and @end." @options
            BP_REF_TIMEUNIT_OPTIONS
        )
    ),
    @output BP_REF_OUTPUT(@description "crop operation" @type "llll")
);

## ------------------------------------------------------------

bpthru = ( -> [ [ "fx" "thru" ] ]);

## ------------------------------------------------------------

reverse = ( -> [ [ "fx" "reverse" ] ]);

BP_REF_NEW(
    @name "reverse",
    @description "Audio process operation for reversing a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @output BP_REF_OUTPUT(@description "reverse operation" @type "llll")
);

## ------------------------------------------------------------

dcfilter = ( -> [ [ "fx" "dcfilter" ] ]);

BP_REF_NEW(
    @name "dcfilter",
    @description "Audio process operation for removing DC offset from a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @output BP_REF_OUTPUT(@description "dcfilter operation" @type "llll")
);

## ------------------------------------------------------------

getchannels = (
    $buffer, 
    $channels = null,
    $all = 1 -> (
        BP_FN_CHECK_ARGS('getchannels', 'buffer', $buffer);
        $buffer.process(
            [
                [ "fx" "channel" ]
                [ "params"
                    [ "all" $all ]
                    [ "channels" $channels ]
                ]
            ]
        )    
    )
);

BP_REF_NEW(
    @name "getchannels",
    @description "Extracts one or more buffer channels as individual buffers.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "buffer", @type "llll", @description "buffer to extract channels from.")
        BP_REF_ARG(@name "channels" @default "null" @type "int/list/llll/null", @description "number to channels to extract — ignored when @all is 1.")
        BP_REF_ARG(@name "all" @default 1 @type "int", @description "extract all channels." @options 
            BP_REF_SWITCH_OPTIONS
        )
    ),
    @output BP_REF_OUTPUT(@description "channels as buffers", @type "llll")
);

## ------------------------------------------------------------

freeverb = (
    $roomsize = .5,
    $damp = .5,
    $width = .5,
    $tail = -1,
    $dry = 1., 
    $wet = 1/6. -> (
        [
            ["fx" "freeverb"]
            [ "params" 
                [ "roomsize" $roomsize ]
                [ "damp" $damp ]
                [ "width" $width ]
                [ "tail" $tail ]
                [ "dry" if depth($dry) > 1 || length($dry) > 1 then [ bpf($dry) ] else $dry ]
                [ "wet" if depth($wet) > 1 || length($wet) > 1 then [ bpf($wet) ] else $wet ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "freeverb",
    @description "Audio process operation for applying reverb to a buffer. See #process function.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "roomsize", @default 0.5, @type "int/float", @description "reverb room size")
        BP_REF_ARG(@name "damp", @default 0.5, @type "int/float", @description "damping coefficient")
        BP_REF_ARG(@name "width", @default 0.5, @type "int/float", @description "panning width/spread, from 0 to 1.")
        BP_REF_ARG(@name "tail", @default -1, @type "int/float", @description "duration of reverb tail in ms." @options 
            BP_REF_OPT(@value -1 @description "auto")
            BP_REF_OPT(@value 0 @description "no" "tail")
            BP_REF_OPT(@value ">0" @description "duration" "in" "ms")
        )
        BP_REF_ARG(@name "dry", @default 1, @type "int/float/llll", @description "amount of dry output, as either a single number or envelope.")
        BP_REF_ARG(@name "wet", @default 0.16, @type "int/float/llll", @description "amount of wet output, as either a single number or envelope.")
    ),
    @output BP_REF_OUTPUT(@description "freeverb operation" @type "llll")
);

## ------------------------------------------------------------

BP_FN_OSC_GEN = (
    $name,
    $frequency = 440,
    $duration = 50,
    $params = null -> (
        $source = $frequency.getkey("source");
        $isnoise = $name == "noise";
        $salience = $isnoise == 0 && $source == null;
        ## if generator is noise
        if $isnoise == 1 then (
            $frequency = rand(40, 1500)
        ) else if $source == null then (
            ## if @frequency is an envelope
            $source = envelope($frequency, @duration $duration).getkey("source");
            if depth($frequency) > 1 || length($frequency) > 1 then (
                $frequency = trans(bpf($frequency))::(2 1)
            )
        ) else (
            ## if @frequency is a buffer
            $duration = $frequency.getkey("duration");
            $frequency = mc2f(6000)
        );
        BP_FN_DISPATCH("generate", 
            [
                [ "fx" $name ]
                [ "params" 
                    $params
                    if $isnoise == 1 then (
                        [ "tail" $duration ] 
                        [ "trigger" ]
                    ) else (
                        [ $source ]
                    )
                ]
            ]
        );
        $pitch = f2mc($frequency);
        BP_FN_NEWBUFF(@source BP_TMP_BUFF @pitch $pitch)
    )
);

## ------------------------------------------------------------

noise = (
    $duration = 50 -> (
        BP_FN_OSC_GEN("noise", @duration $duration)
    )
);

BP_REF_NEW(
    @name "noise",
    @description "Generates white noise as a buffer.",
    @category BP_REF_LABEL_GEN,
    @arguments (
        BP_REF_ARG(@name "duration", @default 50, @type "int/float", @description "buffer duration, in milliseconds")
    ),
    @output BP_REF_OUTPUT(@description "synthesized buffer" @type "llll")
);

## ------------------------------------------------------------

randosc = (
    $frequency = 440,
    $duration = 50 -> (
        BP_FN_OSC_GEN("rand", @frequency $frequency @duration $duration)
    )
);

BP_REF_NEW(
    @name "randosc",
    @description "Generates a random oscillator as a buffer.",
    @category BP_REF_LABEL_GEN,
    @arguments (
        BP_REF_ARG(@name "frequency", @default 440, @type "int/float/llll", @description "frequency, either as a single number, envelope, or buffer.")
        BP_REF_ARG(@name "duration", @default 50, @type "int/float", @description "buffer duration, in milliseconds")
    ),
    @output BP_REF_OUTPUT(@description "synthesized buffer" @type "llll")
);

## ------------------------------------------------------------

cycle = (
    $frequency = 440, 
    $duration = 50,
    $phase = 0.25 -> (
        BP_FN_OSC_GEN("cycle" @frequency $frequency @duration $duration @params [ "phase" float($phase) ])
    )
);

BP_REF_NEW(
    @name "cycle",
    @description "Generates a sinusoidal oscillator as a buffer.",
    @category BP_REF_LABEL_GEN,
    @arguments (
        BP_REF_ARG(@name "frequency", @default 440, @type "int/float/llll", @description "frequency, either as a single number, envelope, or buffer.")
        BP_REF_ARG(@name "duration", @default 50, @type "int/float", @description "buffer duration, in milliseconds")
        BP_REF_ARG(@name "phase", @default 0.25, @type "int/float", @description "initial phase, in the 0–1 range.")
    ),
    @output BP_REF_OUTPUT(@description "synthesized buffer" @type "llll")
);

## ------------------------------------------------------------

rect = (
    $frequency = 440, 
    $duration = 50,
    $duty = 0.5 -> (
        BP_FN_OSC_GEN("rect", @frequency $frequency, @duration $duration, @params [ "duty" $duty ])
    )
);

BP_REF_NEW(
    @name "rect",
    @description "Generates a bipolar, anti-aliased rectangular (pulse) oscillator as a buffer.",
    @category BP_REF_LABEL_GEN,
    @arguments (
        BP_REF_ARG(@name "frequency", @default 440, @type "int/float/llll", @description "frequency, either as a single number, envelope, or buffer.")
        BP_REF_ARG(@name "duration", @default 50, @type "int/float", @description "buffer duration, in milliseconds")
        BP_REF_ARG(@name "duty", @default 0.5, @type "int/float/llll", @description "duty cycle in the range of 0-1, either as a number, envelope, or buffer.")
    ),
    @output BP_REF_OUTPUT(@description "synthesized buffer" @type "llll")
);

## ------------------------------------------------------------

saw = (
    $frequency = 440, 
    $duration = 50 -> (
        BP_FN_OSC_GEN("saw", @frequency $frequency, @duration $duration)
    )
);

BP_REF_NEW(
    @name "saw",
    @description "Generates a bipolar, anti-aliased sawtooth oscillator as a buffer.",
    @category BP_REF_LABEL_GEN,
    @arguments (
        BP_REF_ARG(@name "frequency", @default 440, @type "int/float/llll", @description "frequency, either as a single number, envelope, or buffer.")
        BP_REF_ARG(@name "duration", @default 50, @type "int/float", @description "buffer duration, in milliseconds")
    ),
    @output BP_REF_OUTPUT(@description "synthesized buffer" @type "llll")
);

## ------------------------------------------------------------

tri = (
    $frequency = 440, 
    $duration = 50,
    $duty = 0.5 -> (
        BP_FN_OSC_GEN("tri", @frequency $frequency, @duration $duration, @params [ "duty" $duty ])
    )
);

BP_REF_NEW(
    @name "tri",
    @description "Generates a bipolar, anti-aliased triangular oscillator as a buffer.",
    @category BP_REF_LABEL_GEN,
    @arguments (
        BP_REF_ARG(@name "frequency", @default 440, @type "int/float/llll", @description "frequency, either as a single number, envelope, or buffer.")
        BP_REF_ARG(@name "duration", @default 50, @type "int/float", @description "buffer duration, in milliseconds")
        BP_REF_ARG(@name "duty", @default 0.5, @type "int/float/llll", @description "duty cycle in the range of 0-1, either as a number, envelope, or buffer.")
    ),
    @output BP_REF_OUTPUT(@description "synthesized buffer" @type "llll")
);

## ------------------------------------------------------------

triangle = (
    $frequency = 440, 
    $duration = 50,
    $phase = 0,
    $offset = 0.5 -> (
        BP_FN_OSC_GEN("triangle", @frequency phasor($frequency, @duration $duration @phase $phase), @duration $duration @params [ "phase" float($offset) ])
    )
);

BP_REF_NEW(
    @name "triangle",
    @description "Generates a triangular/ramp oscillator as a buffer.",
    @category BP_REF_LABEL_GEN,
    @arguments (
        BP_REF_ARG(@name "frequency", @default 440, @type "int/float/llll", @description "frequency, either as a single number, envelope, or buffer.")
        BP_REF_ARG(@name "duration", @default 50, @type "int/float", @description "buffer duration, in milliseconds")
        BP_REF_ARG(@name "phase", @default 0, @type "int/float", @description "initial phase, in the 0-1 range.")
        BP_REF_ARG(@name "offset", @default 0.5, @type "int/float", @description "peak position offset, in the 0-1 range.")
    ),
    @output BP_REF_OUTPUT(@description "synthesized buffer" @type "llll")
);

## ------------------------------------------------------------

phasor = (
    $frequency = 440, 
    $duration = 50,
    $phase = 0. -> (
        BP_FN_OSC_GEN("phasor", @frequency $frequency, @duration $duration, @params [ "phase" float($phase) ])
    )
);

BP_REF_NEW(
    @name "phasor",
    @description "Generates a unipolar ramp oscillator as a buffer.",
    @category BP_REF_LABEL_GEN,
    @arguments (
        BP_REF_ARG(@name "frequency", @default 440, @type "int/float/llll", @description "frequency, either as a single number, envelope, or buffer.")
        BP_REF_ARG(@name "duration", @default 50, @type "int/float", @description "buffer duration, in milliseconds")
        BP_REF_ARG(@name "phase", @default 0, @type "int/float", @description "initial phase, in the 0-1 range.")
    ),
    @output BP_REF_OUTPUT(@description "synthesized buffer" @type "llll")
);

## ------------------------------------------------------------

envelope = (
    $envelope = 0, 
    $duration = 1000 -> (
        $depth = depth($envelope);
        $length = length($envelope);
        if $depth > 1 || $length > 1 then ($envelope = [ bpf($envelope) ]);
        BP_FN_DISPATCH("generate", 
            [
                [ "fx" "envelope"]
                [ "params" 
                    [ "duration" $duration ]
                    [ $envelope ]
                ]
            ]
        );
        BP_FN_NEWBUFF(@source BP_TMP_BUFF)
    )
);

BP_REF_NEW(
    @name "envelope",
    @description "Generates an audio envelope as a buffer, given a single number or a breakpoint function.",
    @category BP_REF_LABEL_GEN,
    @arguments (
        BP_REF_ARG(@name "envelope", @default 0, @type "int/float/llll", @description "envelope, as either a single number or a breakpoint function.")
        BP_REF_ARG(@name "duration", @default 1000, @type "int", @description "envelope duration, in milliseconds")
    ),
    @output BP_REF_OUTPUT(@description "envelope" @type "llll")
);

## ------------------------------------------------------------

clicks = (
    $onsets = 0, 
    $gains = 1,
    $impulse = 1,
    $ampunit = 0,
    $timeunit = 0 -> (
        $self = 'clicks';
        for $x in ["onsets" $onsets] [ "gains" $gains ] [ "impulse" $impulse ] do (
            $k = $x::(1 2);
            if $k == null || $k.length() > 1  then (
                BP_FN_ERROR($self, $x::(1 1) "must be a flat list")
            )
        );
        BP_FN_DISPATCH("generate", 
            [
                [ "fx" "clicks"]
                [ "params" 
                    [ "impulse" $impulse ]
                    [ "gains" $gains ]
                    [ "onsets" $onsets.max(1) ]
                ]
            ]
        );
        $buff = BP_FN_NEWBUFF(@source BP_TMP_BUFF);
        if $buff.getkey('duration') < 2 then (
            $buff.process(
                join(envelope(0 @duration 2))
            )
        ) else (
            $buff
        )
    )
);

BP_REF_NEW(
    @name "clicks",
    @description "Generates a buffer containing a set of clicks at specific onsets. Note that if the first onset value is 0, it might get silenced when the @fade argument in #render is non-zero.",
    @category BP_REF_LABEL_GEN,
    @arguments (
        BP_REF_ARG(@name "onsets" @default 0 @type "int/float/list" @description "onset positions.")
        BP_REF_ARG(@name "gains" @default 1 @type "int/float/list" @description "click gains.")
        BP_REF_ARG(@name "impulse" @default 1 @type "int/float/list" @description "impulse, a list of audio samples.")
        BP_REF_ARG(@name "timeunit", @default 0, @type "int", @description "time unit." @options
            BP_REF_TIMEUNIT_OPTIONS
        )
        BP_REF_ARG(@name "ampunit", @default 0, @type "int", @description "amplitude unit." @options
            BP_REF_AMPUNIT_OPTIONS
        )
    ),
    @output BP_REF_OUTPUT(@description "clicks buffer" @type "llll")
);

## ------------------------------------------------------------

paulstretch = (
    $stretching = 1,
    $timeunit = 2,
    $envtimeunit = 2,
    $spectral = 1,
    $framesize = 8192 -> (
        $stretching = if depth($stretching) > 1 || length($stretching) > 1 then [ bpf($stretching) ] else $stretching;
        [
            [ "fx" "paulstretch" ]
            [ "params" 
                [ "stretching" $stretching ||| 1 ]
                [ "timeunit" $timeunit ]
                [ "envtimeunit" $envtimeunit ]
                [ "spectral" $spectral ] 
                [ "framesize" $framesize ] 
            ]
        ]
    )
);

BP_REF_NEW(
    @name "paulstretch",
    @description "Audio process operation for applying time-stretching to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "stretching", @default 1, @type "int/float/llll", @description "stretching amount, as single number or envelope.")
        BP_REF_ARG(@name "timeunit", @default 2, @type "int", @description "time unit for @stretching." @options (
            BP_REF_TIMEUNIT_OPTIONS
        ))
        BP_REF_ARG(@name "envtimeunit", @default 2, @type "int", @description "time unit for @stretching envelope." @options 
            BP_REF_TIMEUNIT_OPTIONS
        )
        BP_REF_ARG(@name "spectral", @default 1, @type "int", @description "stretching mode." @options 
            BP_REF_AUDIO_DOMAIN_OPTIONS
        )
        BP_REF_ARG(@name "framesize", @default 8192, @type "int", @description "analysis frame size, in samples.")
    ),
    @output BP_REF_OUTPUT(@description "paulstretch operation" @type "llll")
);

## ------------------------------------------------------------

paulfreeze = (
    $duration = 1000,
    $position = 0,
    $jitter = 0,
    $timeunit = 0,
    $spectral = 0,
    $framesize = 8192 -> (
        [
            [ "fx" "paulfreeze" ]
            [ "params" 
                [ "duration" $duration ||| 1000 ]
                [ "onset" [ $position $jitter ] ]
                [ "timeunit" $timeunit ]
                [ "spectral" $spectral ]
                [ "framesize" $framesize ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "paulfreeze",
    @description "Audio process operation for freezing a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "duration" @default 1000 @type "int/float" @description "freezing duration, based on @timeunit.")
        BP_REF_ARG(@name "position" @default 0 @type "int/float" @description "freezing time position")
        BP_REF_ARG(@name "jitter" @default 0 @type "int/float" @description "variation around time position, in milliseconds. To use entire buffer, use 'all'.")
        BP_REF_ARG(@name "timeunit" @default 0 @type "int" @description "time unit.", @options 
            BP_REF_TIMEUNIT_OPTIONS
        )
        BP_REF_ARG(@name "spectral" @default 0 @type "int", @description "stretching mode." @options 
            BP_REF_AUDIO_DOMAIN_OPTIONS
        )
        BP_REF_ARG(@name "framesize", @default 8192, @type "int", @description "analysis frame size, in samples.")
    ),
    @output BP_REF_OUTPUT(@description "paulfreeze operation" @type "llll")
);

## ------------------------------------------------------------

overdrive = (
    $factor = 1 -> (
        $factor = if depth($factor) > 1 || length($factor) > 1 then [ bpf($factor) ] else $factor;
        [
            [ "fx" "overdrive" ]
            [ "params" 
                [ "factor" $factor ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "overdrive",
    @description "Audio process operation for applying soft-clip distortion to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "factor", @type "int/float/llll", @description "amplitude distortion factor, either as single number or envelope.")
    ),
    @output BP_REF_OUTPUT(@description "overdrive operation" @type "llll")
);

## ------------------------------------------------------------

window = (
    $wintype = "hann",
    $winnormalized = 0,
    $zeropadding = 0,
    $zerophase = 0 -> (
        [
            [ "fx" "window" ]
            [ "params" 
                [ "wintype" $wintype ]
                [ "winnormalized" $winnormalized ]
                [ "zeropadding" $zeropadding ]
                [ "zerophase" $zerophase ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "window",
    @description "Audio process operation for applying a windowing function to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "wintype", @default "'hann'", @type "symbol", @description "window type, as a symbol" @options
            BP_REF_WINDOW_OPTIONS
        )
        BP_REF_ARG(@name "winnormalized", @default 0, @type "int", @description "normalize window samples to sum up to 1 and multiply by a factor of 2." @options 
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "zeropadding", @default 0, @type "int", @description "number of samples for zero padding.")
        BP_REF_ARG(@name "zerophase", @default 0, @type "int", @description "zero phase windowing" @options 
            BP_REF_SWITCH_OPTIONS
        )
    ),
    @output BP_REF_OUTPUT(@description "window operation" @type "llll")
);

## ------------------------------------------------------------

biquad = (
    $frequency = 2000,
    $type = 2,
    $gain = 1,
    $q = 100 -> (
        $frequency = $frequency.getkey("source") ||| [ bpf($frequency) ];
        $gain = $gain.getkey("source") ||| [ bpf($gain) ];
        $q = $q.getkey("source") ||| [ bpf($q) ];
        if contains($type) == 16 then (
            $type = (
                [ "lowpass" 0 ]
                [ "highpass" 1 ]
                [ "bandpass" 2 ]
                [ "bandstop" 3 ]
                [ "peaknotch" 4 ]
                [ "lowshelf" 5 ]
                [ "highshelf" 6 ]
                [ "resonant" 7 ]
                [ "allpass" 8 ]
            ).$type
        );
        $type ||| BP_FN_ERROR('biquad', "invalid value for @type");
        [
            [ "fx" "biquad" ]
            [ "params" 
                [ "type" "edit_mode" $type + 1 ]
                [ "frequency" $frequency ]
                [ "gain" $gain ]
                [ "q" $q ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "biquad",
    @description "Audio process operation for applying biquad filtering to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "type", @type "int/symbol", @description "filter type, as a symbol or integer." @options
            BP_REF_OPT(@value 0 @description "lowpass")
            BP_REF_OPT(@value 1 @description "highpass")
            BP_REF_OPT(@value 2 @description "bandpass")
            BP_REF_OPT(@value 3 @description "bandstop")
            BP_REF_OPT(@value 4 @description "peaknotch")
            BP_REF_OPT(@value 5 @description "lowshelf")
            BP_REF_OPT(@value 6 @description "highshelf")
            BP_REF_OPT(@value 7 @description "resonant")
            BP_REF_OPT(@value 8 @description "allpass")
        )
        BP_REF_ARG(@name "frequency", @default 2000, @type "int/float", @description "cutoff/center frequency.")
        BP_REF_ARG(@name "gain", @default 1, @type "int/float", @description "linear gain.")
        BP_REF_ARG(@name "q", @default 80, @type "int/float", @description "resonance or slope, depending on @type.")
    ),
    @output BP_REF_OUTPUT(@description "biquad operation" @type "llll")
);

## ------------------------------------------------------------

clip = (
    $threshold = 1 -> (
        $threshold = if depth($threshold) > 1 || length($threshold) > 1 then [ bpf($threshold) ] else $threshold;
        [
            [ "fx" "clip" ]
            [ "params" 
                [ "threshold" $threshold ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "clip",
    @description "Audio process operation for applying hard-clip distortion to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "threshold" @default 1 @type "int/float/llll", @description "distortion amplitude threshold, either as single number or envelope.")
    ),
    @output BP_REF_OUTPUT(@description "clip operation" @type "llll")
);

## ------------------------------------------------------------

rubberband = (
    $stretching = 1,
    $pitchshift = 0,
    $pitchunit = 0,
    $timeunit = 2,
    $envtimeunit = 2,
    $blocksize = 1024,
    $fftwin = 1,
    $phase = 0,
    $pitchmode = 2,
    $formants = 0,
    $smoothing = 0,
    $stretchmode = 0,
    $detector = 0,
    $transients = 2 -> (
        $stretching = if depth($stretching) > 1 || length($stretching) > 1 then [ bpf($stretching) ] else $stretching;
        $pitchshift = if depth($pitchshift) > 1 || length($pitchshift) > 1 then [ bpf($pitchshift) ] else $pitchshift;
        [
            [ "fx" "rubberband" ]
            [ "params" 
                [ "stretching" $stretching ||| 1 ]
                [ "pitchshift" $pitchshift ||| 1 ]
                [ "pitchunit" $pitchunit ]
                [ "timeunit" $timeunit ]
                [ "envtimeunit" $envtimeunit ]
                [ "blocksize" $blocksize ]
                [ "fftwin" $fftwin ]
                [ "phase" $phase ]
                [ "pitchmode" $pitchmode ]
                [ "formants" $formants ]
                [ "smoothing" $smoothing ]
                [ "stretchmode" $stretchmode ]
                [ "detector" $detector ]
                [ "transients" $transients ] 
            ]
        ]
    )
);

BP_REF_NEW(
    @name "rubberband",
    @description "Audio process operation for applying rubberband pitch-shifting/time-stretching to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "stretching", @default 1, @type "int/float/llll", @description "stretching amount, as single number or envelope.")
        BP_REF_ARG(@name "pitchshift", @default 0, @type "int/float/llll", @description "pitch shifting amount, as single number or envelope.")
        BP_REF_ARG(@name "pitchunit", @default 0, @type "int", @description "unit for @pitchshift." @options
            BP_REF_PITCH_FORMAT_OPTIONS
        )
        BP_REF_ARG(@name "timeunit", @default 2, @type "int", @description "time unit for @stretching." @options 
            BP_REF_TIMEUNIT_OPTIONS
        )
        BP_REF_ARG(@name "envtimeunit", @default 2, @type "int", @description "time unit for @stretching envelope." @options
            BP_REF_TIMEUNIT_OPTIONS
        )
        BP_REF_ARG(@name "blocksize", @default 1024, @type "int", @description "size for granular processes, such as envelopes, in samples.")
        BP_REF_ARG(@name "fftwin", @default 1, @type "int", @description "FFT window type." @options
            BP_REF_OPT(@value 0 @description "short") 
            BP_REF_OPT(@value 1 @description "standard") 
            BP_REF_OPT(@value 2 @description "long")
        )
        BP_REF_ARG(@name "phase", @default 0, @type "int", @description "phase adjustment mode." @options
            BP_REF_OPT(@value 0 @description "elastic") 
            BP_REF_OPT(@value 1 @description "precise") 
        )
        BP_REF_ARG(@name "pitchmode", @default 2, @type "int", @description "pitch shift mode." @options
            BP_REF_OPT(@value 0 @description "high" "speed") 
            BP_REF_OPT(@value 1 @description "high" "quality") 
            BP_REF_OPT(@value 2 @description "high" "consistency") 
        )
        BP_REF_ARG(@name "formants", @default 0, @type "int", @description "formant processing." @options
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "smoothing", @default 0, @type "int", @description "time-domain smoothing." @options
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "stretchmode", @default 0, @type "int", @description "stretch mode." @options 
            BP_REF_OPT(@value 0 @description "elastic") 
            BP_REF_OPT(@value 1 @description "precise") 
        )
        BP_REF_ARG(@name "detector", @default 0, @type "int", @description "transient detection algorithm." @options
            BP_REF_OPT(@value 0 @description "compound") 
            BP_REF_OPT(@value 1 @description "percussive") 
            BP_REF_OPT(@value 2 @description "soft") 
        )
        BP_REF_ARG(@name "transients", @default 2, @type "int", @description "transient type." @options
            BP_REF_OPT(@value 0 @description "crisp") 
            BP_REF_OPT(@value 1 @description "mixed") 
            BP_REF_OPT(@value 2 @description "smooth") 
        )
    ),
    @output BP_REF_OUTPUT(@description "rubberband operation" @type "llll")
);

## ------------------------------------------------------------

soundtouch = (
    $stretching = 1,
    $pitchshift = 0,
    $pitchunit = 0,
    $timeunit = 2,
    $antialias = 0,
    $quick = 0,
    $speech = 0 -> (
        [
            [ "fx" "soundtouch" ]
            [ "params" 
                [ "stretching" $stretching ||| 1 ]
                [ "pitchshift" $pitchshift ||| 1 ]
                [ "pitchunit" $pitchunit ]
                [ "timeunit" $timeunit ]
                [ "naa" $antialias ]
                [ "quick" $quick ]
                [ "speech" $speech ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "soundtouch",
    @description "Audio process operation for applying soundtouch pitch-shifting/time-stretching to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "stretching", @default 1, @type "int/float", @description "stretching amount, as a single number.")
        BP_REF_ARG(@name "pitchshift", @default 0, @type "int/float", @description "pitch shifting amount, as single number.")
        BP_REF_ARG(@name "pitchunit", @default 0, @type "int", @description "unit for @pitchshift." @options
            BP_REF_PITCH_FORMAT_OPTIONS
        )
        BP_REF_ARG(@name "timeunit", @default 2, @type "int", @description "time unit for @stretching." @options 
            BP_REF_TIMEUNIT_OPTIONS
        )
        BP_REF_ARG(@name "antialias", @default 0, @type "int", @description "anti-aliasing filter." @options 
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "quick", @default 0, @type "int", @description "quick processing. " @options 
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "speech", @default 0, @type "int", @description "tune algorithm for speech. " @options 
            BP_REF_SWITCH_OPTIONS
        )
    ),
    @output BP_REF_OUTPUT(@description "soundtouch operation" @type "llll")
);

## ------------------------------------------------------------

expand = (
    $buffer -> (
        BP_FN_CHECK_ARGS('expand', 'buffer', $buffer);
        $buffer.setkey("offset", 0).setkey("duration", $buffer.getkey("source_end"))
    )
);

BP_REF_NEW(
    @name "expand",
    @description "Modifies offset and duration of a buffer, such that it uses the full length of its reference buffer.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "buffer", @type "llll", @description "buffer to expand.")
    )
    @output BP_REF_OUTPUT(@description "buffer" @type "llll")
);

## ------------------------------------------------------------

groove = (
    $rate = 1,
    $duration = 1000 -> (
        $source = $rate.getkey("source");
        if $source == null then (
            $source = envelope($rate, @duration $duration).getkey("source")
        );
        [
            [ "fx" "groove" ]
            [ "params"
                [ "rate" $source ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "groove",
    @description "Audio processing operation for applying variable-rate sample playback to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "rate" @default 1 @type "int/float/list/llll", @description "playback rate, as either a single number, envelope, or control buffer.")
        BP_REF_ARG(@name "duration" @default 1000 @type "int/float", @description "duration in milliseconds. Ignored if @rate is a buffer.")
    )
    @output BP_REF_OUTPUT(@description "groove operation" @type "llll")
);

## ------------------------------------------------------------

freqshift = (
    $shift,
    $negative = 0 -> (
        BP_FN_CHECK_ARGS('freqshift', 'shift', $shift);
        $source = $shift.getkey("source");
        if $source != null then (
            $shift = $source
        ) else (
            $shift = [ bpf($shift) ]
        );
        [
            [ "fx" "freqshift" ]
            [ "params"
                [ "negative" float($negative != 0) ]
                [ "shift" $shift ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "freqshift",
    @description "Audio process operation for applying frequency shifting to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "shift", @type "int/float/list/llll", @description "frequency shift in Hertz, as either a single number, an envelope or buffer.")
        BP_REF_ARG(@name "negative" @default 0 @type "int", @description "Include negative sideband  in output." @options
            BP_REF_SWITCH_OPTIONS
        )
    ),
    @output BP_REF_OUTPUT(@description "freqshift operation" @type "llll")
);

## ------------------------------------------------------------

degrade = (
    $ratio = .5,
    $bits = 4 -> (
        $bits = $bits.getkey("source") ||| [ bpf($bits) ];
        $ratio = $ratio.getkey("source") ||| [ bpf($ratio) ];
        [
            [ "fx" "degrade" ]
            [ "params"
                [ "bits" $bits ]
                [ "ratio" $ratio ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "degrade",
    @description "Audio process operation for reducing sampling rate and bit-depth of a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "ratio", @default 0.5, @type "int/float/llll", @description "sampling rate ratio.")
        BP_REF_ARG(@name "bits", @default 4, @type "int/float/llll", @description "bit depth.")
    ),
    @output BP_REF_OUTPUT(@description "degrade operation" @type "llll")
);

## ------------------------------------------------------------

rounding = (
    $value = 1,
    $nearest = 1 -> (
        $value = $value.getkey("source") ||| [ bpf($value) ];
        [
            [ "fx" "round" ]
            [ "params"
                [ "round" 
                    [ "nearest" $nearest ]
                ]
                [ "value" $value ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "rounding",
    @description "Audio process operation for applying signal rounding to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "value", @default 1, @type "int/float/list/llll", @description "rounding value, as either a single number, envelope, or buffer.")
        BP_REF_ARG(@name "nearest", @default 1, @type "int", @description "rounding behavior" @options
            BP_REF_OPT(@value 0 @description "floor")
            BP_REF_OPT(@value 1 @description "nearest")
        )
    ),
    @output BP_REF_OUTPUT(@description "rounding operation" @type "llll")
);

## ------------------------------------------------------------

teeth = (
    $feedforward = 5,
    $feedback = 10,
    $gain = 0.5,
    $feedforwardgain = 0.5,
    $feedbackgain = -0.5 -> (
        $feedforward = $feedforward.getkey("source") ||| [ bpf($feedforward) ];
        $feedback = $feedback.getkey("source") ||| [ bpf($feedback) ];
        $gain = $gain.getkey("source") ||| [ bpf($gain) ];
        $feedforwardgain = $feedforwardgain.getkey("source") ||| [ bpf($feedforwardgain) ];
        $feedbackgain = $feedbackgain.getkey("source") ||| [ bpf($feedbackgain) ];
        [
            [ "fx" "teeth" ]
            [ "params"
                [ "feedforward" $feedforward ]
                [ "feedback" $feedback ]
                [ "gain" $gain ]
                [ "feedforwardgain" $feedforwardgain ]
                [ "feedbackgain" $feedbackgain ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "teeth",
    @description "Audio process operation for applying comb filtering to a buffer, with feedforward and feedback delay control. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "feedforward", @default 5, @type "int/float/llll", @description "feedforward delay time, in milliseconds, as either a single number, envelope, or buffer.")
        BP_REF_ARG(@name "feedback", @default 10, @type "int/float/llll", @description "feedback delay time, in milliseconds, as either a single number, envelope, or buffer.")
        BP_REF_ARG(@name "gain", @default 0.5, @type "int/float/llll", @description "linear gain, as either a single number, envelope, or buffer.")
        BP_REF_ARG(@name "feedforwardgain", @default 0.5, @type "int/float/llll", @description "linear feedforward gain, as either a single number, envelope, or buffer.")
        BP_REF_ARG(@name "feedbackgain", @default -0.5, @type "int/float/llll", @description "linear feedback gain, as either a single number, envelope, or buffer.")
    ),
    @output BP_REF_OUTPUT(@description "teeth operation" @type "llll")
);

## ------------------------------------------------------------

pong = (
    $low = -1,
    $high = 1,
    $mode = 0 -> (
        $low = $low.getkey("source") ||| [ bpf($low) ];
        $high = $high.getkey("source") ||| [ bpf($high) ];
        [
            [ "fx" "pong" ]
            [ "params"
                [ "pong"
                    [ "mode" $mode ]
                ]
                [ "low" $low ]
                [ "high" $high ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "pong",
    @description "Audio process operation for applying range limiting to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "low", @default -1, @type "int/float/llll", @description "low limit value, as either a single number, envelope, or buffer.")
        BP_REF_ARG(@name "high", @default 1, @type "int/float/llll", @description "high limit value, as either a single number, envelope, or buffer.")
        BP_REF_ARG(@name "mode", @default 0, @type "int", @description "range limiting mode." @options
            BP_REF_OPT(@value 0 @description "fold")
            BP_REF_OPT(@value 1 @description "wrap")
            BP_REF_OPT(@value 2 @description "clip")
        )
    ),
    @output BP_REF_OUTPUT(@description "pong operation" @type "llll")
);

## ------------------------------------------------------------

retune = (
    $pitchgrid = 0,
    $quality = "basic",
    $threshold = 0,
    $ambiencethreshold = 0.3,
    $amount = 100,
    $bypass = 100 -> (
        BP_FN_CHECK_ARGS('retune', 'pitchgrid', $pitchgrid);
        $pitchgrid = $pitchgrid.thin().fmod(12) * 100;
        $len = $pitchgrid.length();
        if $len <= 2 then (
            $pitchgrid = left($pitchgrid :* (4 - $len), 3) + (0 1 2)
        );
        $pitchgrid = $pitchgrid.sort();
        $notebase = $pitchgrid:1;
        $pitchgrid -= $notebase;
        $pitchgrid = right($pitchgrid, 1);
        $notebase = round($notebase * .01);
        [
            [ "fx" "retune" ]
            [ "params"
                [ "retune" 
                    [ "enablednotes" "all" ]
                    [ "notebase" $notebase ]
                    [ "notelist" $pitchgrid ]
                    [ "correction_ambience_threshold" $ambiencethreshold ]
                    [ "correction_amount" $amount ]
                    [ "correction_bypass" $bypass ]
                    [ "correction_threshold" $threshold ]
                    [ "quality" $quality ]
                ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "retune",
    @description "Audio process operation for applying autotune-like pitch retuning to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "pitchgrid", @default 0, @type "int/float/list", @description "pitch grid to retune to, as a list of pitch classes.")
        BP_REF_ARG(@name "threshold" @default 0 @type "int/float" @description "correction threshold.")
        BP_REF_ARG(@name "ambiencethreshold" @default 0.3 @type "int/float" @description "correction ambience threshold, between -10 and 10.")
        BP_REF_ARG(@name "amount" @default 100 @type "int/float" @description "pitch correction amount.")
        BP_REF_ARG(@name "bypass" @default 100 @type "int/float" @description "pitch correction auto-bypass threshold, at which signal passes unaffected.")
        BP_REF_ARG(@name "quality" @default "'basic'" @type "symbol" @description "pitch correction quality." @options
            BP_REF_OPT(@value "'basic'")
            BP_REF_OPT(@value "'good'")
            BP_REF_OPT(@value "'better'")
            BP_REF_OPT(@value "'best'")
        )
    ),
    @output BP_REF_OUTPUT(@description "retune operation" @type "llll")
);

## ------------------------------------------------------------

waveshape = (
    $phase = -1 1,
    $duration = 1000 -> (
        $source = $phase.getkey("source");
        if $source == null then (
            $source = envelope($phase, @duration $duration).getkey("source")
        );
        [
            [ "fx" "waveshape" ]
            [ "params"
                [ "phase" $source ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "waveshape",
    @description "Audio process operation for waveshaping a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "phase", @default -1 1, @type "int/float", @description "buffer phase envelope between -1 and 1, either as an envelope or a buffer.")
        BP_REF_ARG(@name "duration", @default 1000, @type "int", @description "envelope duration in milliseconds. Ignored if @phase is a buffer.")
    ),
    @output BP_REF_OUTPUT(@description "waveshape operation" @type "llll")
);

## ------------------------------------------------------------

scrub = (
    $phase = 0 1,
    $duration = 1000 -> (
        $source = $phase.getkey("source");
        if $source == null then (
            $source = envelope($phase, @duration $duration).getkey("source")
        );
        [
            [ "fx" "scrub" ]
            [ "params"
                [ "phase" $source ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "scrub",
    @description "Audio process operation for scrubbing through a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "phase", @default 0 1, @type "int/float", @description "buffer phase envelope between 0 and 1, either as an envelope or a buffer.")
        BP_REF_ARG(@name "duration", @default 1000, @type "int", @description "envelope duration in milliseconds. Ignored if @phase is a buffer.")
    ),
    @output BP_REF_OUTPUT(@description "scrub operation" @type "llll")
);

## ------------------------------------------------------------

repeat = (
    $duration = 2,
    $timeunit = 2 -> (
        [
            [ "fx" "repeat" ]
            [ "params"
                [ "duration" max(1, $duration) ]
                [ "timeunit" $timeunit ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "repeat",
    @description "Audio process operation for repeating a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "duration", @default 2, @type "int/float", @description "target duration, based on @timeunit.")
        BP_REF_ARG(@name "timeunit", @default 2, @type "int", @description "time unit for @duration." @options
            BP_REF_TIMEUNIT_OPTIONS
        )
    ),
    @output BP_REF_OUTPUT(@description "repeat operation" @type "llll")
);

## ------------------------------------------------------------

scaling = (
    $inmin = 0,
    $inmax = 1,
    $outmin = 0,
    $outmax = 1 -> (
        $inmin = getkey($inmin, "source") ||| [ bpf($inmin) ];
        $inmax = getkey($inmax, "source") ||| [ bpf($inmax) ];
        $outmin = getkey($outmin, "source") ||| [ bpf($outmin) ];
        $outmax = getkey($outmax, "source") ||| [ bpf($outmax) ];
        [
            [ "fx" "scale" ]
            [ "params"
                [ "inmin" $inmin ]
                [ "inmax" $inmax ]
                [ "outmin" $outmin ]
                [ "outmax" $outmax ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "scaling",
    @description "Audio process operation for applying amplitude scaling to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "inmin", @default 0, @type "int/float/llll", @description "input minimum value.")
        BP_REF_ARG(@name "inmax", @default 1, @type "int/float/llll", @description "input maximum value.")
        BP_REF_ARG(@name "outmin", @default 0, @type "int/float/llll", @description "output minimum value.")
        BP_REF_ARG(@name "outmax", @default 1, @type "int/float/llll", @description "output maximum value.")
    ),
    @output BP_REF_OUTPUT(@description "scaling operation" @type "llll")
);

## ------------------------------------------------------------

mix = (
    $buffers = null,
    $gains = null,
    $offsets = null,
    $resamplingfiltersize = 11,
    $resamplingmode = 'sinc',
    $resamplingpolicy = 3,
    $ampunit = 0,
    $envampunit = 0,
    $timeunit = 0,
    $envtimeunit = 2,
    $interp = 0,
    $normalize = 0 -> (
        BP_FN_CHECK_ARGS('mix', 'buffers', $buffers);
        $numbuffers = length($buffers) + 1;
        $buffers = for $buffer in $buffers collect $buffer.process(bpthru()).getkey("source");
        [
            [ "fx" "mix" ]
            [ "params"
                [ "buffers" $buffers ]
                [ "gains" right(1 $gains, -$numbuffers) ]
                [ "offsets" right(0 $offsets, -$numbuffers) ]
                [ "resamplingfiltersize" $resamplingfiltersize ]
                [ "resamplingmode" $resamplingmode ]
                [ "resamplingpolicy" $resamplingpolicy ]
                [ "ampunit" $ampunit ]
                [ "envampunit" $envampunit ]
                [ "timeunit" $timeunit ]
                [ "envtimeunit" $envtimeunit ]
                [ "interp" $interp ]
                [ "normalize" $normalize ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "mix",
    @description "Audio process operation for mixing multiple buffers. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "buffers", @type "list/llll", @description "list of buffers to mix.")
        BP_REF_ARG(@name "gains", @default "null" @type "list/llll/null", @description "gain values for each buffer to mix, as either a single number or envelope.")
        BP_REF_ARG(@name "offsets", @default "null", @type "list/null", @description "time offset values for each buffer to mix.")
        BP_REF_ARG(@name "resamplingfiltersize", @default 11, @type "int", @description "resampling filter size.")
        BP_REF_ARG(@name "resamplingmode", @default "'sinc'", @type "symbol", @description "resampling mode." @options
            BP_REF_RESAMPLINGMODE_OPTIONS
        )
        BP_REF_ARG(@name "resamplingpolicy", @default 3, @type "int", @description "resampling policy." @options
            BP_REF_RESAMPLINGPOLICY_OPTIONS
        )
        BP_REF_ARG(@name "ampunit", @default 0, @type "int", @description "amplitude unit." @options
            BP_REF_AMPUNIT_OPTIONS
        )
        BP_REF_ARG(@name "envampunit", @default 0, @type "int", @description "envelope amplitude unit." @options
            BP_REF_AMPUNIT_OPTIONS
        )
        BP_REF_ARG(@name "timeunit", @default 0, @type "int", @description "time unit." @options
            BP_REF_TIMEUNIT_OPTIONS
        )
        BP_REF_ARG(@name "envtimeunit", @default 2, @type "int", @description "envelope time unit." @options
            BP_REF_TIMEUNIT_OPTIONS
        )
        BP_REF_ARG(@name "interp", @default 0, @type "int", @description "band-limited interpolation via resampling for non-integer offsets." @options 
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "normalize", @default 0, @type "int", @description "normalization." @options 
            BP_REF_NORMALIZE_OPTIONS
        )
    ),
    @output BP_REF_OUTPUT(@description "mix operation" @type "llll")
);

## ------------------------------------------------------------

BP_FN_BUFFER_ARITHMETIC = (
    $name,
    $operand,
    $resamplingfiltersize = 11,
    $resamplingmode = "sinc",
    $resamplingpolicy = 3,
    $envtimeunit = 2 -> (
        BP_FN_CHECK_ARGS($name, 'operand', $operand);

        ## check if @operand is buffer, envelope or scalar.
        $depth = depth($operand);
        $length = length($operand);
        if $depth > 1 || $length > 1 then (
            $source = $operand.getkey("source");
            ## if buffer, assign file to @operand
            if $source != null then (
                $operand = $source
            ) else (
                ## if envelope, clean format and wrap if envelope
                $operand = [ bpf($operand) ]
            )
        );
        [
            [ "fx" "arithmetic" ]
            [ "params"
                [ "operator" $name ]
                [ "operand" left($operand, 1) ]
                [ "resamplingfiltersize" $resamplingfiltersize ]
                [ "resamplingmode" $resamplingmode ]
                [ "resamplingpolicy" $resamplingpolicy ]
                [ "envtimeunit" $envtimeunit ]
            ]
        ]
    )
);

BP_BUFFER_ARITHMETIC_ARGS = (
    BP_REF_ARG(@name "resamplingfiltersize", @default 11, @type "int", @description "resampling filter size.")
    BP_REF_ARG(@name "resamplingmode", @default "'sinc'", @type "symbol", @description "resampling mode." @options
        BP_REF_RESAMPLINGMODE_OPTIONS
    )
    BP_REF_ARG(@name "resamplingpolicy", @default 3, @type "int", @description "resampling policy." @options
        BP_REF_RESAMPLINGPOLICY_OPTIONS
    )
    BP_REF_ARG(@name "envtimeunit", @default 2, @type "int", @description "envelope time unit." @options
        BP_REF_TIMEUNIT_OPTIONS
    )
);

## ------------------------------------------------------------

absolute = (
    -> (
        BP_FN_BUFFER_ARITHMETIC(
            @name "abs"
            @operand 0
        )
    )
);

BP_REF_NEW(
    @name "absolute",
    @description "Audio process operation for computing the absolute value of a buffer signal. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @output BP_REF_OUTPUT(@description "absolute operation" @type "llll")
);

## ------------------------------------------------------------

squareroot = (
    -> (
        BP_FN_BUFFER_ARITHMETIC(
            @name "sqrt"
            @operand 0
        )
    )
);

BP_REF_NEW(
    @name "squareroot",
    @description "Audio process operation for computing the square root of a buffer signal. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @output BP_REF_OUTPUT(@description "squareroot operation" @type "llll")
);

## ------------------------------------------------------------

power = (
    $operand = 2,
    $resamplingfiltersize = 11,
    $resamplingmode = "sinc",
    $resamplingpolicy = 3,
    $envtimeunit = 2 -> (
        BP_FN_BUFFER_ARITHMETIC(
            @name "pow"
            @operand $operand
            @resamplingfiltersize $resamplingfiltersize
            @resamplingmode $resamplingmode
            @resamplingpolicy $resamplingpolicy
            @envtimeunit $envtimeunit
        )
    )
);

BP_REF_NEW(
    @name "power",
    @description "Audio process operation for performing exponentiation on a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "operand", @default 2 @type "int/float/llll", @description "value to raise buffer signal to, either as a single number, envelope, or buffer.")
        BP_BUFFER_ARITHMETIC_ARGS
    ),
    @output BP_REF_OUTPUT(@description "power operation" @type "llll")
);

## ------------------------------------------------------------

plus = (
    $operand,
    $resamplingfiltersize = 11,
    $resamplingmode = "sinc",
    $resamplingpolicy = 3,
    $envtimeunit = 2 -> (
        BP_FN_BUFFER_ARITHMETIC(
            @name "plus"
            @operand $operand
            @resamplingfiltersize $resamplingfiltersize
            @resamplingmode $resamplingmode
            @resamplingpolicy $resamplingpolicy
            @envtimeunit $envtimeunit
        )
    )
);

BP_REF_NEW(
    @name "plus",
    @description "Audio process operation for performing addition on a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "operand", @type "int/float/llll", @description "value to add to buffer, either as a single number, envelope, or buffer.")
        BP_BUFFER_ARITHMETIC_ARGS
    ),
    @output BP_REF_OUTPUT(@description "plus operation" @type "llll")
);

## ------------------------------------------------------------

minus = (
    $operand,
    $resamplingfiltersize = 11,
    $resamplingmode = "sinc",
    $resamplingpolicy = 3,
    $envtimeunit = 2 -> (
        BP_FN_BUFFER_ARITHMETIC(
            @name "minus"
            @operand $operand
            @resamplingfiltersize $resamplingfiltersize
            @resamplingmode $resamplingmode
            @resamplingpolicy $resamplingpolicy
            @envtimeunit $envtimeunit
        )
    )
);

BP_REF_NEW(
    @name "minus",
    @description "Audio process operation for performing subtraction on a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "operand", @type "int/float/llll", @description "value to subtract from buffer, either as a single number, envelope, or buffer.")
        BP_BUFFER_ARITHMETIC_ARGS
    ),
    @output BP_REF_OUTPUT(@description "minus operation" @type "llll")
);

## ------------------------------------------------------------

multiply = (
    $operand,
    $resamplingfiltersize = 11,
    $resamplingmode = "sinc",
    $resamplingpolicy = 3,
    $envtimeunit = 2 -> (
        BP_FN_BUFFER_ARITHMETIC(
            @name "times"
            @operand $operand
            @resamplingfiltersize $resamplingfiltersize
            @resamplingmode $resamplingmode
            @resamplingpolicy $resamplingpolicy
            @envtimeunit $envtimeunit
        )
    )
);

BP_REF_NEW(
    @name "multiply",
    @description "Audio process operation for performing multiplication on a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "operand", @type "int/float/llll", @description "value to multiply buffer by either as a single number, envelope, or buffer.")
        BP_BUFFER_ARITHMETIC_ARGS
    ),
    @output BP_REF_OUTPUT(@description "multiply operation" @type "llll")
);

## ------------------------------------------------------------

divide = (
    $operand,
    $resamplingfiltersize = 11,
    $resamplingmode = "sinc",
    $resamplingpolicy = 3,
    $envtimeunit = 2 -> (
        BP_FN_BUFFER_ARITHMETIC(
            @name "div"
            @operand $operand
            @resamplingfiltersize $resamplingfiltersize
            @resamplingmode $resamplingmode
            @resamplingpolicy $resamplingpolicy
            @envtimeunit $envtimeunit
        )
    )
);

BP_REF_NEW(
    @name "divide",
    @description "Audio process operation for performing division on a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "operand", @type "int/float/llll", @description "value to divide buffer by either as a single number, envelope, or buffer.")
        BP_BUFFER_ARITHMETIC_ARGS
    ),
    @output BP_REF_OUTPUT(@description "divide operation" @type "llll")
);

## ------------------------------------------------------------

wavesetrepeat = (
    $times = 2,
    $span = 1,
    $normalize = 0 -> (
        [
            [ "fx" "wavesetrepeat" ]
            [ "params"
                [ "times" max(1, $times) ]
                [ "span" $span ]
                [ "normalize" $normalize ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "wavesetrepeat",
    @description "Audio process operation for applying waveset repetition to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "times",  @default 2, @type "int", @description "number of repetitions.")
        BP_REF_ARG(@name "span", @default 1, @type "int", @description "number of negative-to-positive zero crossing regions that form a waveset.")
        BP_REF_ARG(@name "normalize", @default 0, @type "int", @description "waveset normalization." @options 
            BP_REF_SWITCH_OPTIONS
        )
    ),
    @output BP_REF_OUTPUT(@description "waveset repeat operation" @type "llll")
);

## ------------------------------------------------------------

wavesetshuffle = (
    $maxdist = 1,
    $span = 1 -> (
        [
            [ "fx" "wavesetshuffle" ]
            [ "params"
                [ "maxdist" $maxdist ]
                [ "span" $span ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "wavesetshuffle",
    @description "Audio process operation for applying waveset shuffling to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "maxdist", @default 1, @type "int", @description "maximum shuffling distance.")
        BP_REF_ARG(@name "span", @default 1, @type "int", @description "number of negative-to-positive zero crossing regions that form a waveset.")
    ),
    @output BP_REF_OUTPUT(@description "waveset shuffle operation" @type "llll")
);

## ------------------------------------------------------------

rampsmooth = (
    $up = 1024,
    $down = 1024 -> (
        $up = $up.getkey("source") ||| [ bpf($up) ];
        $down = $down.getkey("source") ||| [ bpf($down) ];
        [
            [ "fx" "rampsmooth" ]
            [ "params"
                [ "up" $up ]
                [ "down" $down ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "rampsmooth",
    @description "Audio process operation for applying rampsmoothing to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "up", @default 1024, @type "int/list/llll", @description "ramp up, in samples, as either a single number, envelope, or buffer.")
        BP_REF_ARG(@name "down", @default 1024, @type "int/list/llll", @description "ramp down, in samples, as either a single number, envelope, or buffer.")
    ),
    @output BP_REF_OUTPUT(@description "rampsmooth operation" @type "llll")
);

## ------------------------------------------------------------

onepole = (
    $cutoff,
    $highpass = 0 -> (
        BP_FN_CHECK_ARGS('onepole', 'cutoff', $cutoff);
        [
            [ "fx" "onepole" ]
            [ "params"
                [ "cutoff" $cutoff ]
                [ "highpass" $highpass ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "onepole",
    @description "Audio process operation for applying single-pole lowpass or highpass filtering to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "cutoff", @default 1, @type "int/float", @description "cutoff frequency.")
        BP_REF_ARG(@name "highpass", @default 0, @type "int", @description "highpass filter mode." @options
            BP_REF_SWITCH_OPTIONS
        )
    ),
    @output BP_REF_OUTPUT(@description "onepole operation" @type "llll")
);

## ------------------------------------------------------------

mixdown = (
    $numchannels = 1,
    $channelmode = 3,
    $autogain = 0 -> (
        [
            [ "fx" "mixdown" ]
            [ "params"
                [ "numchannels" $numchannels ]
                [ "channelmode" $channelmode ]
                [ "autogain" $autogain ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "mixdown",
    @description "Audio process operation for mixing down (or up) the number of channels of a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "numchannels", @default 1, @type "int", @description "number of output channels.")
        BP_REF_ARG(@name "channelmode", @default 3, @type "int", @description "downmixing channel conversion type." @options 
            BP_REF_OPT(@value 0, @description "delete" "all" "samples")
            BP_REF_OPT(@value 1, @description "only" "keep" "existing channels")
            BP_REF_OPT(@value 2, @description "pad" "last" "channel")
            BP_REF_OPT(@value 3, @description "cyclic" "repetition" "of" "channels" "while" "upmixing.")
            BP_REF_OPT(@value 4, @description "palindrome" "cycling" "of" "channels" "while" "upmixing.")
            BP_REF_OPT(@value 5, @description "pan" "channels" "to" "new" "configuration")
        )
        BP_REF_ARG(@name "autogain", @default 0, @type "int", @description "apply audio compensation, based on ratio between input and output channels." @options
            BP_REF_SWITCH_OPTIONS
        )
    ),
    @output BP_REF_OUTPUT(@description "onepole operation" @type "llll")
);

## ------------------------------------------------------------

fromdiffs = (
    -> (
        [
            [ "fx" "fromdiffs" ]
            [ "params" ]
        ]
    )
);

BP_REF_NEW(
    @name "fromdiffs",
    @description "Audio process operation to perform discrete integration of a buffer. This is the equivalent of #dx2x for buffer samples. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments null
    @output BP_REF_OUTPUT(@description "fromdiffs operation" @type "llll")
);

## ------------------------------------------------------------

todiffs = (
    -> (
        [
            [ "fx" "todiffs" ]
            [ "params" ]
        ]
    )
);

BP_REF_NEW(
    @name "todiffs",
    @description "Audio process operation to perform discrete differentiation of a buffer. This is the equivalent of #x2dx for buffer samples. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments null
    @output BP_REF_OUTPUT(@description "todiffs operation" @type "llll")
);

## ------------------------------------------------------------

join = (
    $buffers,
    $xfade = 0,
    $xfadecurve = 0,
    $xfadetype = 1,
    $fadeboundaries = 0,
    $timeunit = 0,
    $resamplingfiltersize = 11,
    $resamplingmode = 'sinc',
    $resamplingpolicy = 3 -> (
        BP_FN_CHECK_ARGS('join', 'buffers', $buffers);
        $buffers = for $buffer in $buffers collect (
            $source = $buffer.getkey("source");
            if $source == null then (
                BP_FN_ERROR('join', 'invalid buffer:' $buffer)
            ) else (
                $buffer.process(bpthru()).getkey("source")
            )
        );
        [
            [ "fx" "join" ]
            [ "params"
                [ "buffers" $buffers ]
                [ "timeunit" $timeunit ]
                [ "xfadecurve" $xfadecurve ]
                [ "xfade" $xfade ]
                [ "xfadetype" $xfadetype + 1 ]
                [ "fadeboundaries" $fadeboundaries ]
                [ "resamplingfiltersize" $resamplingfiltersize ]
                [ "resamplingmode" $resamplingmode ]
                [ "resamplingpolicy" $resamplingpolicy ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "join",
    @description "Audio process operation for concatenating one or more buffers to the processed buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "buffers", @type "llll", @description "buffers to concatenate.")
        BP_REF_ARG(@name "xfade", @default 0, @type "int/float", @description "duration of the crossfade, in samples.")
        BP_REF_ARG(@name "xfadecurve", @default 0, @type "int/float", @description "curve parameter for the crossfade.")
        BP_REF_ARG(@name "xfadetype", @default 1, @type "int", @description "cross fade type." @options 
            BP_REF_CURVE_OPTIONS
        )
        BP_REF_ARG(@name "fadeboundaries", @default 0, @type "int", @description "fade beginning of first buffer and end of last buffer." @options
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "timeunit", @default 0, @type "int", @description "time unit." @options
            BP_REF_TIMEUNIT_OPTIONS
        )
        BP_REF_ARG(@name "resamplingfiltersize", @default 11, @type "int", @description "resampling filter size.")
        BP_REF_ARG(@name "resamplingmode", @default "'sinc'", @type "symbol", @description "resampling mode." @options
            BP_REF_RESAMPLINGMODE_OPTIONS
        )
        BP_REF_ARG(@name "resamplingpolicy", @default 3, @type "int", @description "resampling policy." @options
            BP_REF_RESAMPLINGPOLICY_OPTIONS
        )
    ),
    @output BP_REF_OUTPUT(@description "join operation" @type "llll")
);

## ------------------------------------------------------------

trim = (
    $threshold = 0.01,
    $ampunit = 0,
    $start = 1,
    $end = 1 -> (
        [
            [ "fx" "trim" ]
            [ "params"
                [ "ampunit" $ampunit ]
                [ "start" $start ]
                [ "end" $end ]
                [ "thresh" $threshold ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "trim",
    @description "Audio process operation for applying silence-based trimming to a buffer. When the entire buffer is considered silent, the resulting buffer's duration will be a single audio sample. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "threshold" @default 0.01 @type "int/float", @description "amplitude threshold at/below which samples are considered silence.")
        BP_REF_ARG(@name "ampunit", @default 0, @type "int", @description "amplitude unit for @threshold." @options
            BP_REF_AMPUNIT_OPTIONS
        )
        BP_REF_ARG(@name "start" @default 1 @type "int/float", @description "trim the beginning of the buffer." @options 
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "end" @default 1 @type "int/float", @description "trim the end of the buffer." @options 
            BP_REF_SWITCH_OPTIONS
        )
    ),
    @output BP_REF_OUTPUT(@description "join operation" @type "llll")
);

## ------------------------------------------------------------

timesquash = (
    $duration = 1,
    $timeunit = 2, 
    $timeblock = 4096,
    $mode = 1,
    $xfade = 4096,
    $xfadecurve = 0,
    $xfadetype = 1,
    $glbleed = 4,
    $glnumiter = 10,
    $glrandomize = 0,
    $glrect = 1,
    $batchsize = 1,
    $batchinterrupt = 0,
    $energy = 2,
    $forwardenergy = 1.,
    $forwardenergyembed = 1,
    $forwardenergytype = 1,
    $framesize = 2048,
    $hopsize = 1024,
    $phasehandling = 2,
    $regularization = 0.01,
    $wintype = "sqrthann" "sqrthann" -> (
        [
            [ "fx" "timesquash" ]
            [ "params"
                [ "duration" $duration ]
                [ "mode" $mode ]
                [ "timeblock" $timeblock ]
                [ "xfade" $xfade ]
                [ "xfadecurve" $xfadecurve ]
                [ "xfadetype" $xfadetype + 1 ]
                [ "glbleed" $glbleed ]
                [ "glnumiter" $glnumiter ]
                [ "glrandomize" $glrandomize ]
                [ "glrect" $glrect ]
                [ "batchsize" $batchsize ]
                [ "energy" $energy ]
                [ "forwardenergy" $forwardenergy ]
                [ "forwardenergyembed" $forwardenergyembed ]
                [ "forwardenergytype" $forwardenergytype ]
                [ "batchinterrupt" $batchinterrupt ]
                [ "phasehandling" $phasehandling ]
                [ "regularization" $regularization ]
                [ "hopsize" $hopsize ]
                [ "framesize" $framesize ]
                [ "wintype" $wintype ]
                [ "timeunit" $timeunit ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "timesquash",
    @description "Audio process operation for applying timesquash time compression to a buffer. This removes time from a sample by shifting portions of the spectrogram while preserving the relevant content. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "duration", @default 1, @type "int/float", @description "target duration, based on @timeunit.")
        BP_REF_ARG(@name "timeunit", @default 2, @type "int", @description "time unit for @duration."
            BP_REF_TIMEUNIT_OPTIONS
        )
        BP_REF_ARG(@name "timeblock", @default 4096, @type "int", @description "duration of each time block to be removed.")
        BP_REF_ARG(@name "mode", @default 1, @type "int", @description "working mode." @options 
            BP_REF_AUDIO_DOMAIN_OPTIONS
        )
        BP_REF_ARG(@name "xfade", @default 4096, @type "int/float", @description "duration of the crossfade, in samples.")
        BP_REF_ARG(@name "xfadecurve", @default 0, @type "int/float", @description "curve parameter for the crossfade.")
        BP_REF_ARG(@name "xfadetype", @default 1, @type "int", @description "cross fade type." @options 
            BP_REF_CURVE_OPTIONS
        )
        BP_REF_ARG(@name "glbleed", @default 4, @type "int", @description "number of frames of invalidation for the Griffin-Lim algorithm, when @phasehandling is 2.")
        BP_REF_ARG(@name "glnumiter", @default 10, @type "int", @description "number of Griffin-Lim iterations, when @phasehandling is 2.")
        BP_REF_ARG(@name "glrandomize", @default 0, @type "int", @description "randomize the phases of the regions subject to the Griffin-Lim algorithm, when @phasehandling is 2." @options
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "glrect", @default 1, @type "int", @description "invalidate whole rectangular regions whose phases are recomputed via the Griffin-Lim algorithm, when @phasehandling is 2." @options 
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "batchsize", @default 1, @type "int", @description "number of seams processed in batch.")
        BP_REF_ARG(@name "batchinterrupt", @default 0, @type "int", @description "interrupt batch when crossing.")
        BP_REF_ARG(@name "energy", @default 2, @type "int", @description "energy function used for computing seams." @options
            BP_REF_OPT(@value 0, @description "magnitude")
            BP_REF_OPT(@value 1, @description "gradient" "magnitude")
            BP_REF_OPT(@value 2, @description "Sobel")
        )
        BP_REF_ARG(@name "forwardenergy", @default 1, @type "int/float", @description "amount of forward energy contribution.")
        BP_REF_ARG(@name "forwardenergyembed", @default 1, @type "int", @description "embed forward energy in cumulative matrix." @options
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "forwardenergytype", @default 1, @type "int", @description "forward energy type." @options
            BP_REF_OPT(@value 0, @description "gradient" "L1" "norm")
            BP_REF_OPT(@value 1, @description "energy" "L2" "norm")
        )
        BP_REF_ARG(@name "framesize", @default 2048, @type "int", @description "window size, in samples")
        BP_REF_ARG(@name "hopsize", @default 1024, @type "int", @description "hop size, in samples")
        BP_REF_ARG(@name "phasehandling", @default 2, @type "int", @description "phase handling mode." @options
            BP_REF_OPT(@value 0, @description "keep")
            BP_REF_OPT(@value 1, @description "compensate")
            BP_REF_OPT(@value 2, @description "Griffin-Lim")
        )
        BP_REF_ARG(@name "regularization", @default 0.01, @type "int/float", @description "how much energy of a bin smears on the ones above and below, between 0 and 1.")
        BP_REF_ARG(@name "wintype", @default "'sqrthann'" "'sqrthann'", @type "list/symbol", @description "window type." @options BP_REF_WINDOW_OPTIONS)
    ),
    @output BP_REF_OUTPUT(@description "timesquash operation" @type "llll")
);

## ------------------------------------------------------------

resample = (
    $duration = 1,
    $timeunit = 2,
    $changesr = 0,
    $antimeunit = 1,
    $resamplingmode = "sinc",
    $resamplingfiltersize = 11 -> (
        if length($duration) > 1 || depth($duration) > 1 then ($duration = [ bpf($duration) ]);
        [
            [ "fx" "resample" ]
            [ "params"
                [ "duration" $duration ]
                [ "timeunit" $timeunit ]
                [ "changesr" $changesr ]
                [ "antimeunit" $antimeunit ]
                [ "resamplingmode" $resamplingmode ]
                [ "resamplingfiltersize" $resamplingfiltersize ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "resample",
    @description "Audio process operation for applying stretching/pitch shifting a buffer via resampling. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "duration", @default 1, @type "int/float", @description "target duration, based on @timeunit.")
        BP_REF_ARG(@name "timeunit", @default 2, @type "int", @description "time unit for @duration." @options 
            BP_REF_TIMEUNIT_OPTIONS
        )
        BP_REF_ARG(@name "changesr", @default 0, @type "int", @description "change sampling rate." @options
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "antimeunit", @default 1, @type "int", @description "time unit for analysis." @options 
            BP_REF_TIMEUNIT_OPTIONS
        )
        BP_REF_ARG(@name "resamplingmode", @default "'sinc'", @type "symbol", @description "resampling mode." @options
            BP_REF_RESAMPLINGMODE_OPTIONS
        )
        BP_REF_ARG(@name "resamplingfiltersize", @default 11, @type "int", @description "resampling filter size.")
    ),
    @output BP_REF_OUTPUT(@description "resample operation" @type "llll")
);

## ------------------------------------------------------------

panning = (
    $position = 0.5,
    $numchannels = 2,
    $panmode = 0,
    $panlaw = 1,
    $rangetype = 1,
    $range = 0. 1.,
    $compensate = 1,
    $spread = 1,    
    $envtimeunit = 2 -> (
        $source = $position.getkey("source");
        if $source != null then (
            $position = $source
        ) else if length($position) > 1 || depth($position) > 1 then (
            $position = [ bpf($position) ]
        );
        [
            [ "fx" "panning" ]
            [ "params"
                [ "position" $position ]
                [ "numchannels" $numchannels ]
                [ "panlaw" $panlaw ]
                [ "panmode" $panmode ]
                [ "rangetype" $rangetype ]
                [ "range" $range ]
                [ "compensate" $compensate ]
                [ "envtimeunit" $envtimeunit ]
                [ "spread" $spread ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "panning",
    @description "Audio process operation for applying 1-D panning to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "position" @type "int/float/list/llll", @description "panning position, as either a single number, envelope, or buffer.")
        BP_REF_ARG(@name "numchannels", @default 2, @type "int", @description "number of output channels.")
        BP_REF_ARG(@name "panmode", @type "int", @default 0, @description "panning mode." @options 
            BP_REF_OPT(@value 0, @description "linear")
            BP_REF_OPT(@value 1, @description "circular")
        )
        BP_REF_ARG(@name "panlaw", @default 1, @type "int", @description "panning law." @options 
            BP_REF_OPT(@value 0 @description "nearest" "neighbor")
            BP_REF_OPT(@value 1 @description "cosine")
        )
        BP_REF_ARG(@name "rangetype", @default 1, @type "int", @description "panning range type." @options
            BP_REF_OPT(@value 0 @description "custom")
            BP_REF_OPT(@value 1 @description "0" "to" "1")
            BP_REF_OPT(@value 2 @description "-1" "to" "1")
            BP_REF_OPT(@value 3 @description "loudspeaker" "number" "—" "0-based")
            BP_REF_OPT(@value 4 @description "loudspeaker" "number" "—" "1-based")
        )
        BP_REF_ARG(@name "range", @default 0 1, @type "list", @description "panning range, as a <min> <max> value pair. Ignored unless @rangetype is 0")
        BP_REF_ARG(@name "compensate", @default 1, @type "int", @description "Reduce gain for multichannel files by a factor of the number of channels." @options
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "spread", @type "int/float", @default 1, @description "multichannel panning spread, between 0 and 1.")
        BP_REF_ARG(@name "envtimeunit", @default 2, @type "int", @description "time unit for @gain envelope." @options
            BP_REF_TIMEUNIT_OPTIONS
        )
    ),
    @output BP_REF_OUTPUT(@description "panning operation" @type "llll")
);

## ------------------------------------------------------------

normalize = (
    $level = -6,
    $mix = 1,
    $rms = 0,
    $ampunit = 1 -> (
        [
            [ "fx" "normalize" ]
            [ "params"
                [ "ampunit" $ampunit ]
                [ "rms" $rms ]
                [ "level" $level ]
                [ "mix" $mix ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "normalize",
    @description "Audio process operation for normalizing the amplitude of a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "level", @default -6, @type "int/float", @description "reference level.")
        BP_REF_ARG(@name "mix", @default 1, @type "int", @description "dry/wet mix, between 0 and 1.")
        BP_REF_ARG(@name "rms", @default 0, @type "int", @description "use root mean square." @options
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "ampunit", @default 1, @type "int", @description "amplitude unit for @level." @options
            BP_REF_AMPUNIT_OPTIONS
        )
    ),
    @output BP_REF_OUTPUT(@description "normalize operation" @type "llll")
);

## ------------------------------------------------------------

gain = (
    $gain,
    $resamplingfiltersize = 11,
    $resamplingmode = 'sinc',
    $ampunit = 0,
    $envampunit = 0,
    $envtimeunit = 2 -> (
        BP_FN_CHECK_ARGS('gain', 'gain', $gain);
        $gain = $gain.getkey("source") ||| [ bpf($gain) ];
        [
            [ "fx" "gain" ]
            [ "params"
                [ "gain" $gain ]
                [ "resamplingfiltersize" $resamplingfiltersize ]
                [ "resamplingmode" $resamplingmode ]
                [ "ampunit" $ampunit ]
                [ "envampunit" $envampunit ]
                [ "envtimeunit" $envtimeunit ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "gain",
    @description "Audio process operation for modifying a buffer's gain. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "gain", @type "int/float/llll", @description "gain amount, as either a single number or envelope.")
        BP_REF_ARG(@name "resamplingfiltersize", @default 11, @type "int", @description "resampling filter size, in samples.")
        BP_REF_ARG(@name "resamplingmode", @default "'sinc'", @type "symbol", @description "resampling mode." @options
            BP_REF_RESAMPLINGMODE_OPTIONS
        )
        BP_REF_ARG(@name "ampunit", @default 0, @type "int", @description "amplitude unit." @options
            BP_REF_AMPUNIT_OPTIONS
        )
        BP_REF_ARG(@name "envampunit", @default 0, @type "int", @description "amplitude unit for @gain envelope." @options
            BP_REF_AMPUNIT_OPTIONS
        )
        BP_REF_ARG(@name "envtimeunit", @default 2, @type "int", @description "time unit for @gain envelope." @options
            BP_REF_TIMEUNIT_OPTIONS
        )
    ),
    @output BP_REF_OUTPUT(@description "gain operation" @type "llll")
);

## ------------------------------------------------------------

dynamics = (
    $attack = 10,
    $release = 50,
    $knee = 0.7,
    $makeup = 0,
    $ratio = 1.5,
    $thresh = -20.,
    $ampunit = 1,
    $timeunit = 0 -> (
        [
            [ "fx" "dynamics" ]
            [ "params"
                [ "attack" $attack ]
                [ "release" $release ]
                [ "knee" $knee ]
                [ "makeup" $makeup ]
                [ "ratio" $ratio ]
                [ "thresh" $thresh ]
                [ "ampunit" $ampunit ]
                [ "timeunit" $timeunit ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "dynamics",
    @description "Audio process operation for applying simple compression to a buffer. See #process.",
    @category BP_REF_LABEL_PROCESS,
    @arguments (
        BP_REF_ARG(@name "attack", @default 10, @type "int/float", @description "attack time.")
        BP_REF_ARG(@name "release", @default 50, @type "int/float", @description "release time.")
        BP_REF_ARG(@name "knee", @default 0.7, @type "int/float", @description "knee width.")
        BP_REF_ARG(@name "makeup", @default 0, @type "int/float", @description "make-up gain.")
        BP_REF_ARG(@name "ratio", @default 1.5, @type "int/float", @description "compression ratio.")
        BP_REF_ARG(@name "thresh", @default -20, @type "int/float", @description "amplitude threshold.")
        BP_REF_ARG(@name "ampunit", @default 1, @type "int", @description "amplitude unit." @options
            BP_REF_AMPUNIT_OPTIONS
        )
        BP_REF_ARG(@name "timeunit", @default 0, @type "int", @description "time unit." @options
            BP_REF_TIMEUNIT_OPTIONS
        )
    ),
    @output BP_REF_OUTPUT(@description "dynamics operation" @type "llll")
);

## ------------------------------------------------------------

buf2ptracks = (
    $buffer,
    $winstartfromzero = 0,
    $framesize = 2048,
    $hopsize = 512,
    $freqdevoffset = 20,
    $freqdevslope = 0.01,
    $magnitudethreshold = 0.0002,
    $maxfrequency = 22050,
    $minfrequency = 0,
    $maxpeaks = 100,
    $maxnsines = 100,
    $numframes = 'auto',
    $orderby = 'frequency',
    $overlap = 4,
    $wintype = 'hann',
    $ampunit = 0,
    $antimeunit = 1,
    $angleunit = 0,
    $frequnit = 0,
    $timeunit = 0,
    $downmix = 1 -> (
        $self = 'buf2ptracks';
        BP_FN_CHECK_ARGS($self, 'buffer', $buffer);
        BP_FN_VALIDATE_BUFFER($self, $buffer);
        $source = $buffer.process(bpthru()).getkey("source");
        BP_FN_DISPATCH("resynth", 
            [ "analysis" 
                [ "winstartfromzero" $winstartfromzero ]
                [ "framesize" $framesize ]
                [ "freqdevoffset" $freqdevoffset ]
                [ "freqdevslope" $freqdevslope ]
                [ "hopsize" $hopsize ]
                [ "magnitudethreshold" $magnitudethreshold ]
                [ "maxfrequency" $maxfrequency ]
                [ "maxpeaks" $maxpeaks ]
                [ "maxnsines" $maxnsines ]
                [ "minfrequency" $minfrequency ]
                [ "numframes" $numframes ]
                [ "orderby" $orderby ]
                [ "overlap" $overlap ]
                [ "wintype" $wintype ]
                [ "ampunit" $ampunit ]
                [ "antimeunit" $antimeunit ]
                [ "angleunit" $angleunit ]
                [ "frequnit" $frequnit ]
                [ "timeunit" $timeunit ]
                [ "downmix" $downmix ]
                $source 
            ]
        );
        [ BP_RESYNTH_ANALYSIS ]
    )
);

topartialtracks = (
    $buffer,
    $winstartfromzero = 0,
    $framesize = 2048,
    $hopsize = 512,
    $freqdevoffset = 20,
    $freqdevslope = 0.01,
    $magnitudethreshold = 0.0002,
    $maxfrequency = 22050,
    $minfrequency = 0,
    $maxpeaks = 100,
    $maxnsines = 100,
    $numframes = 'auto',
    $orderby = 'frequency',
    $overlap = 4,
    $wintype = 'hann',
    $ampunit = 0,
    $antimeunit = 1,
    $angleunit = 0,
    $frequnit = 0,
    $timeunit = 0,
    $downmix = 1 -> (
        BP_FN_WARNING('topartialtracks', 'this function will be deprecated. Use instead buf2ptracks.');
        buf2ptracks(
            @buffer $buffer
            @winstartfromzero $winstartfromzero
            @framesize $framesize
            @hopsize $hopsize
            @freqdevoffset $freqdevoffset
            @freqdevslope $freqdevslope
            @magnitudethreshold $magnitudethreshold
            @maxfrequency $maxfrequency
            @minfrequency $minfrequency
            @maxpeaks $maxpeaks
            @maxnsines $maxnsines
            @numframes $numframes
            @orderby $orderby
            @overlap $overlap
            @wintype $wintype
            @ampunit $ampunit
            @antimeunit $antimeunit
            @angleunit $angleunit
            @frequnit $frequnit
            @timeunit $timeunit
            @downmix $downmix
        )
    )
);

BP_REF_NEW(
    @name "buf2ptracks",
    @description "Converts a buffer into a partial track analysis.",
    @category BP_REF_LABEL_ANALYSIS,
    @arguments (
        BP_REF_ARG(@name "buffer" @type "llll" @description "buffer to analyze.")
        BP_REF_ARG(@name "winstartfromzero", @default 0, @type "int", @description "first window starts at zero" @options
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "framesize", @default 2048, @type "int", @description "window size, in samples.")
        BP_REF_ARG(@name "hopsize", @default 512, @type "int", @description "hop size, in samples.")
        BP_REF_ARG(@name "freqdevoffset" @default 20 @type "int" @description "frequency deviation offset.")
        BP_REF_ARG(@name "freqdevslope" @default 0.01 @type "int/float" @description "frequency deviation slope.")
        BP_REF_ARG(@name "magnitudethreshold", @default 2e-4, @type "float", @description "peak amplitude threshold.")
        BP_REF_ARG(@name "maxfrequency", @default 22050, @type "int/float", @description "max. frequency of the range to evaluate.")
        BP_REF_ARG(@name "minfrequency", @default 0, @type "int/float", @description "min. frequency of the range to evaluate.")
        BP_REF_ARG(@name "maxpeaks", @default 100, @type "int", @description "max. number of returned peaks.")
        BP_REF_ARG(@name "maxnsines", @default 100, @type "int", @description "max. number of sines per frame.")
        BP_REF_ARG(@name "numframes" @default "'auto'" @type "int/symbol" @description "number of frames.")
        BP_REF_ARG(@name "orderby" @default "'frequency'" @type "symbol" @description "ordering feature." @options 
            BP_REF_OPT(@value "'frequency'")
            BP_REF_OPT(@value "'magnitude'")
        )
        BP_REF_ARG(@name "overlap" @default 4 @type "int" @description "overlap.")
        BP_REF_ARG(@name "wintype", @default "'hann'", @type "symbol", @description "window type." @options 
            BP_REF_WINDOW_OPTIONS
        )
        BP_REF_ARG(@name "ampunit" @default 0 @type "int" @description "amplitude unit." @options 
            BP_REF_AMPUNIT_OPTIONS
        )
        BP_REF_ARG(@name "antimeunit" @default 1 @type "int" @description "analysis time unit." @options 
            BP_REF_TIMEUNIT_OPTIONS
        )
        BP_REF_ARG(@name "angleunit" @default 0 @type "int" @description "angle unit." @options 
            BP_REF_ANGLEUNIT_OPTIONS
        )
        BP_REF_ARG(@name "frequnit", @default 0, @type "int", @description "unit for frequency components in @func." @options 
            BP_REF_FREQUNIT_OPTIONS
        )
        BP_REF_ARG(@name "timeunit" @default 0 @type "int" @description "time unit." @options 
            BP_REF_TIMEUNIT_OPTIONS
        )
        BP_REF_ARG(@name "downmix" @default 1 @type "int" @description "downmix buffer." @options 
            BP_REF_SWITCH_OPTIONS
        )
        ## BP_REF_ARG(@name "stochastic", @default 0, @type "int", @description "analysis/resynthesis mode." @options
        ##     BP_REF_OPT(@value 0 @description "sinusoidal")
        ##     BP_REF_OPT(@value 1 @description "stochastic" "+" "sinusoidal")
        ## )
        ## BP_REF_ARG(@name "stocf", @default 0.2, @type "int/float", @description "decimation factor of stochastic approximation. Ignored if @stochastic is 0.")
    ),
    @output BP_REF_OUTPUT(@description "partial track analysis" @type "llll")
);

## ------------------------------------------------------------

ptracks2buf = (
    $frequencies = null,
    $magnitudes = null,
    $phases = null,
    $framesize = 2048,
    $hopsize = 512,
    $ampunit = 0,
    $antimeunit = 1,
    $angleunit = 0,
    $frequnit = 0 -> (
        BP_FN_CHECK_ARGS('ptracks2buf', 'frequencies', $frequencies, 'magnitudes', $magnitudes, 'phases', $phases);
        BP_FN_DISPATCH("resynth", 
            [ "synthesis" 
                [ "params"
                    [ "framesize" $framesize ]
                    [ "hopsize" $hopsize ]
                    [ "ampunit" $ampunit ]
                    [ "antimeunit" $antimeunit ]
                    [ "angleunit" $angleunit ]
                    [ "frequnit" $frequnit ]
                ]
                [ "phases" $phases ]
                [ "magnitudes" $magnitudes ]
                [ "frequencies" $frequencies ]
            ]
        );
        BP_FN_NEWBUFF(@source BP_RESYNTH_SYNTHESIS)
    )
);

frompartialtracks = (
    $frequencies,
    $magnitudes,
    $phases,
    $framesize = 2048,
    $hopsize = 512,
    $ampunit = 0,
    $antimeunit = 1,
    $angleunit = 0,
    $frequnit = 0 -> (
        BP_FN_WARNING('frompartialtracks', 'this function will be deprecated. Use instead ptracks2buf');
        ptracks2buf(
            @frequencies $frequencies
            @magnitudes $magnitudes
            @phases $phases
            @framesize $framesize
            @hopsize $hopsize
            @ampunit $ampunit
            @antimeunit $antimeunit
            @angleunit $angleunit
            @frequnit $frequnit
        )
    )
);

BP_REF_NEW(
    @name "ptracks2buf",
    @description "Converts a partial track analysis into a buffer.",
    @category BP_REF_LABEL_GEN,
    @arguments (
        BP_REF_ARG(@name "frequencies" @type "llll")
        BP_REF_ARG(@name "magnitudes" @type "llll")
        BP_REF_ARG(@name "phases" @type "llll")
        BP_REF_ARG(@name "framesize" @default 2048 @type "int")
        BP_REF_ARG(@name "hopsize" @default 512 @type "int")
        BP_REF_ARG(@name "ampunit" @default 0 @type "int" @description "amplitude unit." @options 
            BP_REF_AMPUNIT_OPTIONS
        )
        BP_REF_ARG(@name "antimeunit" @default 1 @type "int" @description "analysis time unit." @options 
            BP_REF_TIMEUNIT_OPTIONS
        )
        BP_REF_ARG(@name "angleunit" @default 0 @type "int" @description "angle unit." @options 
            BP_REF_OPT(@value 0 @description "'radians'")
            BP_REF_OPT(@value 1 @description "'degrees'")
            BP_REF_OPT(@value 2 @description "'turns'")
        )
        BP_REF_ARG(@name "frequnit", @default 0, @type "int", @description "unit for frequency components in @func." @options 
            BP_REF_FREQUNIT_OPTIONS
        )
    ),
    @output BP_REF_OUTPUT(@description "buffer" @type "llll")
);

## ------------------------------------------------------------

buf2samps = (
    $buffer -> (
        BP_FN_VALIDATE_BUFFER('buf2samps', $buffer);
        $source = $buffer.process(bpthru()).getkey("source");
        BP_FN_DISPATCH('ears', ['tosamps' $source]);
        BP_TMP_EARS_OUTPUT
        
    )
);

BP_REF_NEW(
    @name "buf2samps"
    @description "Buffer to samples conversion.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "buffer", @type "llll", @description "buffer to convert to audio samples.")
    )
    @output BP_REF_OUTPUT(@description "buffer samples as a llll" @type "llll")
);

## ------------------------------------------------------------

samps2buf = (
    $llll,
    $sr = 0 -> (
        $self = 'samps2buf';
        BP_FN_CHECK_ARGS($self, 'llll', $llll);
        if depth($llll) != 2 then (
            BP_FN_ERROR($self, '@llll must have a depth of 2')
        ) else (
            BP_FN_DISPATCH('ears', 
                ['fromsamps' 
                    ['sr' $sr]
                    ['source' $llll]
                ]
            );
            $source = BP_TMP_EARS_OUTPUT;
            BP_FN_NEWBUFF($source).process(bpthru())
        )
    )
);

BP_REF_NEW(
    @name "samps2buf"
    @description "Samples to buffer conversion."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "llll" @type "llll" @description "audio samples to convert to a buffer.")
        BP_REF_ARG(@name "sr" @type "int" @default 0 @description "sampling rate. use 0 for default sampling rate.")
    )
    @output BP_REF_OUTPUT(@description "buffer" @type "llll")
);

## ------------------------------------------------------------

hoaencode = (
    $azimuth = 0,
    $elevation = 0,
    $distance = 1,
    $order = 1,
    $coordtype = 'aed',
    $dimension = '3D',
    $angleunit = 0,
    $envtimeunit = 2 -> (
        [
            [ "fx" "hoaencode" ]
            [ "params"
                [ 'azimuth' if depth($azimuth) > 1 || length($azimuth) > 1 then [ bpf($azimuth) ] else $azimuth ]
                [ 'elevation' if depth($elevation) > 1 || length($elevation) > 1 then [ bpf($elevation) ] else $elevation ]
                [ 'distance' if depth($distance) > 1 || length($distance) > 1 then [ bpf($distance) ] else $distance ]
                [ 'order' $order ]
                [ 'angleunit' $angleunit ]
                [ 'envtimeunit' $envtimeunit ]
                [ 'coordtype' $coordtype ]
                [ 'dimension' $dimension ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "hoaencode",
    @description "Audio process operation for panning the input buffer and encode it as a higher-order ambisonic buffer",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "azimuth" @default 0 @type "int/float/llll" @description "azimuth or X coordinate.")
        BP_REF_ARG(@name "elevation" @default 0 @type "int/float/llll" @description "elevation or y coordinate.")
        BP_REF_ARG(@name "distance" @default 1 @type "int/float/llll" @description "distance or Z coordinate.")
        BP_REF_ARG(@name "order" @default 1 @type "int" @description "ambisonics order.")
        BP_REF_ARG(@name "coordtype" @default "'aed'" @type "symbol" @description "input coordinate type" @options
            BP_REF_OPT(@value "'aed'" @description "azimuth, elevation, and distance; or spherical coordinates.")
            BP_REF_OPT(@value "'xyz'" @description "cartesian coordinates.")
            BP_REF_OPT(@value "'azr'" @description "azimuth, Z, axial radius; or cylindrical coordinates.")
        )
        BP_REF_ARG(@name "dimension" @default "'3D'" @type "symbol" @description "dimensionality of ambisonics" @options 
            BP_REF_OPT(@value "'2D'" @description "2-dimensional.")
            BP_REF_OPT(@value "'3D'" @description "3-dimensional.")
        )
        BP_REF_ARG(@name "angleunit" @default 0 @type "int" @description "unit for angles" @options 
            BP_REF_ANGLEUNIT_OPTIONS
        )
        BP_REF_ARG(@name "envtimeunit" @default 0 @type "int" @description "unit for time values inside envelopes/bpfs." @options
            BP_REF_TIMEUNIT_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "higher-order ambisonics encoding operation" @type "llll")
);

## ------------------------------------------------------------

hoadecode = (
    $azimuth = pi * (1/4 3/4 -3/4 -1/4),
    $elevation = 0 0 0 0,
    $binaural = 1,
    $dimension = '3D',
    $blocksamps = 64,
    $angleunit = 0 -> (
        [
            [ "fx" "hoadecode" ]
            [ "params"
                [ 'binaural' $binaural ]
                [ 'blocksamps' $blocksamps ]
                [ 'dimension' $dimension ]
                [ 'azimuth' $azimuth ]
                [ 'elevation' $elevation ]
                [ 'angleunit' $angleunit ]
            ]
        ]
    )
);

BP_REF_NEW(
    @name "hoadecode",
    @description "Audio process operation for decoding higher-order ambisonic buffers for a set of loudspeakers or for binaural listening",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "azimuth" @default 0.78 2.35 @type "int/float/llll" @description "azimuth or X coordinate, for each loudspeaker.")
        BP_REF_ARG(@name "elevation" @default 0 0 @type "int/float/llll" @description "elevation or y coordinate.")
        BP_REF_ARG(@name "binaural" @default 1 @type "int/float/llll" @description "binaural mode." @options
            BP_REF_SWITCH_OPTIONS
        )
        BP_REF_ARG(@name "dimension" @default "'3D'" @type "symbol" @description "dimensionality of ambisonics" @options 
            BP_REF_OPT(@value "'2D'" @description "2-dimensional.")
            BP_REF_OPT(@value "'3D'" @description "3-dimensional.")
        )
        BP_REF_ARG(@name "blocksamps" @default 64 @type "int" @description "decoding block size in samples.")
        BP_REF_ARG(@name "angleunit" @default 0 @type "int" @description "unit for angles." @options 
            BP_REF_ANGLEUNIT_OPTIONS
        )
    )
    @output BP_REF_OUTPUT(@description "higher-order ambisonics decoding operation" @type "llll")
);

## ------------------------------------------------------------

ezsampler = (
    $pitch = 6000, $duration = 2000, $velocity = 64, $keymap = null, $resample = 1, $useseed = 0, $usecache = 1 -> (
        $keymap = $keymap ||| BP_DEFAULT_EZSAMPLER_KEYMAP;
        $pitch = $pitch:1 ||| 6000;
        ## get list of pitch values
        $pitches = trans($keymap)::1;
        ## find closest pitch sample
        $minaddr = minmax(abs($pitches - $pitch))::2;
        $closest = $keymap::$minaddr;
        ## calculate pitch difference
        $pitchdev = $pitch - $closest:1;
        $ratio = if $resample != 0 then c2r($pitchdev) else ($pitch = $closest:1; 1);
        ## check if it's multi-sample match
        $options = right($closest, 1);
        ## init choose func
        $choose = if $useseed == 0 then choose else xchoose;
        if depth($options) > 1 then (
            ## find best velocity match
            $velocities = trans($options)::1;
            $minaddr = minmax(abs($velocities - ($velocity ||| 64)))::2;
            $closest = $options::$minaddr;
            $file = $choose(right($closest, 1))
        ) else (
            $file = $choose($options)
        );
        $b = importaudio($file @usecache $usecache);
        $b = $b.setkey('duration', ($duration ||| $b.getkey("duration")) * $ratio);
        if $ratio != 1 then (
            $b = $b.process(resample(1/$ratio))
        );
        $b.setkey('pitch', float($pitch)).setkey('file', $file @mode 1) 
    ) 
);

BP_REF_NEW(
    @name "ezsampler",
    @description "Generates a buffer given pitch, duration, and velocity values, and an optional list representing a sampler key map. The key map must be a list of key-value pairs, where the each key is a numeric pitch value, in midicents, that maps to one or more audio file paths corresponding to that pitch, or to a list of key-value pairs with velocity values, between 0 and 127, as keys, and audio file paths as values. When multiple file paths are provided for a given pitch or velocity key, one of them is chosen at random. If no keymap is provided, the function defaults to a basic, built-in key map. The generated buffer will be one that best approximates the specified pitch, duration, and velocity values.",
    @category BP_REF_LABEL_GEN,
    @arguments (
        BP_REF_ARG(@name "pitch", @default 6000 @type "int/float", @description "target pitch in midicents.")
        BP_REF_ARG(@name "duration" @default 2000 @type "int/float", @description "target duration in milliseconds. Set to null to get the sample's max. duration.")
        BP_REF_ARG(@name "velocity" @default 64 @type "int/float", @description "target velocity, from 0 to 127. Used only when keymap has velocity-based options.")
        BP_REF_ARG(@name "keymap" @default "null" @type "llll", @description "key mapping, with pitch in midicents as key and file path as value")
        BP_REF_ARG(@name "resample" @default 1 @type "int" @description "resample buffer to match target pitch." @options
            BP_REF_OPT(@value 0 @description "off")
            BP_REF_OPT(@value 1 @description "on")
        )
        BP_REF_ARG(@name "useseed" @default 0 @type "int" @description "use seed-based random selection function." @options
            BP_REF_OPT(@value 0 @description "off")
            BP_REF_OPT(@value 1 @description "on")
        )
        BP_REF_USE_CACHE_ARG
    )
    @output BP_REF_OUTPUT(@description "buffer" @type "llll")
);

## ------------------------------------------------------------

argsort = (
    $x, $function = null -> (
        BP_FN_CHECK_ARGS('argsort', 'x', $x);
        $lambda = $function ||| ($a, $b -> $a < $b);
        $addrs = 1...length($x);
        sort($addrs @function ($a, $b -^ $x, $lambda -> $lambda($x:$a, $x:$b))) 
    ) 
);

BP_REF_NEW(
    @name "argsort",
    @description "Returns the indices that would sort an input llll in ascending order. Instead of returning a sorted version of the llll, it provides an index permutation that, when applied to the original llll, results in a sorted sequence.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "x" @type "llll" @description "llll to sort.")
        BP_REF_ARG(@name "function" @default "null" @type "function", @description "optional lambda sorting function.")
    )
    @output BP_REF_OUTPUT(@description "sorted indices" @type "llll")
);

## ------------------------------------------------------------

symlen = (
    $symbol -> (
        ($symbol &&& length(BP_MAXOBJ_ATOI($symbol @out 'm'))) ||| 0
    ) 
);

BP_REF_NEW(
    @name "symlen",
    @description "Returns the length of symbol.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "symbol", @type "symbol", @description "symbol to get length of.")
    ),
    @output BP_REF_OUTPUT(@description "symbol length" @type "int")
);

## ------------------------------------------------------------

getchar = (
    $symbol, $i = 1 -> (
        $i &&& BP_MAXOBJ_ITOA(
            BP_MAXOBJ_ATOI($symbol @out 'm'):[int($i)] @out 'm' 
        ) 
    ) 
);

BP_REF_NEW(
    @name "getchar",
    @description "Given a symbol and one or more indices, it returns the characters corresponding to each index.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "symbol", @type "symbol", @description "symbol to get characters from.")
        BP_REF_ARG(@name "i", @type "int/list", @description "character indices.")
    ),
    @output BP_REF_OUTPUT(@description "symbol" @type "symbol")
);

## ------------------------------------------------------------

BP_FN_GCD = $x, $y -> if $y == 0 then abs($x) else BP_FN_GCD($y, $x % $y);

gcd = $llll -> for $x in flat($llll) do $gcd = BP_FN_GCD($gcd ||| $x, $x);

BP_REF_NEW(
    @name "gcd",
    @description "Computes the greatest common denominator of a list of integers.",
    @category BP_REF_LABEL_UTILS,
    @arguments (
        BP_REF_ARG(@name "llll" @type "llll" @description "list of integers.")
    ),
    @output BP_REF_OUTPUT(@description "greatest common denominator" @type "int")
);

## ------------------------------------------------------------

BP_FN_LCM = $x, $y -> if $x == 0 || $y == 0 then 0 else abs($x * $y) / BP_FN_GCD($x, $y);

lcm = $llll -> (
    for $x in flat($llll) do $lcm = max($lcm ||| $x, BP_FN_LCM($lcm ||| $x, $x))
);

BP_REF_NEW(
    @name "lcm"
    @description "Computes the least common multiple of a list of integers."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "llll" @type "llll" @description "list of integers.")
    ),
    @output BP_REF_OUTPUT(@description "Least common multiple" @type "int")
);

## ------------------------------------------------------------

integrate = (
    $llll, $numsamples = 100, $order = 1, $origin = 0. -> (
        BP_FN_CHECK_ARGS('intergrate', 'llll', $llll);
        for $arg in ['numsamples' $numsamples] ['order' $order] ['origin' $origin] with @unwrap 1 do (BP_MAXOBJ_BACHINTEGRATE($arg @out 'm'));
        BP_MAXOBJ_BACHINTEGRATE($llll) 
    ) 
);

BP_REF_NEW(
    @name "integrate"
    @description "Computes the integral of a breakpoint function. Note that the slope of the integrated break-point function is always 0, since the output function is always piecewise linear."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "llll" @type "llll" @description "list of integers.")
        BP_REF_ARG(@name "numsamples" @default 100 @type "int" @description "number of samples.")
        BP_REF_ARG(@name "order" @default 1 @type "int/list" @description "order of the integration, i.e. the number of times the integration should be subsequently performed.")
        BP_REF_ARG(@name "origin" @default 0 @type "int/float" @description "initial value of the integral function. If the order of the integration is greater than one, one origin for each different integration step can be defined.")
    ),
    @output BP_REF_OUTPUT(@description "Integrated breakpoint function." @type "llll")
);

## ------------------------------------------------------------

mc2chroma = (
    $mc, $mod = 12 -> (
        BP_FN_CHECK_ARGS('mc2chroma', 'mc', $mc);
        $cents = 100 / ($mod / 12);
        $mc = int(($mc / $cents * 1.) % $mod) + 1;
        $chroma = 0 :* $mod;
        for $x in $mc with @maxdepth -1 @spikemode 1 do $chroma:$x += 1;
        $chroma
    ) 
);

BP_REF_NEW(
    @name "mc2chroma"
    @description "Midicents to chroma vector conversion."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "mc" @type "llll" @description "list of midicents.")
        BP_REF_ARG(@name "mod" @default 12 @type "int" @description "length of chroma vector, based on equal divisions of the octave.")
    ),
    @output BP_REF_OUTPUT(@description "chroma vector." @type "llll")
);

## ------------------------------------------------------------

autoscale = (
    $x, $mode = 0 -> (
        BP_FN_CHECK_ARGS('autoscale', 'x', $x);
        $minmax = minmax($x @depth -1 -1);
        $min = $minmax:1;
        $max = $minmax:3;
        $y = scale($x, $min, $max, 0, 1);
        if $mode == 0 then $y else $y / reduce(flat($y), #+) 
    ) 
);

BP_REF_NEW(
    @name "autoscale"
    @description "Applies auto-scaling normalization to a llll."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "x" @type "llll" @description "numeric list.")
        BP_REF_ARG(@name "mode" @default 0 @type "int" @description "auto-scaling normalization mode." @options 
            BP_REF_OPT(@value 0 @description "minmax normalization")
            BP_REF_OPT(@value 1 @description "1-sum normalization")
        )
    ),
    @output BP_REF_OUTPUT(@description "auto-scaled llll" @type "llll")
);

## ------------------------------------------------------------

derive = (
    $llll, $numsamples = 100, $order = 1, $discrete = 0, $pad = 2 -> (
        BP_FN_CHECK_ARGS('derive', 'llll', $llll);
        for $arg in ['pad' $pad] ['numsamples' $numsamples] ['order' $order] ['discrete' $discrete] with @unwrap 1 do (BP_MAXOBJ_BACHDERIVE($arg @out 'm'));
        BP_MAXOBJ_BACHDERIVE(
            $llll
            @pad $pad
            @numsamples $numsamples
            @order $order
            @discrete $discrete
        ) 
    ) 
);

BP_REF_NEW(
    @name "derive"
    @description "Computes the derivative of a breakpoint function. Note that the slope of the derived break-point function is always 0, since the output function is always piecewise linear."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "llll" @type "llll" @description "list of integers.")
        BP_REF_ARG(@name "numsamples" @default 100 @type "int" @description "number of samples.")
        BP_REF_ARG(@name "order" @default 1 @type "int/list" @description "order of the integration, i.e. the number of times the integration should be subsequently performed.")
        BP_REF_ARG(@name "origin" @default 0 @type "int/float" @description "initial value of the integral function. If the order of the integration is greater than one, one origin for each different integration step can be defined.")
        BP_REF_ARG(@name "pad" @default 2 @type "int" @description "padding mode." @options 
            BP_REF_OPT(@value 0 @description "no pad")
            BP_REF_OPT(@value 1 @description "pad at left")
            BP_REF_OPT(@value 2 @description "pad at right")
            BP_REF_OPT(@value 3 @description "pad at left and right")
        )
    ),
    @output BP_REF_OUTPUT(@description "Integrated breakpoint function." @type "llll")
);

## ------------------------------------------------------------

splitbuf = (
    $buffer, $split = 100, $mode = 0, $overlap = 1, $partials = 1 -> (
        $self = 'splitbuf';
        BP_FN_CHECK_ARGS($self, 'buffer', $buffer, 'split', $split, 'mode', $mode);
        BP_FN_VALIDATE_BUFFER($self, $buffer);
        $overlap = max($overlap, 1);
        $duration = $buffer.getkey('duration');
        $segs = null;
        if $mode == 0 || $mode == 1 then (
            if $mode == 0 then (
                $segdur = $split;
                $hopsize = $segdur / $overlap;
                $numsegs = floor($duration / $hopsize)
            ) else (
                $numsegs = $split;
                $hopsize = $duration / $numsegs;
                $segdur = $hopsize * $overlap
            );
            $buffer = $buffer.setkey('duration', $segdur);
            for $i in 0...($numsegs - 1) do (
                $offset = $i * $hopsize;
                $segs _= $buffer.setkey('offset', $offset) 
            );
            $offset += $hopsize;
            if $partials == 1 && $offset < $duration then (
                $taildur = $duration - $offset;
                $segs _= $buffer.setkey('offset', $offset).setkey('duration', $taildur) 
            ) 
        ) else if $mode == 2 then (
            $offsets = sort($split);
            $segdurs = x2dx($offsets $duration);
            for $offset in $offsets, $sdur in $segdurs do (
                $segs _= $buffer.setkey('offset', $offset).setkey('duration', $sdur) 
            ) 
        ) else BP_FN_ERROR($self, 'invalid @mode:' $mode);
        $segs
    ) 
);

BP_REF_NEW(
    @name "splitbuf"
    @description "Splits a buffer into multiple segments. Based on the split mode, it segments the buffer based on segment duration, number of segment, or split points."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "buffer" @type "llll" @description "buffer to segment.")
        BP_REF_ARG(@name "split" @default 100 @type "int/float/list" @description "split value, based on split mode.")
        BP_REF_ARG(@name "mode" @default 0 @type "int" @description "segmentation mode" @options 
            BP_REF_OPT(@value 0 @description "segment duration.")
            BP_REF_OPT(@value 1 @description "number of segments.")
            BP_REF_OPT(@value 2 @description "split points.")
        )
        BP_REF_ARG(@name "overlap" @default 1 @type "int/float" @description "overlap factor. Ignored if @mode is 2.")
        BP_REF_ARG(@name "partials" @default 1 @type "int" @description "when mode < 2, always include trailing buffer." @options 
            BP_REF_SWITCH_OPTIONS
        )
    ),
    @output BP_REF_OUTPUT(@description "list of segmented buffers." @type "llll")
);

## ------------------------------------------------------------

createtree = (
    $data, $mode = 0 -> (
        $ok = BP_FN_CHECK_ARGS('createtree', 'data', $data);
        if depth($data) != 2 then (
            BP_FN_ERROR('createtree', '@data must be a matrix or list of lists with depth of 2')
        ) else if $ok == 1 then (
            $numpoints = length($data);
            $cols = trans($data);
            $dims = length($cols);
            $stop = 0;
            $stats = trans(
                for $col in $cols as $stop == 0 with @unwrap 1 collect (
                    $colsize = length($col);
                    if $colsize != $numpoints then (
                        $stop = 1;
                        null
                    ) else (
                        if $mode == 0 then (
                            $minmax = minmax($col):[1 3];
                            $min = $minmax:1;
                            $scale = $minmax:2 - $min;
                            [$min $scale] 
                        ) else (
                            $mean = reduce($col, #+) / $colsize;
                            $stdev = reduce(($col - $mean) ** 2, #+) / $colsize;
                            [$mean $stdev] 
                        ) 
                    ) 
                ) 
            );
            if $stop == 1 then BP_FN_ERROR('createtree', 'all elements in @data must have the same length') else (
                $bias = $stats:1;
                $spread = $stats:2;
                $data = float(($data - $bias) / $spread);
                $tree = BP_FN_SANDBOX_NEWOBJ('ml.kdtree');
                BP_FN_SANDBOX_CONNECT(
                    $tree, 'bpsandboxout' @outlet 1
                );
                BP_FN_SANDBOX_GEN();
                for $point $index in $data with @unwrap 1 do BP_FN_SANDBOX_MSG(
                    @to $tree @message 'store' $index $point
                );
                BP_FN_SANDBOX_MSG(
                    @to $tree @message 'sort' 
                );
                [
                    ['ref' $tree] ['dims' $dims] ['bias' $bias::1] ['spread' $spread::1] 
                ] 
            ) 
        ) 
    ) 
);

BP_REF_NEW(
    @name "createtree"
    @description "Creates a k-dimensional tree for optimized nearest-neighbor search of multidimensional data. See #querytree."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "data" @type "llll" @description "data as a list of numeric lists.")
        BP_REF_ARG(@name "mode" @default 0 @type "int" @description "data scaling mode" @options 
            BP_REF_OPT(@value 0 @description "minmax normalization.")
            BP_REF_OPT(@value 1 @description "standardization.")
        )
    )
    @output BP_REF_OUTPUT(@description "k-dimensional tree reference" @type "llll")
);

## ------------------------------------------------------------

querytree = (
    $tree, $point -> (
        $self = 'querytree';
        BP_FN_CHECK_ARGS($self, 'tree', $tree, 'point', $point);
        BP_SANDBOX_OUT = null;
        $treedims = getkey($tree, 'dims');
        if $treedims == null then BP_FN_ERROR($self, 'invalid tree:' $tree) else (
            $point = flat($point);
            $pointdims = length($point);
            if $treedims != $pointdims then BP_FN_ERROR($self, '@point must be of length' $treedims) else (
                $ref = getkey($tree, 'ref');
                $bias = getkey($tree, 'bias');
                $spread = getkey($tree, 'spread');
                $point = float(($point - $bias) / $spread);
                BP_FN_SANDBOX_MSG(@to $ref @message $point) 
            ) 
        );
        BP_SANDBOX_OUT
    ) 
);

BP_REF_NEW(
    @name "querytree"
    @description "Given a k-dimensional tree and a target point with the same dimensionality, returns the index position of the nearest neighbor in that tree. See #createtree."
    @category BP_REF_LABEL_UTILS
    @arguments (
        BP_REF_ARG(@name "tree" @type "llll" @description "k-dimensional tree.")
        BP_REF_ARG(@name "point" @type "llll" @description "target point to search nearest neighbor of.")
    )
    @output BP_REF_OUTPUT(@description "index of nearest neighbor" @type "int")
);

## ------------------------------------------------------------

null