"use strict";(self.webpackChunkbellplay_docs=self.webpackChunkbellplay_docs||[]).push([[1125],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var i=t(96540);const r={},a=i.createContext(r);function s(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:n},e.children)}},83189:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"learning/tutorials/bufferkeys","title":"6. Buffer Keys","description":"As mentioned in earlier tutorials, buffers in bellplay~ are simply nested lists of key-value pairs.","source":"@site/docs/learning/tutorials/bufferkeys.md","sourceDirName":"learning/tutorials","slug":"/learning/tutorials/bufferkeys","permalink":"/docs/learning/tutorials/bufferkeys","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"getkey","permalink":"/docs/tags/getkey"},{"inline":true,"label":"importaudio","permalink":"/docs/tags/importaudio"},{"inline":true,"label":"mapkey","permalink":"/docs/tags/mapkey"},{"inline":true,"label":"print","permalink":"/docs/tags/print"},{"inline":true,"label":"render","permalink":"/docs/tags/render"},{"inline":true,"label":"setkey","permalink":"/docs/tags/setkey"},{"inline":true,"label":"transcribe","permalink":"/docs/tags/transcribe"}],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"6. Buffer Keys","tags":["getkey","importaudio","mapkey","print","render","setkey","transcribe"]},"sidebar":"tutorialSidebar","previous":{"title":"5. Rendering","permalink":"/docs/learning/tutorials/rendering"},"next":{"title":"7. Markers","permalink":"/docs/learning/tutorials/markers"}}');var r=t(74848),a=t(28453);const s={sidebar_position:5,title:"6. Buffer Keys",tags:["getkey","importaudio","mapkey","print","render","setkey","transcribe"]},o="Buffer Keys",l={},c=[];function d(e){const n={a:"a",code:"code",h1:"h1",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"buffer-keys",children:"Buffer Keys"})}),"\n",(0,r.jsxs)(n.p,{children:["As mentioned in earlier tutorials, buffers in ",(0,r.jsx)(n.strong,{children:"bellplay~"})," are simply nested lists of ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Name%E2%80%93value_pair",children:"key-value pairs"}),".\nHere's what a typically buffer looks like:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bell",metastring:'title="my buffer"',children:"[\n    [ 'source' 'u357000940' ]\n    [ 'sr' 48000 ]\n    [ 'numchannels' 1 ]\n    [ 'max' 1.0 ]\n    [ 'min' -1.0 ]\n    [ 'maxabs' 1.0 ]\n    [ 'rms' 0.7071067709 ]\n    [ 'duration' 50.0 ]\n    [ 'offset' 0 ]\n    [ 'pitch' 6900.0 ]\n    [ 'source_end' 1000.0 ]\n]\n"})}),"\n",(0,r.jsx)(n.p,{children:"These keys contain relevant information about the underlying audio data.\nFor instance, the buffer's channel count, sampling rate, duration, source (i.e., where to find the audio data), and more.\nThis may also include more interesting information, such as estimated pitch, pitch salience, zero crossing rate, etc., which will be discussed in later tutorials."}),"\n",(0,r.jsx)(n.p,{children:"Relevant to this tutorial is our ability to access and/or modify this buffer properties or keys."}),"\n",(0,r.jsxs)(n.p,{children:["In ",(0,r.jsx)(n.strong,{children:"bellplay~"})," this is done through primarily through 3 functions:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"getkey"}),": returns the value of a given key (access)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"setkey"}),": overrides the value of a given key (modification)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"mapkey"}),": overrides the value of a given key, based on the current value, via ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Anonymous_function",children:"lambda functions"})," (modification)."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Crucially, modifications to buffer keys via ",(0,r.jsx)(n.code,{children:"setkey"})," and ",(0,r.jsx)(n.code,{children:"mapkey"})," do not actually modify the underlaying audio data - at least not directly.\nInstead, the information contained in each of these key-value pairs is used by functions like ",(0,r.jsx)(n.code,{children:"transcribe"}),", ",(0,r.jsx)(n.code,{children:"process"}),", or ",(0,r.jsx)(n.code,{children:"analyze"})," use to determine how to treat the buffer."]}),"\n",(0,r.jsxs)(n.p,{children:["For instance, in the case of the ",(0,r.jsx)(n.code,{children:"transcribe"})," function, the ",(0,r.jsx)(n.code,{children:"'pitch'"})," key simply defines how the buffer is notated in staff notation, but has no impact in the audio data."]}),"\n",(0,r.jsxs)(n.p,{children:["Other keys, however, like ",(0,r.jsx)(n.code,{children:"duration"})," or ",(0,r.jsx)(n.code,{children:"offset"}),", tell functions like ",(0,r.jsx)(n.code,{children:"transcribe"}),", ",(0,r.jsx)(n.code,{children:"process"})," or ",(0,r.jsx)(n.code,{children:"analyze"})," how much of the audio data should be used.\nIn other words, they are ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Lazy_evaluation",children:'"lazy"'})," modifications, because it delays real modifications until it's actually needed.\nIn ",(0,r.jsx)(n.code,{children:"transcribe"}),", this is specifically the case with the ",(0,r.jsx)(n.code,{children:"'duration'"})," and ",(0,r.jsx)(n.code,{children:"'offset'"})," keys.\nAs such, these setter-based modifications are not destructive or irreversible, and only take effect once the buffer goes through transcription, processing, or analysis."]}),"\n",(0,r.jsx)(n.p,{children:"The code below puts all this into practice"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bell",metastring:'title="buffer_keys.bell" showLineNumbers',children:"## path to built-in audio file\n$path = 'badinerie.wav';\n## uncomment the line below\ud83d\udc47 to use an audio file path of your choosing\n## $path = \"/path/to/your/file.wav\"\n## import audio file as buffer\n$buff = importaudio($path);\n## we can print buffer variables and see what they look like\nprint('This is what a typical buffer looks like \ud83d\udc47');\nprint($buff);\n## get and print buffer duration\n$buffdur = $buff.getkey('duration');\nprint('buffer duration:' $buffdur);\n## get and print buffer channel count\n$buffchans = $buff.getkey('numchannels');\nprint('buffer channel count:' $buffchans);\n## change buffer duration and transcribe\n$buff = $buff.setkey('duration', 1000);\n$buff.transcribe();\n## define a lambda function that takes an input value, and adds 1000 to it.\n$myfunc = ($x -> $x + 1000);\n## change buffer offset (i.e., where to start reading the buffer from) via a lambda function and transcribe\n$buff = $buff.mapkey('offset', $myfunc);\n$buff.transcribe(@onset 1500);\n## change buffer pitch in midicents and transcribe\n## ---- NOTE -----\n## this only changes the notated pitch. \n## To change the actual pitch, we would need to use `@detune` argument in `transcribe`, or apply processing via the `process` function. \n## Please refer to the `transcribe` documentation to learn more.\n## ---------------\n$buff = $buff.setkey('pitch', 7200);\n$buff.transcribe(@onset 3000);\n## render modified buffer\nrender()\n"})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);