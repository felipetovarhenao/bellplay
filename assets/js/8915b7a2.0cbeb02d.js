"use strict";(self.webpackChunkbellplay_docs=self.webpackChunkbellplay_docs||[]).push([[7440],{5441:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>i,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"reference/buffer-analysis/temporalflatness","title":"temporalflatness","description":"temporalflatness","source":"@site/docs/reference/buffer-analysis/temporalflatness.md","sourceDirName":"reference/buffer-analysis","slug":"/reference/buffer-analysis/temporalflatness","permalink":"/docs/reference/buffer-analysis/temporalflatness","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"hide_title":true},"sidebar":"tutorialSidebar","previous":{"title":"temporalcentroid","permalink":"/docs/reference/buffer-analysis/temporalcentroid"},"next":{"title":"temporalkurtosis","permalink":"/docs/reference/buffer-analysis/temporalkurtosis"}}');var r=s(4848),l=s(8453);const a={hide_title:!0},o=void 0,i={},c=[{value:"<code>temporalflatness</code>",id:"temporalflatness",level:2},{value:"Output",id:"output",level:3},{value:"Usage",id:"usage",level:3}];function f(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"temporalflatness",children:(0,r.jsx)(n.code,{children:"temporalflatness"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bell",children:"temporalflatness() -> llll\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Audio descriptor to calculate the temporal flatness of a buffer, defined as the ratio between the buffer envelope's geometric mean and arithmetic mean. Flatness is undefined for empty input and negative values, therefore an exception is thrown in any both cases. See ",(0,r.jsx)(n.code,{children:"analyze"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"The resulting buffer will be updated with the following keys:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"'temporalflatness'"})}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"output",children:"Output"}),"\n",(0,r.jsxs)(n.p,{children:["temporalflatness descriptor [",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.em,{children:"llll"})}),"]"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"usage",children:"Usage"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"temporalflatness"})," is meant to be used with the ",(0,r.jsx)(n.code,{children:"analyze"})," function:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bell",metastring:"showLineNumbers",children:"$buffer = importaudio('singing.wav'); ## input buffer\n$descr = temporalflatness(); ## generate temporalflatness audio descriptor\n$buffer.inspect('before analysis');\n$buffer = $buffer.analyze($descr); ## apply analysis\n$buffer.inspect('after analysis')\n"})})]})}function d(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(f,{...e})}):f(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var t=s(6540);const r={},l=t.createContext(r);function a(e){const n=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);