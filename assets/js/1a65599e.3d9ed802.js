"use strict";(self.webpackChunkbellplay_docs=self.webpackChunkbellplay_docs||[]).push([[8722],{78046:e=>{e.exports=JSON.parse('{"tag":{"label":"pitchmelodia","permalink":"/docs/tags/pitchmelodia","allTagsPath":"/docs/tags","count":7,"items":[{"id":"learning/examples/keymaps","title":"11. Generating Keymaps","description":"This example automatically generates a custom keymap given a list of audio file paths:","permalink":"/docs/learning/examples/keymaps"},{"id":"learning/tutorials/analysismodes","title":"16. Audio Descriptor Modes","description":"When analyzing buffers, we can specify the output format for many of the available audio descriptors.","permalink":"/docs/learning/tutorials/analysismodes"},{"id":"learning/tutorials/features","title":"17. More Audio Features","description":"This tutorial provides an additional example for using buffer analysis features for audio processing.","permalink":"/docs/learning/tutorials/features"},{"id":"learning/tutorials/buildcorpus","title":"18. Audio corpora with SQL tables","description":"This tutorial demonstrates how to create an in-memory, queryable corpus of audio buffers by leveraging the createdbtable and querydb functions.","permalink":"/docs/learning/tutorials/buildcorpus"},{"id":"learning/tutorials/caching","title":"19. Caching Data","description":"In bellplay~, computation-heavy operations such as building large corpora, analyzing lots of audio data, and more, can be take a very long time, thus making it more tedious to experiment with our scripts every time we run them.","permalink":"/docs/learning/tutorials/caching"},{"id":"learning/tutorials/kdtree","title":"23. Feature-driven Sampling","description":"This tutorial shows how to build k-dimensional trees to efficiently perform feature-based search on buffers.","permalink":"/docs/learning/tutorials/kdtree"},{"id":"reference/buffer-analysis/analyze","title":"analyze","description":"analyze","permalink":"/docs/reference/buffer-analysis/analyze"}],"unlisted":false}}')}}]);