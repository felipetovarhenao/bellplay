"use strict";(self.webpackChunkbellplay_docs=self.webpackChunkbellplay_docs||[]).push([[3910],{28453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>o});var t=r(96540);const a={},i=t.createContext(a);function s(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(i.Provider,{value:n},e.children)}},81858:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"learning/tutorials/automation","title":"9. Automation","description":"In many cases, we will want to have some kind of DAW-style automation of certain parameters when generating or processing audio in our scripts.","source":"@site/docs/learning/tutorials/automation.md","sourceDirName":"learning/tutorials","slug":"/learning/tutorials/automation","permalink":"/docs/learning/tutorials/automation","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"addmarker","permalink":"/docs/tags/addmarker"},{"inline":true,"label":"cycle","permalink":"/docs/tags/cycle"},{"inline":true,"label":"rect","permalink":"/docs/tags/rect"},{"inline":true,"label":"render","permalink":"/docs/tags/render"},{"inline":true,"label":"saw","permalink":"/docs/tags/saw"},{"inline":true,"label":"transcribe","permalink":"/docs/tags/transcribe"},{"inline":true,"label":"tri","permalink":"/docs/tags/tri"}],"version":"current","sidebarPosition":8,"frontMatter":{"sidebar_position":8,"title":"9. Automation","tags":["addmarker","cycle","rect","render","saw","transcribe","tri"]},"sidebar":"tutorialSidebar","previous":{"title":"8. Randomness","permalink":"/docs/learning/tutorials/randomness"},"next":{"title":"10. Buffer Processing","permalink":"/docs/learning/tutorials/bufferprocessing"}}');var a=r(74848),i=r(28453);const s={sidebar_position:8,title:"9. Automation",tags:["addmarker","cycle","rect","render","saw","transcribe","tri"]},o="Automation",l={},c=[];function u(e){const n={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"automation",children:"Automation"})}),"\n",(0,a.jsxs)(n.p,{children:["In many cases, we will want to have some kind of DAW-style automation of certain parameters when generating or processing audio in our scripts.\nOne way of doing this is through breakpoint functions \u2014 numeric lists that describe a certain shape or trajectory.\nThis tutorial shows the different syntaxes available in ",(0,a.jsx)(n.strong,{children:"bellplay~"})," for specifying breakpoint functions."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bell",metastring:'title="automation.bell" showLineNumbers',children:"## duration value for all buffers\n$dur = 2000;\n## frequency envelope, in equi-distant linear syntax\n$fq = 220 440 330 220;\n## generate and transcribe sinusoidal oscillator buffer\ncycle(\n    @frequency $fq @duration $dur\n).transcribe();\n## add marker to match start of sinusoidal oscillator\naddmarker(\n    @onset 0 @names 'sinusoidal' \n);\n## ----------------------------------------------\n## frequency envelope, in wrapped xy-pair syntax\n$fq = [0 220] [1 440] [3 220];\n## generate and transcribe triangular wave oscillator buffer\ntri(\n    @frequency $fq @duration $dur\n).transcribe(@onset $dur);\n## another marker matching start of triangular wave oscillator\naddmarker(\n    @onset $dur @names 'triangular' \n);\n## ----------------------------------------------\n## wrapped xy-slope tuples (linear)\n$fq = [0 220 0] [1 440 0] [3 220 0];\n## generate and transcribe square wave oscillator buffer\nrect(\n    @frequency $fq @duration $dur\n).transcribe(@onset $dur * 2);\n## third marker matching start of square wave oscillator\naddmarker($dur * 2, 'square');\n## ----------------------------------------------\n## wrapped xy-slope tuples (with curves)\n$fq = [0 220 0] [1 440 0.5] [3 220 -0.5];\n## generate and transcribe sawtooth wave oscillator buffer\nsaw(\n    @frequency $fq @duration $dur\n).transcribe(@onset $dur * 3 @gain .125);\n## last marker matching start of sawtooth wave oscillator\naddmarker($dur * 3, 'sawtooth \u2014 has curved envelope');\n## render everything\nrender(@play 1)\n"})})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}}}]);