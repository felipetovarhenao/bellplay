"use strict";(self.webpackChunkbellplay_docs=self.webpackChunkbellplay_docs||[]).push([[1028],{8453:(e,r,n)=>{n.d(r,{R:()=>a,x:()=>s});var t=n(6540);const o={},i=t.createContext(o);function a(e){const r=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function s(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(i.Provider,{value:r},e.children)}},9216:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"learning/tutorials/corpus","title":"17. Audio Corpora","description":"One of the core features of bellplay~ is the ability to handle audio corpora \u2014 i.e., large collections of audio data.","source":"@site/docs/learning/tutorials/corpus.md","sourceDirName":"learning/tutorials","slug":"/learning/tutorials/corpus","permalink":"/docs/learning/tutorials/corpus","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":16,"frontMatter":{"sidebar_position":16,"title":"17. Audio Corpora"},"sidebar":"tutorialSidebar","previous":{"title":"16. More Audio Features","permalink":"/docs/learning/tutorials/features"},"next":{"title":"18. Creating Audio Corpora","permalink":"/docs/learning/tutorials/buildcorpus"}}');var o=n(4848),i=n(8453);const a={sidebar_position:16,title:"17. Audio Corpora"},s="Audio Corpora",c={},l=[];function d(e){const r={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.header,{children:(0,o.jsx)(r.h1,{id:"audio-corpora",children:"Audio Corpora"})}),"\n",(0,o.jsxs)(r.p,{children:["One of the core features of ",(0,o.jsx)(r.strong,{children:"bellplay~"})," is the ability to handle audio corpora \u2014 i.e., large collections of audio data.\nThe first step is to create an audio corpus, which will be covered in a later tutorial.\nThese audio corpora, which are saved as .llll files, can then be loaded into our scripts.\nIn turn, this makes it possible to make queries on a corpus, in SQLite3 syntax, to retrieve buffers according to certain criteria."]}),"\n",(0,o.jsx)(r.p,{children:"This tutorial shows how to use a pre-existing corpus to retrieve buffers with well-defined pitch content, order them in pitch-wise descending order, and retune each buffer to conform to a Cm7 chord."}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-bell",metastring:'title="audio_corpora.bell" showLineNumbers',children:"## path to pre-existing corpus file\n$corpuspath = 'corpus_demo.llll';\n## load the corpus\nsetcorpus($corpuspath);\n## perform a SQLite3 query on the corpus, choosing buffers with pitch salience above 0.15 \n## and ordering the results by pitch, in descending order.\n$buffers = query('SELECT * FROM buffers WHERE pitchmelodia_confidence > 0.15 ORDER BY pitchmelodia DESC');\n## iterate through each buffer and transcribe them\nfor $buffer $i in $buffers do (\n    ## evenly-spaced onset for current buffer\n    $onset = ($i - 1) * 50;\n    $pitch = $buffer.getkey('pitchmelodia');\n    ## get pitch deviation in cents from a Cm7 chord;\n    $detune = $pitch.pitchdiff(0 3 7 10);\n    ## transcribe buffer, and apply deviation and hanning-shaped gain envelope\n    $buffer.transcribe(\n        @onset $onset\n        @detune $detune\n        @gain hanning() \n        @pan rand() \n        @pitchkey 'pitchmelodia' \n    ) \n);\n## trigger rendering\nrender(@play 1)\n"})})]})}function u(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);