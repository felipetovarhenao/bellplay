"use strict";(self.webpackChunkbellplay_docs=self.webpackChunkbellplay_docs||[]).push([[5097],{3171:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"learning/tutorials/transcription","title":"4. Transcription","description":"When transcribing buffers, we get to specify essential information about how each buffer fits within the final output.","source":"@site/docs/learning/tutorials/transcription.md","sourceDirName":"learning/tutorials","slug":"/learning/tutorials/transcription","permalink":"/docs/learning/tutorials/transcription","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"4. Transcription"},"sidebar":"tutorialSidebar","previous":{"title":"3. Importing Audio","permalink":"/docs/learning/tutorials/importingaudio"},"next":{"title":"5. Rendering","permalink":"/docs/learning/tutorials/rendering"}}');var r=t(4848),o=t(8453);const s={sidebar_position:3,title:"4. Transcription"},a="Transcription",l={},c=[];function u(n){const e={admonition:"admonition",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,o.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"transcription",children:"Transcription"})}),"\n",(0,r.jsx)(e.p,{children:"When transcribing buffers, we get to specify essential information about how each buffer fits within the final output.\nFor instance, specifying the time onset position (i.e., start time), gain, panning, and even resampling-based detuning amount in cents."}),"\n",(0,r.jsx)(e.p,{children:"The code below shows how a single buffer is transcribed multiple times, each time with different settings, to generate a simple melodic gesture."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bell",metastring:'title="transcription.bell" showLineNumbers',children:"## generate a triangle wave oscillator as a buffer\n$buff = tri();\n## number of notes (buffers)\n$numnotes = 25;\n$N = $numnotes - 1;\n## total output duration\n$totaldur = 1500;\n## iterate for each note\nfor $i in 0...$N do (\n    ## compute normalize value of temporal position within output (i.e., 0 = start, 1 = end) \n    $progress = $i / $N;\n    ## make onsets equally spaced within the total duration\n    $onset = $progress * $totaldur;\n    ## panning goes from 0 (left) to 1 (right) with each iteration\n    $pan = $progress;\n    ## make gain exponentially softer\n    $gain = (1 - $progress) ** 2;\n    ## detuning amount from 0 to 1200 (octave) midicents with each iteration\n    $detune = 1200 * $progress;\n    ## transcribe the same buffer, with different values for onset, gain, detuning amount, and panning.\n    $buff.transcribe(\n        @onset $onset\n        @gain $gain\n        @detune $detune\n        @pan $pan\n    ) \n);\n## render transcribed buffers\nrender()\n"})}),"\n",(0,r.jsx)(e.admonition,{type:"danger",children:(0,r.jsxs)(e.p,{children:["Calling ",(0,r.jsx)(e.code,{children:"render"})," before transcribing any buffers will raise an error."]})})]})}function d(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(u,{...n})}):u(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>a});var i=t(6540);const r={},o=i.createContext(r);function s(n){const e=i.useContext(o);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),i.createElement(o.Provider,{value:e},n.children)}}}]);