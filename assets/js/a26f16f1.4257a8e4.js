"use strict";(self.webpackChunkbellplay_docs=self.webpackChunkbellplay_docs||[]).push([[3708],{28453:(e,r,n)=>{n.d(r,{R:()=>o,x:()=>a});var t=n(96540);const s={},i=t.createContext(s);function o(e){const r=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(i.Provider,{value:r},e.children)}},71027:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>a,default:()=>f,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"learning/tutorials/bufferprocessing","title":"10. Buffer Processing","description":"One of the core features of bellplay~ is the ability to dynamically and flexibly apply chains of DSP algorithms to our buffers.","source":"@site/docs/learning/tutorials/bufferprocessing.md","sourceDirName":"learning/tutorials","slug":"/learning/tutorials/bufferprocessing","permalink":"/docs/learning/tutorials/bufferprocessing","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"freeverb","permalink":"/docs/tags/freeverb"},{"inline":true,"label":"importaudio","permalink":"/docs/tags/importaudio"},{"inline":true,"label":"process","permalink":"/docs/tags/process"},{"inline":true,"label":"render","permalink":"/docs/tags/render"},{"inline":true,"label":"reverse","permalink":"/docs/tags/reverse"},{"inline":true,"label":"transcribe","permalink":"/docs/tags/transcribe"}],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9,"title":"10. Buffer Processing","tags":["freeverb","importaudio","process","render","reverse","transcribe"]},"sidebar":"tutorialSidebar","previous":{"title":"9. Automation","permalink":"/docs/learning/tutorials/automation"},"next":{"title":"11. Post-rendering Processing","permalink":"/docs/learning/tutorials/postprocessing"}}');var s=n(74848),i=n(28453);const o={sidebar_position:9,title:"10. Buffer Processing",tags:["freeverb","importaudio","process","render","reverse","transcribe"]},a="Buffer Processing",l={},c=[];function u(e){const r={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"buffer-processing",children:"Buffer Processing"})}),"\n",(0,s.jsxs)(r.p,{children:["One of the core features of ",(0,s.jsx)(r.strong,{children:"bellplay~"})," is the ability to dynamically and flexibly apply chains of DSP algorithms to our buffers.\nThis tutorial shows a very basic example of this by applying reverse delay to an audio file."]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bell",metastring:'title="buffer_processing.bell" showLineNumbers',children:"## path to built-in audio file\n$path = 'drums.wav';\n## uncomment the line below\ud83d\udc47 to use a file path of your choosing\n## $path = \"/path/to/my/file.wav\";\n## use file path to import audio file as a buffer\n$buff = importaudio($path);\n## apply processing to buffer. Notice that we need re-assign the variable\xa0\u2014 operations in bell are not destructive/do not happen in-place.\n$buff = $buff.process(\n    ## reverse buffer\n    reverse() \n    ## apply reverb\n    freeverb(@tail 500) \n    ## reverse again\n    reverse() \n);\n## transcribe and render\n$buff.transcribe(@gain .125);\nrender(@play 1)\n"})})]})}function f(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}}}]);