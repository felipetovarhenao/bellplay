"use strict";(self.webpackChunkbellplay_docs=self.webpackChunkbellplay_docs||[]).push([[6054],{28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var i=n(96540);const a={},r=i.createContext(a);function s(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(r.Provider,{value:t},e.children)}},93763:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"learning/tutorials/caching","title":"19. Caching Data","description":"In bellplay~, computation-heavy operations such as building large corpora, analyzing lots of audio data, and more, can be take a very long time, thus making it more tedious to experiment with our scripts every time we run them.","source":"@site/docs/learning/tutorials/caching.md","sourceDirName":"learning/tutorials","slug":"/learning/tutorials/caching","permalink":"/docs/learning/tutorials/caching","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"analyze","permalink":"/docs/tags/analyze"},{"inline":true,"label":"exists","permalink":"/docs/tags/exists"},{"inline":true,"label":"getkey","permalink":"/docs/tags/getkey"},{"inline":true,"label":"getmediafiles","permalink":"/docs/tags/getmediafiles"},{"inline":true,"label":"importaudio","permalink":"/docs/tags/importaudio"},{"inline":true,"label":"onsets","permalink":"/docs/tags/onsets"},{"inline":true,"label":"pitchdiff","permalink":"/docs/tags/pitchdiff"},{"inline":true,"label":"pitchmelodia","permalink":"/docs/tags/pitchmelodia"},{"inline":true,"label":"rand","permalink":"/docs/tags/rand"},{"inline":true,"label":"read","permalink":"/docs/tags/read"},{"inline":true,"label":"render","permalink":"/docs/tags/render"},{"inline":true,"label":"setkey","permalink":"/docs/tags/setkey"},{"inline":true,"label":"sortbykeys","permalink":"/docs/tags/sortbykeys"},{"inline":true,"label":"transcribe","permalink":"/docs/tags/transcribe"},{"inline":true,"label":"write","permalink":"/docs/tags/write"},{"inline":true,"label":"x2dx","permalink":"/docs/tags/x-2-dx"}],"version":"current","sidebarPosition":18,"frontMatter":{"sidebar_position":18,"title":"19. Caching Data","tags":["analyze","exists","getkey","getmediafiles","importaudio","onsets","pitchdiff","pitchmelodia","rand","read","render","setkey","sortbykeys","transcribe","write","x2dx"]},"sidebar":"tutorialSidebar","previous":{"title":"18. Audio corpora with SQL tables","permalink":"/docs/learning/tutorials/buildcorpus"},"next":{"title":"20. Multi-rendering","permalink":"/docs/learning/tutorials/multirendering"}}');var a=n(74848),r=n(28453);const s={sidebar_position:18,title:"19. Caching Data",tags:["analyze","exists","getkey","getmediafiles","importaudio","onsets","pitchdiff","pitchmelodia","rand","read","render","setkey","sortbykeys","transcribe","write","x2dx"]},o="Caching Data",l={},c=[];function d(e){const t={a:"a",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"caching-data",children:"Caching Data"})}),"\n",(0,a.jsxs)(t.p,{children:["In ",(0,a.jsx)(t.strong,{children:"bellplay~"}),", computation-heavy operations such as building large corpora, analyzing lots of audio data, and more, can be take a very long time, thus making it more tedious to experiment with our scripts every time we run them.\nIn computing, one common solution to this problem is ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Cache_(computing)",children:"caching"}),": storing data such that it can be served more quickly next time it's needed.\nThis tutorial shows how we can do something similar, by writing data in memory, such that we can skip computationally expensive operations next time we run the script. In this particular case, we manually generate a corpus or collection of analyzed buffers, and store it for faster reuse next time the script is run."]}),"\n",(0,a.jsx)(t.p,{children:"You should notice a difference in computation time between the first time the script is run, and subsequent times."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bell",metastring:'title="caching_data.bell" showLineNumbers',children:"## path to cached buffers file\n$cachedbufferspath = './cached_buffers.llll';\n## check if cache file exists\nif exists($cachedbufferspath) == 0 then (\n    ## ---- NOTE -----\n    ## This code block is only executed the very first time we run the script.\n    ## This also means that changes affecting this code block will be ignored afterwards, \n    ## unless you delete `./cached_buffers.llll`\n    ## ---------------\n    ## initialize cached buffers as null\n    $cachedbuffers = null;\n    ## get list of media files of type 'audio'\n    $files = getmediafiles('audio');\n    ## iterate over each audio file\n    for $file in $files do (\n        ## import audio file into a buffer\n        $buf = importaudio($file);\n        ## analyze buffer to detect onsets\n        $buf = $buf.analyze(onsets());\n        ## extract detected onset markers\n        $markers = $buf.getkey('onsets');\n        ## calculate durations between onsets\n        $markdur = x2dx($markers $buf.getkey('duration'));\n        ## iterate over each onset marker and corresponding duration\n        for $m in $markers, $mdur in $markdur do (\n            ## create a segment buffer with specified offset and duration\n            $bufseg = $buf.setkey('offset', $m).setkey('duration', $mdur);\n            ## define analysis operation (pitch estimation)\n            $analysis = pitchmelodia();\n            ## analyze buffer segment for pitch information\n            $bufseg = $bufseg.analyze($analysis);\n            ## extract pitch value\n            $pitch = $bufseg.getkey('pitchmelodia');\n            ## if pitch is detected (> 0), add segment to cached buffers\n            if $pitch > 0 then ($cachedbuffers _= $bufseg) \n        ) \n    );\n    ## write cached buffers to disk for later reuse\n    write($cachedbuffers, $cachedbufferspath) \n) else (\n    ## if cache file exists, read cached buffers from file\n    $cachedbuffers = read($cachedbufferspath);\n    ## ---- NOTE -----\n    ## In **bellplay~**, the \"source\" key of a buffer is **only valid within the script session** in which it was created. \n    ## If we store a buffer to a file and later reload it, its \"source\" key will no longer point to a valid resource, \n    ## because temporary buffers are not permanently saved on disk. \n    ## However, if we have access to the original file path (stored in the \"file\" key by `importaudio()`), \n    ## we can recover a valid \"source\" by re-importing the original file. \n    ## This lets us \"refresh\" the stale \"source\" values of stored buffers and reuse them correctly, without \n    ## losing data such as pre-computed features (e.g., `pitchmelodia`).\n    ## ---------------\n    ## iterate over each buffer to refresh its source key\n    $cachedbuffers = for $buf in $cachedbuffers collect (\n        ## get original file path from buffer\n        $file = $buf.getkey('file');\n        ## re-import original audio file\n        $tmpbuf = importaudio($file);\n        ## extract refreshed source key\n        $source = $tmpbuf.getkey('source');\n        ## update buffer with refreshed source (while also keeping pre-computed features)\n        $buf = $buf.setkey('source', $source);\n        ## return updated buffer\n        $buf\n    ) \n);\n## initialize transcription onset time\n$t = 0;\n## iterate over cached buffers sorted by pitchmelodia value\nfor $b in $cachedbuffers.sortbykeys('pitchmelodia') do (\n    ## get confidence value of pitch estimation\n    $conf = $b.getkey('pitchmelodia_confidence');\n    ## get detected pitch\n    $pitch = $b.getkey('pitchmelodia');\n    ## calculate detune value relative to Cmaj7 chord (pitch classes: 0 4 7 11)\n    $detune = $pitch.pitchdiff(0 4 7 11);\n    ## if pitch estimation confidence is higher than 0.15, transcribe buffer\n    if $conf > 0.15 then (\n        $b.transcribe(\n            @onset $t\n            @pitchkey 'pitchmelodia' \n            @pan rand() \n            @detune $detune\n        );\n        ## increment onset time for next transcription\n        $t += 50\n    ) \n);\n## render the transcription for playback\nrender(@play 1)\n"})})]})}function u(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);