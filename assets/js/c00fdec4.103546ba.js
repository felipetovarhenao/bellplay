"use strict";(self.webpackChunkbellplay_docs=self.webpackChunkbellplay_docs||[]).push([[4680],{5360:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>p});const r=JSON.parse('{"id":"learning/examples/gliss","title":"5. Glissando texture","description":"An example of using time-varying resampling to generate a polyphonic texture.","source":"@site/docs/learning/examples/gliss.md","sourceDirName":"learning/examples","slug":"/learning/examples/gliss","permalink":"/bellplay/docs/learning/examples/gliss","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"5. Glissando texture"},"sidebar":"tutorialSidebar","previous":{"title":"4. Waveshaping Buffers","permalink":"/bellplay/docs/learning/examples/waveshaping"},"next":{"title":"6. MIDI Retuning","permalink":"/bellplay/docs/learning/examples/midiretuning"}}');var s=t(4848),i=t(8453);const o={sidebar_position:4,title:"5. Glissando texture"},a="Glissando texture",l={},p=[];function c(e){const n={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"glissando-texture",children:"Glissando texture"})}),"\n",(0,s.jsx)(n.p,{children:"An example of using time-varying resampling to generate a polyphonic texture."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bell",metastring:'title="glissando_texture.bell" showLineNumbers',children:"## Import an audio buffer from the file 'poem.wav'\n$buf = importaudio('poem.wav');\n## Define a set of transpositions for retuning, centered around 0\n$cents = (0 2 4 7 9) * 100;\n$cents = $cents - mean($cents);\n## Convert cents to ratios\n$ratios = c2r($cents);\n## Specify the number of voices for processing\n$numvoices = 5;\n## Retune the buffer by mapping it to a neutral pitch grid\n$buf = $buf.process(retune(@pitchgrid 0 @ambiencethreshold -10));\n## Iterate over the number of voices for granular processing\nfor $v in 1...$numvoices do (\n    ## Map the voice index to a stereo pan position\n    $pan = scale($v, 1, $numvoices, 0, 1);\n    ## Randomly determine the envelope size for pitch glissando\n    $envsize = random(10, 20);\n    ## Generate a breakpoint function (BPF) for glissando effects\n    $glissbpf = for $x in 0...($envsize - 1) collect (\n        ## Select a random resampling ratio\n        $ratio = choose($ratios);\n        ## Create the BPF entry\n        [$x 1 / $ratio 0.95] \n    );\n    ## Create a resampling effect using the generated glissando BPF\n    $fx = resample($glissbpf);\n    ## Apply the effect to the buffer and transcribe with pan settings\n    $buf.process($fx).transcribe(\n        ## Set onset time to 0\n        @onset 0\n        ## Apply pan position for spatial distribution\n        @pan $pan\n    ) \n);\n## Render the processed audio with normalization and reverb\nrender(\n    @play 1 @process normalize(-3) freeverb(\n        ## Set reverb room size\n        @roomsize 0.7\n        ## Control wet/dry mix of reverb\n        @wet 0.025\n        ## Adjust damping for high-frequency absorption\n        @damp 1\n        ## Set stereo width for the effect\n        @width 1\n    ) \n)\n"})})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var r=t(6540);const s={},i=r.createContext(s);function o(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);