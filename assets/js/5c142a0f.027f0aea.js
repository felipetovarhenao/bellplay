"use strict";(self.webpackChunkbellplay_docs=self.webpackChunkbellplay_docs||[]).push([[8341],{8453:(e,n,a)=>{a.d(n,{R:()=>o,x:()=>s});var t=a(6540);const i={},r=t.createContext(i);function o(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(r.Provider,{value:n},e.children)}},9930:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>t,toc:()=>m});const t=JSON.parse('{"id":"learning/examples/temporalalignment","title":"9. Envelope-aware Temporal Alignment","description":"This example demonstrates how to align the envelopes of different audio samples based on their peak amplitude times.","source":"@site/docs/learning/examples/temporalalignment.md","sourceDirName":"learning/examples","slug":"/learning/examples/temporalalignment","permalink":"/docs/learning/examples/temporalalignment","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"sidebar_position":8,"title":"9. Envelope-aware Temporal Alignment"},"sidebar":"tutorialSidebar","previous":{"title":"8. Audio Mosaicing","permalink":"/docs/learning/examples/audiomosaic"},"next":{"title":"10. Generating Keymaps","permalink":"/docs/learning/examples/keymaps"}}');var i=a(4848),r=a(8453);const o={sidebar_position:8,title:"9. Envelope-aware Temporal Alignment"},s="Envelope-aware Temporal Alignment",l={},m=[];function p(e){const n={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"envelope-aware-temporal-alignment",children:"Envelope-aware Temporal Alignment"})}),"\n",(0,i.jsx)(n.p,{children:"This example demonstrates how to align the envelopes of different audio samples based on their peak amplitude times.\nIt first generates synthetic audio samples with random characteristics (as placeholders for, say, multiple one-shot samples), then analyzes their peak times, and finally aligns them so their peaks coincide."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bell",metastring:'title="envelope-aware_temporal_alignment.bell" showLineNumbers',children:"## Generate a collection of 10 synthetic audio buffers\n$bufs = for $i in 1...10 collect (\n    ## Define a random envelope for gain shaping\n    $env = [0 0 0] [rand(0.001, 0.5) 1 rand(0, 0.5)] [1 0 -rand(0, 0.5)];\n    ## Assign a random fundamental frequency and duration\n    $fq = random(1, 16) * 55;\n    $dur = random(300, 4000);\n    ## Label each buffer for debugging/inspection\n    $label = 'sound' + tosymbol($i);\n    ## Generate a cyclic waveform, apply gain envelope, and add to inspector window for demonstration purposes\n    cycle(@frequency $fq @duration $dur).process(gain($env)).inspect(@label $label) \n);\n## Initialize variable to store the maximum peak time\n$maxpeaktime = 0;\n## Analyze each buffer to determine the time of its peak amplitude\n$bufs = for $buf in $bufs collect (\n    ## Compute the time of maximum envelope value\n    $buf = $buf.analyze(envmaxtime());\n    ## Update max peak time across all buffers\n    $maxpeaktime = max($maxpeaktime, $buf.getkey('envmaxtime'));\n    $buf\n);\n## Insert a marker at the maximum peak time for alignment reference\naddmarker(\n    @onset $maxpeaktime @names 'peak' \n);\n## Align each buffer's peak to the maximum peak time\nfor $buf in $bufs do (\n    $peaktime = $buf.getkey('envmaxtime');\n    $onset = $maxpeaktime - $peaktime;\n    ## Transcribe buffer with adjusted onset time and random panning\n    $buf.transcribe(\n        @onset $onset @pan rand() \n    ) \n);\n## Render the final output with reverberation and normalization\nrender(\n    @play 1 @process freeverb(\n        @roomsize 0.9\n        @wet 0.025\n        @damp 0.5\n        @width 1\n    ) normalize(-6) \n)\n"})})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}}}]);