"use strict";(self.webpackChunkbellplay_docs=self.webpackChunkbellplay_docs||[]).push([[6479],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var i=t(96540);const a={},s=i.createContext(a);function r(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:n},e.children)}},77690:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>i,toc:()=>p});const i=JSON.parse('{"id":"learning/examples/keymaps","title":"11. Generating Keymaps","description":"This example automatically generates a custom keymap given a list of audio file paths:","source":"@site/docs/learning/examples/keymaps.md","sourceDirName":"learning/examples","slug":"/learning/examples/keymaps","permalink":"/docs/learning/examples/keymaps","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"analyze","permalink":"/docs/tags/analyze"},{"inline":true,"label":"approx","permalink":"/docs/tags/approx"},{"inline":true,"label":"exists","permalink":"/docs/tags/exists"},{"inline":true,"label":"export","permalink":"/docs/tags/export"},{"inline":true,"label":"ezsampler","permalink":"/docs/tags/ezsampler"},{"inline":true,"label":"getkey","permalink":"/docs/tags/getkey"},{"inline":true,"label":"getmediafiles","permalink":"/docs/tags/getmediafiles"},{"inline":true,"label":"importaudio","permalink":"/docs/tags/importaudio"},{"inline":true,"label":"importmidi","permalink":"/docs/tags/importmidi"},{"inline":true,"label":"int","permalink":"/docs/tags/int"},{"inline":true,"label":"larm","permalink":"/docs/tags/larm"},{"inline":true,"label":"left","permalink":"/docs/tags/left"},{"inline":true,"label":"onsets","permalink":"/docs/tags/onsets"},{"inline":true,"label":"pitchmelodia","permalink":"/docs/tags/pitchmelodia"},{"inline":true,"label":"rand","permalink":"/docs/tags/rand"},{"inline":true,"label":"read","permalink":"/docs/tags/read"},{"inline":true,"label":"render","permalink":"/docs/tags/render"},{"inline":true,"label":"setkey","permalink":"/docs/tags/setkey"},{"inline":true,"label":"tosymbol","permalink":"/docs/tags/tosymbol"},{"inline":true,"label":"transcribe","permalink":"/docs/tags/transcribe"},{"inline":true,"label":"write","permalink":"/docs/tags/write"},{"inline":true,"label":"x2dx","permalink":"/docs/tags/x-2-dx"}],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10,"title":"11. Generating Keymaps","tags":["analyze","approx","exists","export","ezsampler","getkey","getmediafiles","importaudio","importmidi","int","larm","left","onsets","pitchmelodia","rand","read","render","setkey","tosymbol","transcribe","write","x2dx"]},"sidebar":"tutorialSidebar","previous":{"title":"10. Envelope-aware Temporal Alignment","permalink":"/docs/learning/examples/temporalalignment"},"next":{"title":"analyze","permalink":"/docs/reference/buffer-analysis/analyze"}}');var a=t(74848),s=t(28453);const r={sidebar_position:10,title:"11. Generating Keymaps",tags:["analyze","approx","exists","export","ezsampler","getkey","getmediafiles","importaudio","importmidi","int","larm","left","onsets","pitchmelodia","rand","read","render","setkey","tosymbol","transcribe","write","x2dx"]},l="Generating Keymaps",o={},p=[];function d(e){const n={code:"code",h1:"h1",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"generating-keymaps",children:"Generating Keymaps"})}),"\n",(0,a.jsx)(n.p,{children:"This example automatically generates a custom keymap given a list of audio file paths:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"We import the audio files, detect onsets, and slice them into segments."}),"\n",(0,a.jsx)(n.li,{children:"Then analyze each segment\u2019s pitch and loudness, keeping only relevant segments (e.g., pitch, non-silent)."}),"\n",(0,a.jsx)(n.li,{children:"We quantize pitches to nearest 1/8th tone, export the valid segments as samples, and map them to their pitches."}),"\n",(0,a.jsx)(n.li,{children:"We save the final keymap to disk for reuse."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Once the keymap is ready, the script loads a MIDI file and, using an ezsampler, triggers the appropriate audio samples based on the pitch, duration, and velocity of each MIDI event.\nThe final result is rendered as audio."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bell",metastring:'title="generating_keymaps.bell" showLineNumbers',children:"## path to custom keymap file\n$keymappath = './custom_keymap.txt';\n## initialize keymap as null\n$keymap = null;\n## check if keymap file exists\nif exists($keymappath) == 0 then (\n    ## retrieve list of audio media files\n    $files = getmediafiles('audio');\n    ## initialize sample count\n    $count = 1;\n    ## iterate over each audio file\n    for $file in $files do (\n        ## import audio file into a buffer\n        $b = importaudio($file);\n        ## analyze buffer to detect onsets with specified sensitivity\n        $b = $b.analyze(onsets(@alpha 0.2 @silencethreshold 0.05));\n        ## extract onset markers\n        $markers = $b.getkey('onsets');\n        ## compute durations between onsets\n        $mdurs = x2dx($markers $b.getkey('duration'));\n        ## define analysis operations (pitch estimation and loudness)\n        $analysis = pitchmelodia() larm();\n        ## iterate over onset markers and corresponding durations\n        for $offset in $markers, $dur in $mdurs do (\n            ## create buffer segment for each detected onset\n            $bufseg = $b.setkey('offset', $offset).setkey('duration', $dur);\n            ## analyze buffer segment for pitch and loudness\n            $bufseg = $bufseg.analyze($analysis);\n            ## retrieve pitch confidence value\n            $pitchconf = $bufseg.getkey('pitchmelodia_confidence');\n            ## retrieve loudness (larm) value\n            $larm = $bufseg.getkey('larm');\n            ## filter segments based on pitch confidence and loudness thresholds\n            if $pitchconf > 0.25 && $larm > 0.005 then (\n                ## retrieve detected pitch\n                $pitch = $bufseg.getkey('pitchmelodia');\n                ## quantize pitch to nearest eighth-tone step and cast to integer\n                $pitch = int(approx($pitch @tonedivision 2));\n                ## if pitch not already in keymap, add empty mapping\n                if $keymap.$pitch == null then ($keymap _= [$pitch]);\n                ## transcribe segment\n                $bufseg.transcribe();\n                ## render current segment for export\n                render(@reset 1 @numchannels 1);\n                ## define path for exported sample\n                $path = './sample-' + tosymbol($count) + '.wav';\n                ## export buffer segment to file\n                export($path);\n                ## increment sample count\n                $count += 1;\n                ## map pitch to exported sample path\n                $keymap.$pitch _= $path\n            ) \n        ) \n    );\n    ## write updated keymap to file\n    write($keymap, $keymappath) \n) else (\n    ## if keymap file exists, read it into memory\n    $keymap = read($keymappath) \n);\n## import MIDI file containing note events\n$events = importmidi('bach.mid');\n## iterate over first 64 MIDI events\nfor $e in $events.left(64) do (\n    ## retrieve onset time of MIDI event\n    $onset = $e.getkey('onset');\n    ## retrieve pitch of MIDI event\n    $pitch = $e.getkey('pitch');\n    ## retrieve velocity of MIDI event\n    $velocity = $e.getkey('velocity');\n    ## retrieve duration of MIDI event\n    $duration = $e.getkey('duration');\n    ## use ezsampler to trigger appropriate sample based on pitch\n    ezsampler(\n        @pitch $pitch\n        @duration $duration\n        @velocity $velocity\n        @keymap $keymap\n    ).transcribe(\n        ## place sample at adjusted onset time\n        @onset $onset * 0.75\n        ## randomize panning position\n        @pan rand() \n        ## apply slight gain fadeout\n        @gain [0 1 0] [1 0 -0.125] \n    ) \n);\n## render full transcription for playback\nrender(@play 1)\n"})})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);