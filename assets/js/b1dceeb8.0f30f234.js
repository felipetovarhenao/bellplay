"use strict";(self.webpackChunkbellplay_docs=self.webpackChunkbellplay_docs||[]).push([[9131],{19868:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"learning/tutorials/multirendering","title":"20. Multi-rendering","description":"This tutorial demonstrates a very simple but consequential feature in bellplay~ \u2014 namely, the ability to reuse rendered buffers multiple times to further refine and sculpt the final output into complex and intricate sounds.","source":"@site/docs/learning/tutorials/multirendering.md","sourceDirName":"learning/tutorials","slug":"/learning/tutorials/multirendering","permalink":"/docs/learning/tutorials/multirendering","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"freeverb","permalink":"/docs/tags/freeverb"},{"inline":true,"label":"hanning","permalink":"/docs/tags/hanning"},{"inline":true,"label":"inspect","permalink":"/docs/tags/inspect"},{"inline":true,"label":"normalize","permalink":"/docs/tags/normalize"},{"inline":true,"label":"process","permalink":"/docs/tags/process"},{"inline":true,"label":"rand","permalink":"/docs/tags/rand"},{"inline":true,"label":"render","permalink":"/docs/tags/render"},{"inline":true,"label":"reverse","permalink":"/docs/tags/reverse"},{"inline":true,"label":"saw","permalink":"/docs/tags/saw"},{"inline":true,"label":"scale","permalink":"/docs/tags/scale"},{"inline":true,"label":"transcribe","permalink":"/docs/tags/transcribe"}],"version":"current","sidebarPosition":19,"frontMatter":{"sidebar_position":19,"title":"20. Multi-rendering","tags":["freeverb","hanning","inspect","normalize","process","rand","render","reverse","saw","scale","transcribe"]},"sidebar":"tutorialSidebar","previous":{"title":"19. Caching Data","permalink":"/docs/learning/tutorials/caching"},"next":{"title":"21. Basic Sampling","permalink":"/docs/learning/tutorials/sampling"}}');var i=r(74848),a=r(28453);const s={sidebar_position:19,title:"20. Multi-rendering",tags:["freeverb","hanning","inspect","normalize","process","rand","render","reverse","saw","scale","transcribe"]},l="Multi-rendering",o={},c=[];function d(e){const n={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"multi-rendering",children:"Multi-rendering"})}),"\n",(0,i.jsxs)(n.p,{children:["This tutorial demonstrates a very simple but consequential feature in ",(0,i.jsx)(n.strong,{children:"bellplay~"})," \u2014 namely, the ability to reuse rendered buffers multiple times to further refine and sculpt the final output into complex and intricate sounds."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bell",metastring:'title="multi-rendering.bell" showLineNumbers',children:"## generate granular sequence\nfor $n in 0...80 do (\n    $fq = rand(20, 2000);\n    $onset = $n * 60;\n    $gain = rand(0.125);\n    $grain = saw($fq @duration 100);\n    $grain.transcribe(\n        @onset $onset\n        @gain $gain * hanning() \n        @pan rand() \n    ) \n);\n## render into single buffer and clear transcription\n$buff = render(@reset 1).inspect('first render');\n## create a comb-like delay by transcribing closely-spaced copies of the rendered buffer \nfor $n in 0...50 do (\n    ## make onsets near-evenly spaced\n    $onset = $n + $n * 7;\n    ## make each copy gradually softer\n    $gain = scale($n, 0, 50, 1, 0) ** 1.5;\n    $buff.transcribe(\n        @onset $onset @gain $gain\n    ) \n);\n## render again and normalize to -6 dB, reset transcription afterwards\n$buff = render(\n    @reset 1 @process normalize(-6) \n).inspect('second render');\n## transcribe rendered buffer twice, original and reversed, with soft left-right panning\n$buff.transcribe(@pan 0.1);\n$buff.process(\n    ## reverse buffer before transcribing\n    reverse() \n).transcribe(@pan .9);\n## render one last time\nrender(\n    @play 1 @process freeverb(\n        @roomsize .85 @wet [0 0 0] [1 .8 .5] \n    ) \n).inspect('third and final render')\n"})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>l});var t=r(96540);const i={},a=t.createContext(i);function s(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);