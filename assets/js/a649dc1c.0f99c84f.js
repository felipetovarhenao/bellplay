"use strict";(self.webpackChunkbellplay_docs=self.webpackChunkbellplay_docs||[]).push([[9376],{17149:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>p,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"learning/tutorials/sampling","title":"21. Basic Sampling","description":"In bellplay~, the ezsampler function provides a minimal but flexible interface for mapping symbolic pitch and velocity information to audio buffers.","source":"@site/docs/learning/tutorials/sampling.md","sourceDirName":"learning/tutorials","slug":"/learning/tutorials/sampling","permalink":"/docs/learning/tutorials/sampling","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"addmarker","permalink":"/docs/tags/addmarker"},{"inline":true,"label":"ezsampler","permalink":"/docs/tags/ezsampler"},{"inline":true,"label":"f2mc","permalink":"/docs/tags/f-2-mc"},{"inline":true,"label":"normalize","permalink":"/docs/tags/normalize"},{"inline":true,"label":"rand","permalink":"/docs/tags/rand"},{"inline":true,"label":"render","permalink":"/docs/tags/render"},{"inline":true,"label":"transcribe","permalink":"/docs/tags/transcribe"}],"version":"current","sidebarPosition":20,"frontMatter":{"sidebar_position":20,"title":"21. Basic Sampling","tags":["addmarker","ezsampler","f2mc","normalize","rand","render","transcribe"]},"sidebar":"tutorialSidebar","previous":{"title":"20. Multi-rendering","permalink":"/docs/learning/tutorials/multirendering"},"next":{"title":"22. Importing MIDI","permalink":"/docs/learning/tutorials/importingmidi"}}');var a=i(74848),t=i(28453);const l={sidebar_position:20,title:"21. Basic Sampling",tags:["addmarker","ezsampler","f2mc","normalize","rand","render","transcribe"]},r="Basic Sampling",o={},c=[{value:"Basic Format: One Pitch \u2192 One Sample",id:"basic-format-one-pitch--one-sample",level:3},{value:"Multiple Pitches",id:"multiple-pitches",level:3},{value:"Velocity Layers",id:"velocity-layers",level:3},{value:"Sample Variation (Randomized Selection)",id:"sample-variation-randomized-selection",level:3},{value:"Combined Structure: Mixed Formats",id:"combined-structure-mixed-formats",level:3}];function d(e){const n={admonition:"admonition",code:"code",h1:"h1",h3:"h3",header:"header",hr:"hr",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"basic-sampling",children:"Basic Sampling"})}),"\n",(0,a.jsxs)(n.p,{children:["In ",(0,a.jsx)(n.strong,{children:"bellplay~"}),", the ",(0,a.jsx)(n.code,{children:"ezsampler"})," function provides a minimal but flexible interface for mapping symbolic pitch and velocity information to audio buffers.\nIt expects a data structure called a ",(0,a.jsx)(n.strong,{children:"keymap"}),", which describes how input events should be translated into audio samples."]}),"\n",(0,a.jsxs)(n.p,{children:["A ",(0,a.jsx)(n.strong,{children:"keymap"})," is a list that maps a pitch (and optionally a velocity) to one or more audio files.\nEach item in the list represents a possible match for a given pitch and may take several different forms, depending on the level of specificity or variation desired.\nHere are some examples:"]}),"\n",(0,a.jsx)(n.h3,{id:"basic-format-one-pitch--one-sample",children:"Basic Format: One Pitch \u2192 One Sample"}),"\n",(0,a.jsx)(n.p,{children:"The simplest form of a keymap maps a single pitch value to a corresponding sample.\nIf only one mapping is provided, the sample will be used regardless of pitch."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bell",children:"$keymap = [6000 'guitar.wav']\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This instructs ",(0,a.jsx)(n.code,{children:"ezsampler"})," to use ",(0,a.jsx)(n.code,{children:"'guitar.wav'"})," for ",(0,a.jsx)(n.strong,{children:"all"})," input pitches."]}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:["Incidentally, the keymap above is what ",(0,a.jsx)(n.code,{children:"ezsampler"})," uses by default, when no keymap is provided."]})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h3,{id:"multiple-pitches",children:"Multiple Pitches"}),"\n",(0,a.jsx)(n.p,{children:"We can provide several pitch-sample pairs.\nThe one with the closest pitch will be chosen."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bell",children:"$keymap = (\n    [6000 'guitar.wav']\n    [6900 'flute.wav']\n)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Here, if the input pitch is closer to ",(0,a.jsx)(n.code,{children:"6900"}),", ",(0,a.jsx)(n.code,{children:"'flute.wav'"})," is used; otherwise ",(0,a.jsx)(n.code,{children:"'guitar.wav'"}),"."]}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["To ensure ",(0,a.jsx)(n.code,{children:"ezsampler"})," correctly adjust the pitch of the original sample, always make sure the pitch mapping is as accurate as possible."]})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h3,{id:"velocity-layers",children:"Velocity Layers"}),"\n",(0,a.jsx)(n.p,{children:"Each pitch can be associated with multiple velocity-dependent mappings.\nThese are expressed as nested lists."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bell",children:"$keymap = (\n    [6900\n        [0 './soft.wav']\n        [127 './loud.wav']\n    ]\n)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["With this, ",(0,a.jsx)(n.code,{children:"ezsampler"})," chooses ",(0,a.jsx)(n.code,{children:"'soft.wav'"})," or ",(0,a.jsx)(n.code,{children:"'loud.wav'"})," based on how close the input velocity is to the specified values (0 or 127)."]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h3,{id:"sample-variation-randomized-selection",children:"Sample Variation (Randomized Selection)"}),"\n",(0,a.jsx)(n.p,{children:"To add variability, we can associate pitch or velocity entries with multiple samples. The sampler will randomly pick one."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bell",children:"$keymap = (\n    [6900 'flute1.wav' 'flute2.wav']\n)\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h3,{id:"combined-structure-mixed-formats",children:"Combined Structure: Mixed Formats"}),"\n",(0,a.jsx)(n.p,{children:"We can also define heterogeneous mappings in a single keymap. For instance:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bell",children:"$keymap = (\n    [6000 './mono.wav']                 ## simple single sample\n    [6300 './samp1.wav' './samp2.wav']  ## randomized selection\n    [6600                               ## velocity + random\n        [0 './soft1.wav' '/soft2.wav'] \n        [127 './loud.wav']\n    ]\n    [6900                               ## velocity selection\n        [127 './bright.wav'] \n        [0 './dark.wav']\n    ]\n)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Once a keymap is defined, it can be passed to ",(0,a.jsx)(n.code,{children:"ezsampler"}),", along with parameters like pitch, velocity, and duration.\nA buffer with the selected sample will then be created and modified at the appropriate time and detuned to match the desired pitch."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bell",children:"$buf = ezsampler(\n    @pitch 6200 \n    @duration 1200\n    @velocity 64 \n    @keymap $mykeymap\n)\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:["Currently, ",(0,a.jsx)(n.code,{children:"ezsampler"})," adjust the pitch of a buffer via basic [resampling]. This means the duration of the resulting buffer is constrained by the duration of the actual sample."]})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.p,{children:"The complete example below shows how to generate and transcribe multiple pitches using different keymaps, each showcasing one of the formats above:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bell",metastring:'title="basic_sampling.bell" showLineNumbers',children:"## At its most basic, a sampler keymap is a list of pitches with a corresponding audio file.\n$keymap1 = (\n    ## if we only provide one pitch-sample pair, the same sample is used for all pitches\n    [6000 'guitar.wav' ] \n);\n## we can specify multiple pitch-sample pairs.\n$keymap2 = (\n    ## this sample is used when pitch is closest to 6000\n    [6000 'guitar.wav' ] \n    ## this sample is used when pitch is closest to 6900\n    [6900 'flute.wav' ] \n);\n## we can also break down samples based on velocity\n$keymap3 = (\n    ## this sample is used when pitch is closest to 6000\n    [6000 'guitar.wav'] \n    ## these samples are used when pitch is closest to 6900\n    [\n        6900\n        ## this sample is used when pitch is closest to 6900 AND velocity is closest to 127\n        [127 'flute.wav'] \n        ## this sample is used when pitch is closest to 6900 AND velocity is closest to 0\n        [0 'viola.wav'] \n    ] \n);\n## we can make samplers less predictable by specifying multiple samples per pitch or velocity\n$keymap4 = (\n    ## one these samples will be chosen at random when pitch is closest to 6900\n    [\n        6900 'flute.wav' 'viola.wav' \n    ] \n);\n## generate some pitches\n$numnotes = 8;\n$harmonics = f2mc((1...$numnotes) * 110);\n$onset = 0;\n$dur = 300;\n## transcribe pitches using each keymap.\nfor $keymap $id in [$keymap1] [$keymap2] [$keymap3] [$keymap4] with @unwrap 1 do (\n    addmarker($onset, 'keymap' $id);\n    for $mc in $harmonics do (\n        ezsampler(\n            ## desired pitch\n            @pitch $mc\n            ## subtle legato\n            @duration $dur * 1.1\n            ## current keymap\n            @keymap $keymap\n            ## randomize velocity\n            @velocity rand(127) \n        ).transcribe(@onset $onset);\n        $onset += $dur\n    );\n    $onset += 1000\n);\n## trigger rendering\nrender(\n    @play 1 @process normalize(-3) \n)\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["If you need reproducibility, set the ",(0,a.jsx)(n.code,{children:"@useseed"})," argument to ",(0,a.jsx)(n.code,{children:"1"})," in ",(0,a.jsx)(n.code,{children:"ezsampler"}),". Take a look at the ",(0,a.jsx)(n.code,{children:"setseed"})," function for more information."]})})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>r});var s=i(96540);const a={},t=s.createContext(a);function l(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);