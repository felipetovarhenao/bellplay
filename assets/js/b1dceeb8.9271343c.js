"use strict";(self.webpackChunkbellplay_docs=self.webpackChunkbellplay_docs||[]).push([[9131],{8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>o});var t=r(6540);const i={},a=t.createContext(i);function s(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(a.Provider,{value:n},e.children)}},9868:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"learning/tutorials/multirendering","title":"21. Multi-rendering","description":"This tutorial demonstrates a very simple but consequential feature in bellplay~ \u2014 namely, the ability to reuse rendered buffers multiple times to further refine and sculpt the final output into complex and intricate sounds.","source":"@site/docs/learning/tutorials/multirendering.md","sourceDirName":"learning/tutorials","slug":"/learning/tutorials/multirendering","permalink":"/docs/learning/tutorials/multirendering","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":20,"frontMatter":{"sidebar_position":20,"title":"21. Multi-rendering"},"sidebar":"tutorialSidebar","previous":{"title":"20. Caching Data","permalink":"/docs/learning/tutorials/caching"},"next":{"title":"22. Basic Sampling","permalink":"/docs/learning/tutorials/sampling"}}');var i=r(4848),a=r(8453);const s={sidebar_position:20,title:"21. Multi-rendering"},o="Multi-rendering",l={},d=[];function c(e){const n={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"multi-rendering",children:"Multi-rendering"})}),"\n",(0,i.jsxs)(n.p,{children:["This tutorial demonstrates a very simple but consequential feature in ",(0,i.jsx)(n.strong,{children:"bellplay~"})," \u2014 namely, the ability to reuse rendered buffers multiple times to further refine and sculpt the final output into complex and intricate sounds."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bell",metastring:'title="multi-rendering.bell" showLineNumbers',children:"## generate granular sequence\nfor $n in 0...80 do (\n    $fq = rand(20, 2000);\n    $onset = $n * 60;\n    $gain = rand(0.125);\n    $grain = saw($fq @duration 100);\n    $grain.transcribe(\n        @onset $onset\n        @gain $gain * hanning() \n        @pan rand() \n    ) \n);\n## render into single buffer and clear transcription\n$buff = render(@reset 1).inspect('first render');\n## create a comb-like delay by transcribing closely-spaced copies of the rendered buffer \nfor $n in 0...50 do (\n    ## make onsets near-evenly spaced\n    $onset = $n + $n * 7;\n    ## make each copy gradually softer\n    $gain = scale($n, 0, 50, 1, 0) ** 1.5;\n    $buff.transcribe(\n        @onset $onset @gain $gain\n    ) \n);\n## render again and normalize to -6 dB, reset transcription afterwards\n$buff = render(\n    @reset 1 @process normalize(-6) \n).inspect('second render');\n## transcribe rendered buffer twice, original and reversed, with soft left-right panning\n$buff.transcribe(@pan 0.1);\n$buff.process(\n    ## reverse buffer before transcribing\n    reverse() \n).transcribe(@pan .9);\n## render one last time\nrender(\n    @play 1 @process freeverb(\n        @roomsize .85 @wet [0 0 0] [1 .8 .5] \n    ) \n).inspect('third and final render')\n"})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);