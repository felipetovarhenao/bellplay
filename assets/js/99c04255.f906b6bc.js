"use strict";(self.webpackChunkbellplay_docs=self.webpackChunkbellplay_docs||[]).push([[8860],{5309:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>p});const a=JSON.parse('{"id":"learning/examples/keymaps","title":"10. Generating Keymaps","description":"This example automatically generates a custom keymap given a list of audio file paths:","source":"@site/docs/learning/examples/keymaps.md","sourceDirName":"learning/examples","slug":"/learning/examples/keymaps","permalink":"/bellplay/docs/learning/examples/keymaps","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9,"title":"10. Generating Keymaps"},"sidebar":"tutorialSidebar","previous":{"title":"9. Envelope-aware Temporal Alignment","permalink":"/bellplay/docs/learning/examples/temporalalignment"},"next":{"title":"About","permalink":"/bellplay/docs/category/about"}}');var i=t(4848),s=t(8453);const r={sidebar_position:9,title:"10. Generating Keymaps"},o="Generating Keymaps",l={},p=[];function c(e){const n={code:"code",h1:"h1",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"generating-keymaps",children:"Generating Keymaps"})}),"\n",(0,i.jsx)(n.p,{children:"This example automatically generates a custom keymap given a list of audio file paths:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"We import the audio files, detect onsets, and slice them into segments."}),"\n",(0,i.jsx)(n.li,{children:"Then analyze each segment\u2019s pitch and loudness, keeping only relevant segments (e.g., pitch, non-silent)."}),"\n",(0,i.jsx)(n.li,{children:"We quantize pitches to nearest 1/8th tone, export the valid segments as samples, and map them to their pitches."}),"\n",(0,i.jsx)(n.li,{children:"We save the final keymap to disk for reuse."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Once the keymap is ready, the script loads a MIDI file and, using an ezsampler, triggers the appropriate audio samples based on the pitch, duration, and velocity of each MIDI event.\nThe final result is rendered as audio."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bell",metastring:'title="generating_keymaps.bell" showLineNumbers',children:"## path to custom keymap file\n$keymappath = './custom_keymap.txt';\n## initialize keymap as null\n$keymap = null;\n## check if keymap file exists\nif exists($keymappath) == 0 then (\n    ## retrieve list of audio media files\n    $files = getmediafiles('audio');\n    ## initialize sample count\n    $count = 1;\n    ## iterate over each audio file\n    for $file in $files do (\n        ## import audio file into a buffer\n        $b = importaudio($file);\n        ## analyze buffer to detect onsets with specified sensitivity\n        $b = $b.analyze(onsets(@alpha 0.2 @silencethreshold 0.05));\n        ## extract onset markers\n        $markers = $b.getkey('onsets');\n        ## compute durations between onsets\n        $mdurs = x2dx($markers $b.getkey('duration'));\n        ## define analysis operations (pitch estimation and loudness)\n        $analysis = pitchmelodia() larm();\n        ## iterate over onset markers and corresponding durations\n        for $offset in $markers, $dur in $mdurs do (\n            ## create buffer segment for each detected onset\n            $bufseg = $b.setkey('offset', $offset).setkey('duration', $dur);\n            ## analyze buffer segment for pitch and loudness\n            $bufseg = $bufseg.analyze($analysis);\n            ## retrieve pitch confidence value\n            $pitchconf = $bufseg.getkey('pitchmelodia_confidence');\n            ## retrieve loudness (larm) value\n            $larm = $bufseg.getkey('larm');\n            ## filter segments based on pitch confidence and loudness thresholds\n            if $pitchconf > 0.25 && $larm > 0.005 then (\n                ## retrieve detected pitch\n                $pitch = $bufseg.getkey('pitchmelodia');\n                ## quantize pitch to nearest eighth-tone step and cast to integer\n                $pitch = int(approx($pitch @tonedivision 2));\n                ## if pitch not already in keymap, add empty mapping\n                if $keymap.$pitch == null then ($keymap _= [$pitch]);\n                ## transcribe segment\n                $bufseg.transcribe();\n                ## render current segment for export\n                render(@reset 1 @numchannels 1);\n                ## define path for exported sample\n                $path = './sample-' + tosymbol($count) + '.wav';\n                ## export buffer segment to file\n                export($path);\n                ## increment sample count\n                $count += 1;\n                ## map pitch to exported sample path\n                $keymap.$pitch _= $path\n            ) \n        ) \n    );\n    ## write updated keymap to file\n    write($keymap, $keymappath) \n) else (\n    ## if keymap file exists, read it into memory\n    $keymap = read($keymappath) \n);\n## import MIDI file containing note events\n$events = importmidi('bach.mid');\n## iterate over first 64 MIDI events\nfor $e in $events.left(64) do (\n    ## retrieve onset time of MIDI event\n    $onset = $e.getkey('onset');\n    ## retrieve pitch of MIDI event\n    $pitch = $e.getkey('pitch');\n    ## retrieve velocity of MIDI event\n    $velocity = $e.getkey('velocity');\n    ## retrieve duration of MIDI event\n    $duration = $e.getkey('duration');\n    ## use ezsampler to trigger appropriate sample based on pitch\n    ezsampler(\n        @pitch $pitch\n        @duration $duration\n        @velocity $velocity\n        @keymap $keymap\n    ).transcribe(\n        ## place sample at adjusted onset time\n        @onset $onset * 0.75\n        ## randomize panning position\n        @pan rand() \n        ## apply slight gain fadeout\n        @gain [0 1 0] [1 0 -0.125] \n    ) \n);\n## render full transcription for playback\nrender(@play 1)\n"})})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var a=t(6540);const i={},s=a.createContext(i);function r(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);