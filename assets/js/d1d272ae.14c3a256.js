"use strict";(self.webpackChunkbellplay_docs=self.webpackChunkbellplay_docs||[]).push([[8069],{460:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"learning/examples/basicgranulation","title":"2. Basic Granulation","description":"An example of basic audio granulation, where short audio.","source":"@site/docs/learning/examples/basicgranulation.md","sourceDirName":"learning/examples","slug":"/learning/examples/basicgranulation","permalink":"/bellplay/docs/learning/examples/basicgranulation","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"2. Basic Granulation"},"sidebar":"tutorialSidebar","previous":{"title":"1. Audio Resynthesis","permalink":"/bellplay/docs/learning/examples/resynthesis"},"next":{"title":"3. Feedback Synthesis","permalink":"/bellplay/docs/learning/examples/feedbacksynth"}}');var r=t(4848),i=t(8453);const o={sidebar_position:1,title:"2. Basic Granulation"},s="Basic Granulation",l={},d=[];function u(e){const n={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"basic-granulation",children:"Basic Granulation"})}),"\n",(0,r.jsx)(n.p,{children:"An example of basic audio granulation, where short audio.\nGrains are extracted and reassembled to create a texture.\nIt focuses on randomizing parameters like grain size and density, selecting source material, and layering grains to produce evolving, complex sonic results."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bell",metastring:'title="basic_granulation.bell" showLineNumbers',children:"## Import sound to perform granulation on\n$buf = importaudio('singing.wav');\n## Retrieve the duration of the imported sound\n$bufdur = $buf.getkey('duration');\n## Define the total duration for the granular procesing output\n$totdur = 8000;\n## Initialize the onset time for grains\n$onset = 0;\n## Define a breakpoint function (BPF) to control grain playback positions\n$readbpf = [0 0 0] [1 1 0];\n## Set the duration of each grain in milliseconds\n$graindur = 100;\n## Compute the maximum possible offset within the buffer, ensuring grains do not exceed the buffer duration\n$maxoffset = $bufdur - $graindur;\n## Define grain windowing process\n$win = window();\n## Set a jitter value for randomizing the grain start times\n$jitter = 1000;\n## Define the overlap factor for grain scheduling\n$overlap = 4;\n## Iterate until the onset time reaches the total duration\nwhile $onset < $totdur do (\n    ## Normalize the current onset time to a [0,1] range\n    $nt = $onset / $totdur;\n    ## Determine the grain offset using the breakpoint function (BPF)\n    $offset = samplebpf($readbpf, $nt) * $maxoffset;\n    ## Apply random jitter to the grain offset\n    $offsetvar = rand(-1, 1) * $jitter;\n    ## Clamp the offset value within valid buffer boundaries\n    $offset = max(0, min($maxoffset, $offset + $offsetvar));\n    ## Create a grain with specified duration and computed offset\n    $grain = $buf.setkey('duration', $graindur).setkey('offset', $offset);\n    ## Apply windowing and transcribe the grain with randomized parameters\n    $grain.process($win).transcribe(\n        ## Introduce slight randomness to onset times\n        @onset $onset + rand(-1, 1) * $graindur\n        ## Randomize stereo placement\n        @pan rand() \n        ## Randomize amplitude between 0.5 and 1\n        @gain rand(0.5, 1) \n    );\n    ## Increment onset time based on overlap factor\n    $onset += $graindur / $overlap\n);\n## Render the audio output and play the result\nrender(@play 1)\n"})})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var a=t(6540);const r={},i=a.createContext(r);function o(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);