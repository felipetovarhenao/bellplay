"use strict";(self.webpackChunkbellplay_docs=self.webpackChunkbellplay_docs||[]).push([[9584],{28453:(e,n,a)=>{a.d(n,{R:()=>s,x:()=>o});var r=a(96540);const i={},t=r.createContext(i);function s(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(t.Provider,{value:n},e.children)}},44096:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"learning/examples/feedbacksynth","title":"3. Feedback Synthesis","description":"This code demonstrates a feedback-based synthesis technique, where buffers are routed back into their own processing chain to create a rich, evolving drone.","source":"@site/docs/learning/examples/feedbacksynth.md","sourceDirName":"learning/examples","slug":"/learning/examples/feedbacksynth","permalink":"/docs/learning/examples/feedbacksynth","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"arithmser","permalink":"/docs/tags/arithmser"},{"inline":true,"label":"cycle","permalink":"/docs/tags/cycle"},{"inline":true,"label":"multiply","permalink":"/docs/tags/multiply"},{"inline":true,"label":"normalize","permalink":"/docs/tags/normalize"},{"inline":true,"label":"pong","permalink":"/docs/tags/pong"},{"inline":true,"label":"process","permalink":"/docs/tags/process"},{"inline":true,"label":"rand","permalink":"/docs/tags/rand"},{"inline":true,"label":"random","permalink":"/docs/tags/random"},{"inline":true,"label":"render","permalink":"/docs/tags/render"},{"inline":true,"label":"scale","permalink":"/docs/tags/scale"},{"inline":true,"label":"scaling","permalink":"/docs/tags/scaling"},{"inline":true,"label":"transcribe","permalink":"/docs/tags/transcribe"}],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"3. Feedback Synthesis","tags":["arithmser","cycle","multiply","normalize","pong","process","rand","random","render","scale","scaling","transcribe"]},"sidebar":"tutorialSidebar","previous":{"title":"2. Basic Granulation","permalink":"/docs/learning/examples/basicgranulation"},"next":{"title":"4. Waveshaping Buffers","permalink":"/docs/learning/examples/waveshaping"}}');var i=a(74848),t=a(28453);const s={sidebar_position:2,title:"3. Feedback Synthesis",tags:["arithmser","cycle","multiply","normalize","pong","process","rand","random","render","scale","scaling","transcribe"]},o="Feedback Synthesis",l={},c=[];function d(e){const n={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"feedback-synthesis",children:"Feedback Synthesis"})}),"\n",(0,i.jsx)(n.p,{children:"This code demonstrates a feedback-based synthesis technique, where buffers are routed back into their own processing chain to create a rich, evolving drone.\nIt showcases the use of buffers as processing parameters, illustrating how feedback loops can be used creatively for sound design."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bell",metastring:'title="feedback_synthesis.bell" showLineNumbers',children:"## Define the total duration of the synthesized sound in milliseconds\n$duration = 25000;\n## Generate a random base frequency for the carrier oscillator\n$fzero = rand(20, 80);\n## Define the number of voices in the synthesis\n$numvoices = 3;\n## Iterate over evenly spaced pan positions for each voice\nfor $pan in arithmser(0, 1, null, $numvoices) do (\n    ## Create a carrier oscillator with the base frequency and duration\n    $car = cycle(@frequency $fzero @duration $duration);\n    ## Randomly determine the number of modulation layers\n    $times = random(1, 5);\n    ## Apply frequency modulation layers\n    for $i in 1...$times do (\n        ## Generate a random modulation frequency in a given range\n        $fq = rand(0, 1).scale(0, 1, 40, 8000);\n        ## Create a modulator oscillator with the computed frequency\n        $mod = cycle(\n            @frequency $fq @duration $duration\n        );\n        ## Scale the modulator output to a desired amplitude range\n        $outmin = rand(0.1, 0.9);\n        $mod = $mod.process(scaling(-1, 1, $outmin, 1));\n        ## Generate breakpoint functions for dynamic range limiting\n        $low = for $x in 0...random(0, 10) collect [$x rand(-1) 0.25];\n        $hi = for $x in 0...random(0, 10) collect [$x rand(1) 0.25];\n        ## Apply modulation and dynamic range control\n        $car = $car.process(\n            ## modulate amplitude\n            multiply($mod) \n            ## apply range limiting\n            pong($low, $hi) \n            ## normalize to 0dB\n            normalize(0) \n        ) \n    );\n    ## Transcribe the processed carrier with spatial positioning\n    $car.transcribe(\n        @pan $pan\n        ## apply gain envelope\n        @gain [0 1 0] [1 0.5 -0.5] [2 1 0.5] \n    ) \n);\n## Render the final output with normalization applied\nrender(\n    ## Normalize audio to -12 dB\n    @play 1 @process normalize(-12) \n)\n"})})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);