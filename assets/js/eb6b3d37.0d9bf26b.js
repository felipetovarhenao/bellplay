"use strict";(self.webpackChunkbellplay_docs=self.webpackChunkbellplay_docs||[]).push([[7017],{3002:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"learning/tutorials/postprocessing","title":"10. Post-rendering Processing","description":"Sometimes it can be more useful or desirable to apply processing to the entire output, instead of processing each buffer individually.","source":"@site/docs/learning/tutorials/postprocessing.md","sourceDirName":"learning/tutorials","slug":"/learning/tutorials/postprocessing","permalink":"/bellplay/docs/learning/tutorials/postprocessing","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9,"title":"10. Post-rendering Processing"},"sidebar":"tutorialSidebar","previous":{"title":"9. Buffer Processing","permalink":"/bellplay/docs/learning/tutorials/bufferprocessing"},"next":{"title":"11. Exporting","permalink":"/bellplay/docs/learning/tutorials/export"}}');var i=r(4848),s=r(8453);const o={sidebar_position:9,title:"10. Post-rendering Processing"},a="Post-rendering Processing",l={},c=[];function p(e){const n={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"post-rendering-processing",children:"Post-rendering Processing"})}),"\n",(0,i.jsx)(n.p,{children:"Sometimes it can be more useful or desirable to apply processing to the entire output, instead of processing each buffer individually.\nThis tutorial provides a basic example of how to apply processing after the transcribed buffers have been rendered."}),"\n",(0,i.jsx)(n.p,{children:"First, we transcribe two buffers, and process them individually to apply retuning such that they conform to a pentatonic major scale.\nOnce transcribed, we apply reverb and gain normalization to the entire rendered output, instead of doing it to each buffer."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bell",metastring:'title="post-rendering_processing.bell" showLineNumbers',children:"## list of files to import\n$files = (\n    'trumpet.wav' 'singing.wav' \n);\n## pitch class grid, in this case a pentatonic major scale\n$pcgrid = 0 2 4 7 9;\n## iterate through each file path in the list\nfor $file in $files do (\n    ## import file as a buffer\n    $buff = importaudio($file);\n    ## apply retuning to conform to pitch class grid\n    $buff = $buff.process(retune($pcgrid) );\n    ## random panning value\n    $pan = rand();\n    ## transcribe buffer with random panning envelope\n    $buff.transcribe(@pan $pan (1 - $pan)) \n);\n## trigger rendering\nrender(\n    ## auto-play after rendering\n    @play 1\n    ## apply post-processing\n    @process (\n        ## first reverb\n        freeverb(@roomsize .5) \n        ## then gain normalization to -12 dB\n        normalize(-12) \n    ) \n)\n"})})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var t=r(6540);const i={},s=t.createContext(i);function o(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);