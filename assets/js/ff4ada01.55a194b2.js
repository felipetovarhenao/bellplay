"use strict";(self.webpackChunkbellplay_docs=self.webpackChunkbellplay_docs||[]).push([[3910],{8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>i});var r=t(6540);const a={},o=r.createContext(a);function s(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(o.Provider,{value:n},e.children)}},9477:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>u});const r=JSON.parse('{"id":"learning/tutorials/automation","title":"8. Automation","description":"In many cases, we will want to have some kind of DAW-style automation of certain parameters when generating or processing audio in our scripts.","source":"@site/docs/learning/tutorials/automation.md","sourceDirName":"learning/tutorials","slug":"/learning/tutorials/automation","permalink":"/bellplay/docs/learning/tutorials/automation","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7,"title":"8. Automation"},"sidebar":"tutorialSidebar","previous":{"title":"7. Markers","permalink":"/bellplay/docs/learning/tutorials/markers"},"next":{"title":"9. Buffer Processing","permalink":"/bellplay/docs/learning/tutorials/bufferprocessing"}}');var a=t(4848),o=t(8453);const s={sidebar_position:7,title:"8. Automation"},i="Automation",l={},u=[];function c(e){const n={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"automation",children:"Automation"})}),"\n",(0,a.jsxs)(n.p,{children:["In many cases, we will want to have some kind of DAW-style automation of certain parameters when generating or processing audio in our scripts.\nOne way of doing this is through breakpoint functions \u2014 numeric lists that describe a certain shape or trajectory.\nThis tutorial shows the different syntaxes available in ",(0,a.jsx)(n.strong,{children:"bellplay~"})," for specifying breakpoint functions."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bell",metastring:'title="automation.bell" showLineNumbers',children:"## duration value for all buffers\n$dur = 2000;\n## frequency envelope, in equi-distant linear syntax\n$fq = 220 440 330 220;\n## generate and transcribe sinusoidal oscillator buffer\ncycle(\n    @frequency $fq @duration $dur\n).transcribe();\n## add marker to match start of sinusoidal oscillator\naddmarker(\n    @onset 0 @names 'sinusoidal' \n);\n## ----------------------------------------------\n## frequency envelope, in wrapped xy-pair syntax\n$fq = [0 220] [1 440] [3 220];\n## generate and transcribe triangular wave oscillator buffer\ntri(\n    @frequency $fq @duration $dur\n).transcribe(@onset $dur);\n## another marker matching start of triangular wave oscillator\naddmarker(\n    @onset $dur @names 'triangular' \n);\n## ----------------------------------------------\n## wrapped xy-slope tuples (linear)\n$fq = [0 220 0] [1 440 0] [3 220 0];\n## generate and transcribe square wave oscillator buffer\nrect(\n    @frequency $fq @duration $dur\n).transcribe(@onset $dur * 2);\n## third marker matching start of square wave oscillator\naddmarker($dur * 2, 'square');\n## ----------------------------------------------\n## wrapped xy-slope tuples (with curves)\n$fq = [0 220 0] [1 440 0.5] [3 220 -0.5];\n## generate and transcribe sawtooth wave oscillator buffer\nsaw(\n    @frequency $fq @duration $dur\n).transcribe(@onset $dur * 3 @gain .125);\n## last marker matching start of sawtooth wave oscillator\naddmarker($dur * 3, 'sawtooth \u2014 has curved envelope');\n## render everything\nrender(@play 1)\n"})})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);