"use strict";(self.webpackChunkbellplay_docs=self.webpackChunkbellplay_docs||[]).push([[1068],{2051:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"learning/tutorials/rendering","title":"5. Rendering","description":"Similar to the transcription stage, the rendering stage allows us to define important aspects about the final output.","source":"@site/docs/learning/tutorials/rendering.md","sourceDirName":"learning/tutorials","slug":"/learning/tutorials/rendering","permalink":"/docs/learning/tutorials/rendering","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"5. Rendering"},"sidebar":"tutorialSidebar","previous":{"title":"4. Transcription","permalink":"/docs/learning/tutorials/transcription"},"next":{"title":"6. Buffer Keys","permalink":"/docs/learning/tutorials/bufferkeys"}}');var i=t(4848),a=t(8453);const o={sidebar_position:4,title:"5. Rendering"},s="Rendering",l={},c=[];function d(e){const n={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"rendering",children:"Rendering"})}),"\n",(0,i.jsx)(n.p,{children:"Similar to the transcription stage, the rendering stage allows us to define important aspects about the final output.\nFor instance, the sampling rate, the number of output channels for the rendered output, how the panning of each transcribed buffer is interpreted given the number of channels."}),"\n",(0,i.jsx)(n.p,{children:"Although there are many more features to the render function to be explored in later tutorials, the code below shows a very basic example of this."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bell",metastring:'title="rendering.bell" showLineNumbers',children:"## generate 2-second buffer with white noise and transcribe\nnoise(@duration 2000).transcribe(\n    @pan 0 1\n    ## we specify gain as break-point functions/envelope, which will be covered in a later tutorial\n    @gain [0 0 0] [1 0.5 0.5] \n);\n## render buffer and specify output channels, sampling rate, fade-in/out duration applied to every transcribed buffer\nrender(\n    ## auto play after rendering\n    @play 1\n    ## number of output channels\n    @numchannels 2\n    ## sampling rate\n    @sr 48000\n    ## fade in/out duration\n    @fade 0\n)\n"})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var r=t(6540);const i={},a=r.createContext(i);function o(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);